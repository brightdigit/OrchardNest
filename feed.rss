<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift by Sundell</title><description>Weekly Swift articles, podcasts and tips by John Sundell</description><link>https://www.swiftbysundell.com</link><language>en-us</language><lastBuildDate>Tue, 30 Jun 2020 19:31:23 +0200</lastBuildDate><pubDate>Tue, 30 Jun 2020 19:31:23 +0200</pubDate><ttl>250</ttl><atom:link href="https://www.swiftbysundell.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/76</guid><title>Podcast: “A huge year for SwiftUI”, a WWDC20 special with Josh Shaffer and Eliza Block</title><description>Josh Shaffer and Eliza Block from Apple join John to talk about what’s new in SwiftUI, how Xcode Previews work under the hood, the new home screen widget system, Apple’s internal process of adopting and improving SwiftUI, and much more.</description><link>https://www.swiftbysundell.com/podcast/76</link><pubDate>Tue, 30 Jun 2020 18:50:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell76.mp3" type="audio/mpeg"/></audio><p>Josh Shaffer and Eliza Block from Apple join John to talk about what’s new in SwiftUI, how Xcode Previews work under the hood, the new home screen widget system, Apple’s internal process of adopting and improving SwiftUI, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://instabug.com/sundell">Instabug</a>:</strong> Join thousands of companies, including Lyft and eBay, who use Instabug to enhance their app quality and iterate faster. It’s perfect for teams that are working remotely. Go to <a href="https://instabug.com/sundell">instabug.com/sundell</a> to try it for free for 3 months.</li><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/joshshaffer">Josh on Twitter</a></li><li><a href="https://twitter.com/elizablock">Eliza on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.swiftbysundell.com/podcast/59/">Last year’s episode with Josh</a></li><li><a href="https://developer.apple.com/documentation/swiftui">SwiftUI’s documentation</a></li><li><a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable">UIViewRepresentable</a></li><li><a href="https://developer.apple.com/documentation/swiftui/app">App</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scene">Scene</a></li><li><a href="https://developer.apple.com/documentation/swiftui/colorpicker">The new ColorPicker</a></li><li><a href="https://developer.apple.com/documentation/swiftui/stateobject">StateObject</a></li><li><a href="https://developer.apple.com/documentation/clockkit/creating_complications_for_your_watchos_app">watchOS complications</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scrollview/drawinggroup(opaque:colormode:)">DrawingGroup</a></li><li><a href="https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension">Widgets</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scene/commands(content:)">The new commands modifier</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsdocument">NSDocument</a></li><li><a href="https://developer.apple.com/documentation/swiftui/documentgroup">DocumentGroup</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/learning-swiftui-by-building-tools-and-prototypes</guid><title>Learning SwiftUI by building tools and prototypes</title><description>Let’s take a look at one possible venue for learning and exploring SwiftUI without having to necessarily deploy it directly into production — by building internal tools and various prototypes.</description><link>https://www.swiftbysundell.com/articles/learning-swiftui-by-building-tools-and-prototypes</link><pubDate>Sun, 28 Jun 2020 21:15:00 +0200</pubDate><content:encoded><![CDATA[<p>A year ago, before WWDC 2019 kicked off, there was a lot of speculation and debate within the Apple developer community as to whether Apple would finally start shipping <em>Swift-only frameworks</em>.</p><p>At the time, the notion that Apple would depart from its established strategy of maintaining full backward compatibility with Objective-C might’ve seemed like a quite radical idea, but nonetheless, that’s what ended up happening — with the introduction of frameworks like <a href="https://www.swiftbysundell.com/basics/combine">Combine</a>, <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> and <a href="https://developer.apple.com/documentation/cryptokit">CryptoKit</a>.</p><p>Fast-forward to now, June of 2020, and the concept of Swift-only frameworks is now not just a possibility — it’s quite arguably the <em>new normal</em>, at least for new additions to Apple’s various SDKs. But Apple didn’t stop there. This year, at WWDC20, we saw the introduction of Apple’s first-ever <em>SwiftUI-only</em> framework — <a href="https://wwdcbysundell.com/2020/getting-started-with-widgetkit">WidgetKit</a>.</p><p>Now, depending on who you ask, the fact that the new home screen widgets that Apple announced during the WWDC20 keynote can <em>only</em> be built with SwiftUI might sound anywhere from amazing, to terrible, to downright scary. While it’s fair to say that SwiftUI has in many ways taken the Apple developer community by storm, and has enabled a lot of new developers to start building their first apps, the current opinions on SwiftUI are divisive to say the least.</p><p>However, whether you consider SwiftUI to be a fantastic new way of building apps, or something that’s not quite production-ready, one thing has been made quite clear — SwiftUI is here to stay.</p><p>So this week, let’s take a look at <em>one possible venue</em> for learning and exploring SwiftUI — one that I’ve personally taken during the past year — by building internal tools and various prototypes.</p><h2>Learning doesn’t necessarily mean deploying</h2><p><em>“Should I learn SwiftUI?”</em> is, without a doubt, one of the most common questions that I’ve been asked over the past year.</p><p>Now, I always try to be incredibly careful when answering questions like that, since it’s very difficult to give any sort of concrete advice as to what any given developer should or shouldn’t do, without being familiar with their personal context. For example, what kind of app are they working on, what does their user base look like, and how does their team or company operate?</p><p>However, this year’s announcements from Apple have significantly shifted my default answer as to whether a developer working on Apple’s platforms should learn SwiftUI — towards simply being <em>”yes”</em>.</p><p>It’s important to remember that you don’t have to deploy something within your main production code base in order to learn it. In fact, I personally try to do as much of my learning as possible <em>outside</em> of my shipping code, not just when it comes to SwiftUI, but in general.</p><p>While it’s often great to have a concrete use case in mind when learning something, there are so many ways to write highly valuable code without actually shipping it to customers, which heavily reduces the inherent risk associated with shipping apps or features using technologies that we haven’t yet fully familiarized ourselves with.</p><h2>Building internal tools and prototypes</h2><p>When it comes to SwiftUI in particular, its very lightweight syntax in many ways makes it ideal for tasks like prototyping, building internal tools and utilities, user testing, and hobby projects. For example, let’s say that we wanted to add a view to internal builds of our app that lets both developers and designers preview all colors within a set of themes, and that those themes are defined using a struct that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Theme {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isDark: <span class="s-type">Bool</span>
    <span class="s-keyword">var</span> brandColor: <span class="s-type">UIColor</span>
    <span class="s-keyword">var</span> activeButtonColor: <span class="s-type">UIColor</span>
    <span class="s-keyword">var</span> titleColor: <span class="s-type">UIColor</span>
    ...
}</code></pre><p>To make those previews happen, we can use a bit of <a href="https://www.swiftbysundell.com/articles/reflection-in-swift">reflection</a> to extract all of the colors from an instance of the above <code>Theme</code> type, and then render a list of them by writing just a tiny amount of SwiftUI code — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if INTERNAL_BUILD</span>
<span class="s-keyword">struct</span> ColorList {
    <span class="s-keyword">var</span> entries = [(color: <span class="s-type">UIColor</span>, name: <span class="s-type">String</span>)]()
}

<span class="s-keyword">extension</span> <span class="s-type">Theme</span> {
    <span class="s-keyword">func</span> makeColorList() -&gt; <span class="s-type">ColorList</span> {
        <span class="s-keyword">let</span> mirror = <span class="s-type">Mirror</span>(reflecting: <span class="s-keyword">self</span>)
        <span class="s-keyword">var</span> list = <span class="s-type">ColorList</span>()

        <span class="s-keyword">for</span> (label, value) <span class="s-keyword">in</span> mirror.<span class="s-property">children</span> {
            <span class="s-keyword">guard let</span> color = value <span class="s-keyword">as</span>? <span class="s-type">UIColor</span>,
                  <span class="s-keyword">let</span> name = label <span class="s-keyword">else</span> {
                <span class="s-keyword">continue</span>
            }

            list.<span class="s-property">entries</span>.<span class="s-call">append</span>((color, name))
        }

        <span class="s-keyword">return</span> list
    }
}

<span class="s-keyword">struct</span> ColorListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> list: <span class="s-type">ColorList</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(list.<span class="s-property">entries</span>, id: \.<span class="s-property">name</span>) { entry <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Circle</span>()
                    .<span class="s-call">fill</span>(<span class="s-type">Color</span>(entry.<span class="s-property">color</span>))
                    .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
                <span class="s-type">Text</span>(entry.<span class="s-property">name</span>)
            }
        }
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note how all of the above code is wrapped within a custom <code>INTERNAL_BUILD</code> <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift/%23conditional-compilation">compiler flag</a>, which lets us avoid including that code in App Store builds of our app.</p><p>Let’s say that our app currently ships with two themes — one for light mode and one for dark mode — so let’s also add a list view that lets us select which of those two themes to preview. We’ll also modify each theme’s <code>ColorListView</code> instance to match its corresponding system color scheme, in order to make our previews even more accurate:</p><pre class="splash"><code><span class="s-preprocessing">#if INTERNAL_BUILD</span>
<span class="s-keyword">struct</span> ThemeListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> themes: [<span class="s-type">Theme</span>] = [.<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">dark</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(themes, id: \.<span class="s-property">name</span>) { theme <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(theme.<span class="s-property">name</span>,
                    destination: <span class="s-type">ColorListView</span>(
                        list: theme.<span class="s-call">makeColorList</span>()
                    )
                    .<span class="s-call">colorScheme</span>(theme.<span class="s-property">isDark</span> ? .<span class="s-dotAccess">dark</span> : .<span class="s-dotAccess">light</span>)
                    .<span class="s-call">navigationBarTitle</span>(<span class="s-type">Text</span>(theme.<span class="s-property">name</span>),
                        displayMode: .<span class="s-dotAccess">inline</span>
                    )
                )
            }
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Select a theme"</span>)
        }
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note that if the above code was meant to go into production, or used to render a large list of themes, then we probably wouldn’t want to perform our <code>makeColorList</code> conversion inline within our view’s <code>body</code>. But that’s the beauty of building internal tools and prototypes — we can take shortcuts!</p><p>The above is of course just an example, but if we think about it, just by writing that small amount of SwiftUI code we’ve already had to learn about some of its fundamental concepts — like <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">view composition</a>, <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">layout</a>, <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">modifiers</a>, navigation, and so on. Plus, besides the learning aspect, we also ended up with a super useful tool for both the developers and designers on our team — pretty great!</p><p>SwiftUI is also excellent for prototyping. Just like when building an internal tool, we typically want to spend as little time as possible on any given prototype, since the point of doing prototyping to begin with is to quickly learn whether a given idea or feature is viable.</p><p>What makes SwiftUI so great in this context is that, since it relies on strong defaults and platform conventions, it lets us get down to building our prototype right away — with almost no setup required. Just look at the following code sample — that’s everything that’s now (as of Xcode 12) required to get started with a fully functional SwiftUI-based app:</p><pre class="splash"><code><span class="s-keyword">@main struct</span> MyPrototype: <span class="s-type">App</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">Scene</span> {
        <span class="s-type">WindowGroup</span> {
            <span class="s-type">Text</span>(<span class="s-string">"Let's start prototyping!"</span>)
        }
    }
}</code></pre><h2>Easing our way into production</h2><p>Of course, SwiftUI is not just a prototyping tool, it’s a powerful UI framework that’s increasingly used to ship projects ranging from smaller indie apps to large-scale production software. So when and how could it be a good idea to use it within the code that we actually ship to our customers?</p><p>Besides it being a young framework, perhaps the most major limiting factor when it comes to SwiftUI adoption is the fact that it won’t run on operating systems older than iOS 13 or macOS Catalina — which might not be acceptable for a large number of projects, even though that’ll most likely change when Apple’s upcoming OS versions are released later this year.</p><p>However, as mentioned in last year’s post-WWDC article <em><a href="https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift">“Shifting paradigms in Swift”</a></em>, SwiftUI is far from an “all-or-nothing” type of proposition. Its <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match">interoperability with UIKit and AppKit</a> is really strong, meaning that we might be able to just use SwiftUI to build a small feature that we only make available to users running iOS 13 and above (which at this point should be the vast majority for most apps). Or, we might use it to implement features that rely on newer system APIs, such as <a href="https://wwdcbysundell.com/2020/getting-started-with-widgetkit">widgets</a> or <a href="https://wwdcbysundell.com/2020/a-first-look-at-app-clips-in-ios-14">app clips</a>.</p><p>Just like how building tools, prototypes and hobby projects can let us learn a new framework in a “safer environment” — if we start adopting SwiftUI in just a small part of an existing app, we’re also likely to discover whether or not it’s <em><a href="https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies/%23to-be-or-not-to-be-production-ready">production-ready</a></em> for our particular use cases much quicker. Because even though both Apple and many third party developers are already deploying SwiftUI in production doesn’t mean that it’s going to be the perfect tool for every single app, at least not until it’s had more time to mature as a framework.</p><h2>Conclusion</h2><p>Now the big question is — why spend all of the time and effort required to learn a brand new UI framework when UIKit and AppKit already has everything that’s needed to build a great app?</p><p>For me, besides the excitement to learn new technologies and the fact that SwiftUI has made me a lot more productive when building many different kinds of UIs, it all comes down to <em>future-proofing</em>.</p><p>If it’s one thing I’ve learned from a decade of app development for Apple’s platforms, it’s that the more you align your projects with Apple’s vision for where their platforms are headed, the better. UIKit and AppKit might not be going away anytime soon, but WidgetKit is likely not going to be the last SwiftUI-only framework that Apple will ever release.</p><p>SwiftUI might still have ways to go in order to become the ultimate UI development framework, and it still has rough edges here and there, but — at least in my opinion — it’s definitely worth learning, even if you’ll just end up using it to build tools and prototypes for now.</p><p>Got questions, comments or feedback? Feel free to <a href="https://www.swiftbysundell.com/contact">send me an email</a> or find me <a href="https://twitter.com/johnsundell">on Twitter @johnsundell</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/workingcopy-june-2020</guid><title>Sponsor: Working Copy</title><description>Thanks a lot to Working Copy for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/workingcopy-june-2020</link><pubDate>Thu, 25 Jun 2020 22:22:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to indie developer Anders Borum for sponsoring Swift by Sundell this week to promote his fantastic iOS Git client <em><a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">Working Copy</a></em>.</p><p>If you do any sort of Git-related work on your iPad, then I really recommend trying out Working Copy. It’s fast, easy to use, and gives you access to many powerful Git features through an elegant, iOS-native UI. Clone repos, create branches and commits, view diffs, and push changes — all from your iPad!</p><p>Working Copy also connects beautifully to many different system features — such as the Files app, Shortcuts, and the iOS share sheet — and Anders has been constantly improving the app ever since it was launched just after WWDC 2014.</p><p>During the week of WWDC20, you’ll get <strong>25% off the Pro version</strong> of Working Copy, so <a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">check it out today</a>, and make sure to unlock the Pro version before the week is over to get that really nice discount, and to support two indie developers — both Anders and me — at the same time.</p><p><strong><a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">Download Working Copy from the App Store</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/a-first-look-at-swiftui-stateobject</guid><title>Tip: A first look at SwiftUI’s new StateObject property wrapper</title><description>How SwiftUI’s new StateObject property wrapper works, and how it compares to ObservedObject.</description><link>https://www.swiftbysundell.com/tips/a-first-look-at-swiftui-stateobject</link><pubDate>Thu, 25 Jun 2020 13:10:00 +0200</pubDate><content:encoded><![CDATA[<p>Being a declarative UI framework, state and data management is an incredibly important part of SwiftUI. Since day one, it has been shipping with a suite of protocols and property wrappers that let us define, update and observe our view’s data in various ways — and this year, there’s a new member of that family: <code>StateObject</code>.</p><p class="info">⚠️ This article is covering technologies that are currently in beta as part of Xcode 12, so it’s possible that some of the APIs used will change during the beta period.</p><p>Let’s say that we’re working on an app for browsing movies, and that we’re storing those movies using a <code>MovieStore</code> class — which is an <code>ObservableObject</code> that exposes an array of <code>Movie</code> values using the <code>Published</code> property wrapper:</p><pre class="splash"><code><span class="s-keyword">class</span> MovieStore: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> movies: [<span class="s-type">Movie</span>]
    
    ...
}</code></pre><p>Before the version of SwiftUI included in Xcode 12, we might’ve then used the <code>ObservedObject</code> property wrapper to enable a <code>MovieListView</code> to observe an injected instance of the above store class — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieListView: <span class="s-type">View</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">@ObservedObject var</span> store: <span class="s-type">MovieStore</span></span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(store.<span class="s-property">movies</span>) { movie <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(movie.<span class="s-property">name</span>,
                    destination: <span class="s-type">MovieDetailsView</span>(
                        store: store,
                        movieID: movie.<span class="s-property">id</span>
                    )
                )
            }
            .<span class="s-call">navigationTitle</span>(<span class="s-string">"My movies"</span>)
        }
    }
}</code></pre><p>Although the above <code>MovieListView</code> does hold a reference to the <code>MovieStore</code> that it was injected with, and can pass that store instance along to any child views that it creates (such as the above <code>MovieDetailsView</code>), our view is actually <em>not the owner</em> of that store object.</p><p>It’s important to remember that SwiftUI views are <em>not</em> view objects in the “classic sense”, but rather lightweight value <em>descriptions</em> of our UI, which means that our view instances don’t really have lifecycles like class instances do. Therefore, we always need to make sure to retain any <code>ObservableObject</code> instances that we inject into our views elsewhere — for example within some form of dependency container.</p><p>This is where <code>StateObject</code> comes in, which provides a built-in way to have one of our views <em>assume ownership</em> over an <code>ObservableObject</code>. That way, we no longer need to retain that object elsewhere, since SwiftUI will manage it for us automatically, even as our views get updated and their values recreated.</p><p>Something that’s really nice is that if we wanted to change our above <code>MovieListView</code> to now use <code>StateObject</code> instead, we can actually keep the whole <code>body</code> of our view exactly the same — all that we need to do is replace <code>ObservedObject</code> with <code>StateObject</code>, and give our <code>store</code> property a default value — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieListView: <span class="s-type">View</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">@StateObject private var</span> store = <span class="s-type">MovieStore</span>()</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>Now, this doesn’t mean that <code>StateObject</code> is always a better alternative compared to <code>ObservedObject</code> — both have pros and cons. We should still keep using <code>ObservedObject</code> for injected dependencies that are retained and managed outside of our view hierarchy, while <code>StateObject</code> can be a great alternative for reference types that are used to keep track of a view’s internal state.</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/daily-wwdc20-coverage</guid><title>Link: WWDC by Sundell &amp; Friends</title><description></description><link>https://wwdcbysundell.com</link><pubDate>Mon, 22 Jun 2020 14:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like last year, I’ll be covering WWDC and its key announcements on my spin-off site <em><a href="https://wwdcbysundell.com">WWDC by Sundell</a></em>. The coverage will be highly technical, feature code samples and first looks at some of the new APIs and frameworks, and everything will be completely free for anyone to access.</p><p>What’s new this year, though, is that I’ve invited some of my friends from around the Apple developer community to share their thoughts and first impressions on the site as well, so this year it’s not just <em>WWDC by Sundell</em> — it’s <em>WWDC by Sundell &amp; Friends</em>.</p><p>I hope you’ll <a href="https://wwdcbysundell.com">enjoy the site</a>, and have a great WWDC week!</p><p class="info">Just like Swift by Sundell, the WWDC site also has its <a href="https://wwdcbysundell.com/feed.rss">own RSS feed</a> that you can subscribe to, if you’d like.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020</guid><title>A Swift developer’s WWDC dreams - 2020 edition</title><description>With just a few hours to go until WWDC20 kicks off with the first ever online-only Apple keynote, I thought I’d do the same thing as I did last year, and share a few of my biggest Swift-related dreams for this upcoming WWDC.</description><link>https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020</link><pubDate>Sun, 21 Jun 2020 17:25:00 +0200</pubDate><content:encoded><![CDATA[<p>With just a few hours to go until WWDC20 kicks off with the first ever online-only Apple keynote, I thought I’d do the same thing as I did <a href="https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams">last year</a>, and share a few of my biggest Swift-related dreams for this upcoming WWDC.</p><p>These are not really predictions, nor are they based on any form of insider information — instead they’re simply my biggest wishes for Apple’s upcoming conference when it comes to Swift and its related tooling. Let’s jump right in!</p><h2>SwiftUI 2.0</h2><p>Whether or not you consider SwiftUI in its current state to be “production ready”, I think it’s fair to say that a lot of developers are anticipating significant upgrades to Apple’s new UI framework during this year’s conference.</p><p>While I know from speaking to <a href="https://www.swiftbysundell.com/podcast/59">Josh Shaffer on the podcast</a> that Apple deliberately kept the initial API of SwiftUI narrow, in order to focus on its core set of building blocks during its first year as a public framework, I’d expect its scope to grow significantly with this year’s release.</p><p>Besides the classic “bug fixes and performance improvements”, I’d personally like to see changes such as a SwiftUI-native equivalent to UIKit’s <code>UICollectionView</code>, built-in support for other common views (such as activity indicators and map views), and a more powerful, <code>NSAttributedString</code>-style text API.</p><p>Although we’ve already been able to add support for the above types of views ourselves — for example by bringing existing <code>UIKit</code>-based views into SwiftUI using <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match"><code>UIViewRepresentable</code></a>, or by building brand new ones using SwiftUI itself — having a wider set of commonly used views built into the framework would be incredibly convenient.</p><p>Let’s take a closer look at <code>UICollectionView</code> as an example. While it’s totally possible to quickly create a very basic version of of a grid-based SwiftUI view, recreating the entire collection view API would require a lot more work. Here’s what such a basic grid implementation could look like, using SwiftUI’s <code>ViewBuilder</code> <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builder</a>, along with nested instances of <code>HStack</code> and <code>VStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Grid&lt;Cell: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">typealias</span> Position = (x: <span class="s-type">Int</span>, y: <span class="s-type">Int</span>)

    <span class="s-keyword">private let</span> content: (<span class="s-type">Position</span>) -&gt; <span class="s-type">Cell</span>
    <span class="s-keyword">private let</span> size: (width: <span class="s-type">Int</span>, height: <span class="s-type">Int</span>)

    <span class="s-keyword">init</span>(width: <span class="s-type">Int</span>,
         height: <span class="s-type">Int</span>,
         <span class="s-keyword">@ViewBuilder</span> content: <span class="s-keyword">@escaping</span> (<span class="s-type">Position</span>) -&gt; <span class="s-type">Cell</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = content
        <span class="s-keyword">self</span>.<span class="s-property">size</span> = (width, height)
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(<span class="s-number">0</span>..&lt;size.<span class="s-property">width</span>) { x <span class="s-keyword">in</span>
                <span class="s-type">VStack</span> {
                    <span class="s-type">ForEach</span>(<span class="s-number">0</span>..&lt;<span class="s-keyword">self</span>.<span class="s-property">size</span>.<span class="s-property">height</span>) { y <span class="s-keyword">in
                        self</span>.<span class="s-call">content</span>((x, y))
                    }
                }
            }
        }
    }
}</code></pre><p class="info">The above implementation uses tuples as lightweight types. Check out <a href="https://www.swiftbysundell.com/articles/using-tuples-as-lightweight-types-in-swift">this article</a> to learn more.</p><p>The fact that the above is all that it takes to create a basic grid view is really a testament to just how powerful SwiftUI’s API already is, but the above implementation is still a <em>far cry</em> from all of the flexibility that <code>UICollectionView</code> (and its AppKit equivalent) offers, especially when it comes to things like flow layouts and dynamic item sizes.</p><h2>Swift Package Manager for apps and playgrounds</h2><p>Ever since Xcode started offering <a href="https://wwdcbysundell.com/2019/xcode-swiftpm-first-look">built-in support</a> for the Swift Package Manager as part of last year’s release of Xcode 11, I think it’s fair to say that Swift’s official dependency manager has been significantly growing in both power and popularity.</p><p>While it’s always been possible to <em>build</em> a Swift package using Xcode (using the <code>generate-xcodeproj</code> command), this new built-in support both meant that apps could now easily import Swift packages as dependencies, and that package authors could directly open their projects in Xcode without first having to generate a separate project file for them.</p><p>Now, imagine if Apple took this a step further by enabling entire iOS or Mac apps to be defined as Swift packages — for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"MyApp"</span>,
    products: [
        .<span class="s-call">application</span>(
            name: <span class="s-string">"MyApp"</span>,
            targets: [<span class="s-string">"MyApp-iOS"</span>, <span class="s-string">"MyApp-macOS"</span>]
        )
    ],
    dependencies: [
        .<span class="s-call">package</span>(
            name: <span class="s-string">"Files"</span>,
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
            from: <span class="s-string">"4.0.0"</span>
        ),
        .<span class="s-call">package</span>(
            name: <span class="s-string">"Codextended"</span>,
            url: <span class="s-string">"https://github.com/johnsundell/codextended.git"</span>,
            from: <span class="s-string">"0.3.0"</span>
        )
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"MyApp-iOS"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"Codextended"</span>],
            platform: .<span class="s-dotAccess">iOS</span>
        ),
        .<span class="s-call">target</span>(
            name: <span class="s-string">"MyApp-macOS"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"Codextended"</span>],
            platform: .<span class="s-dotAccess">macOS</span>
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"MyAppTests-iOS"</span>,
            dependencies: [<span class="s-string">"MyApp-iOS"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"MyAppTests-macOS"</span>,
            dependencies: [<span class="s-string">"MyApp-macOS"</span>]
        )
    ]
)</code></pre><p>Apart from my wishful <code>.application</code> product, and the ability to declare platform constraints for individual targets, the above is a perfectly valid <code>Package.swift</code> manifest. So while I’m sure that the underlying changes needed to make the above kind of feature possible would be quite substantial, it wouldn’t necessarily require a ton of changes to the package description API itself — since all of the pieces required to define targets and import dependencies are already there.</p><p>Combine that with the fact that SwiftPM is about to start supporting bundled resources (such as images, XIBs, or any other sort of custom files) as part of the upcoming Swift 5.3 release, and the package manager could become quite a capable tool for building entire (non-command line, non-server-side) applications.</p><p>While I’d expect an initial release of such a feature to just support a very limited amount of customization options and build settings, I think many teams would happily take that tradeoff in order to be able to completely say goodbye to Xcode project file conflicts, once and for all.</p><p>I would also really like to see the Swift Playgrounds app adopt SwiftPM as its module management tool. While I absolutely love the very lightweight way in which modules can be created within a playground — which I also mentioned in <a href="https://www.swiftbysundell.com/articles/review-swift-playgrounds-30-for-ipad">my review of the 3.0 version of the app</a> — being able to instantly open a Swift package (and all of its dependencies) within the Playgrounds app would be incredible, and would make it so much easier to move code between the Mac and the iPad.</p><p class="info">For more details on Swift Playgrounds’ module system, listen to my <a href="https://www.swiftbysundell.com/podcast/69">podcast conversation with Holly Borla and Grace Kendall from Apple</a>, during which they went into lots of details about how the Playgrounds app was built.</p><h2>Xcode on iPad</h2><p>Along those same lines, I don’t think I would be able to put together any kind of WWDC wishlist without mentioning Xcode on iPad. As someone who loves working on both the Mac and the iPad (the Mac when I’m at my desk, the iPad everywhere else), I would love to be able to seamlessly move all of my projects between those two devices.</p><p>So often when Xcode on iPad is discussed, the conversation tends to end up with the question of whether either the iPad or the Mac is the best device for development, but I personally think that’s beside the point. I don’t want Xcode for Mac to be discontinued, and I don’t want to do <em>all</em> of my development work on the iPad — but wouldn’t it be wonderful if we were all free to choose which device to work on at any given time, without having to jump through a ton of hoops?</p><p>Will this be the year we’ll see Xcode on iPad? I honestly don’t know, but I <em>really</em> hope so. The current iPad Pro hardware (even the 2018 model, which I own) is more than capable of compiling and running Swift code, there’s now support for both hardware keyboards and pointing devices, and Swift Playgrounds has shown me and many others that building iOS UIs on an actual iOS device is <em>amazing</em>. The iteration speed between testing and interacting with a piece of UI, and making tweaks to it, when everything is running right directly on a touch-capable device, is simply outstanding.</p><p>Now, like I’ve <a href="https://twitter.com/johnsundell/status/1252944192243937280">mentioned earlier on Twitter</a>, I don’t expect this hypothetical iPad-version of Xcode to have nearly the same amount of features as its Mac equivalent. Instead I would expect it to be a more <em>lightweight</em> version of Xcode focused on SwiftUI-based iOS app development, at least for the first iteration of it.</p><h2>End-to-end Swift</h2><p>Finally, I would love for Apple to more clearly embrace server-side Swift within Xcode and their various platform SDKs. While Apple have <a href="https://www.swiftbysundell.com/podcast/42">confirmed that they’re using server-side Swift in production themselves</a>, and while they’ve made substantial investments in server-side technologies like <a href="https://github.com/apple/swift-nio">SwiftNIO</a> and <a href="https://github.com/apple/swift-crypto">Swift Crypto</a>, I have a few wishes as to how they could take things to the next level.</p><p>One significant trend within the server-side world over the past few years has been the rise of cloud (or “serverless”) functions. It’s the idea that, rather than running any kind of server yourself, you instead just submit a piece of code to a cloud service, and then that service will automatically run that code for you and manage all required system resources — completely automatically.</p><p>Just a few weeks ago (at the time of writing), Amazon officially launched their <em><a href="https://swift.org/blog/aws-lambda-runtime">Swift AWS Lambda Runtime</a></em>, which lets developers write such cloud functions in Swift, and then deploy and run them on Amazon’s vast AWS infrastructure. That’s incredibly cool, but I’d also love to see Apple’s own take on such a system.</p><p>As an example, imagine being able to run custom cloud functions as part of CloudKit — for example in order to perform server-side validation of records that were sent from an iOS or Mac app, using the same <code>CKRecord</code> API that CloudKit uses on the client-side, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> ValidationError: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> invalidRecordType
    <span class="s-keyword">case</span> missingIngredients
    ...
}

<span class="s-comment">// This function would be automatically invoked server-side by
// the CloudKit servers, and passed any CKRecord instance that
// was submitted from a client app. The function either throws
// an error, or allows the record to be saved to the database:</span>
<span class="s-keyword">func</span> validate(<span class="s-keyword">_</span> record: <span class="s-type">CKRecord</span>) <span class="s-keyword">throws</span> {
    <span class="s-keyword">guard</span> record.<span class="s-property">recordType</span> == <span class="s-string">"Recipe"</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">ValidationError</span>.<span class="s-property">invalidRecordType</span>
    }

    <span class="s-keyword">guard let</span> ingredients = record[<span class="s-string">"ingredients"</span>] <span class="s-keyword">as</span>? [<span class="s-type">String</span>],
          !ingredients.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">ValidationError</span>.<span class="s-property">missingIngredients</span>
    }
    
    ...
}</code></pre><p class="info">The above function uses Swift’s built-in error mechanism as part of its control flow. Check out <a href="https://www.swiftbysundell.com/articles/using-errors-as-control-flow-in-swift">this article</a> for more on that topic.</p><p>While the above kind of CloudKit and iCloud customization would be incredibly cool, and enable developers to iterate on their iCloud-based code without having to ship new versions of their apps — it would perhaps be even cooler if we would be able to build <em>completely custom</em> function-based backends that would be automatically deployed on Apple’s servers.</p><p>Don’t get me wrong, projects like SwiftNIO and <a href="https://vapor.codes">Vapor</a> are incredible, and already enable server-side applications to be built in Swift — but my final dream (for this article) is to be able to simply write a request handler like the one below, as part of an app project, and then have it be automatically synced to an Apple-provided cloud service that would host it and run it for me:</p><pre class="splash"><code><span class="s-comment">// This function returns a note based on a parameter that was
// sent from the client, and uses Combine to facilitate the
// communication between the server and the client:</span>
<span class="s-keyword">func</span> handleRequest(<span class="s-keyword">_</span> request: <span class="s-type">Request</span>,
                   responder: <span class="s-type">ResponderPublisher</span>) {
    <span class="s-keyword">guard let</span> noteID = request.<span class="s-call">parameter</span>(named: <span class="s-string">"id"</span>) <span class="s-keyword">else</span> {
        <span class="s-keyword">let</span> error = <span class="s-type">MissingParameterError</span>(name: <span class="s-string">"id"</span>)
        <span class="s-keyword">return</span> responder.<span class="s-call">send</span>(completion: .<span class="s-call">failure</span>(error))
    }

    <span class="s-keyword">guard let</span> data = <span class="s-type">KeyValueStore</span>.<span class="s-call">data</span>(forKey: noteID) <span class="s-keyword">else</span> {
        <span class="s-keyword">let</span> error = <span class="s-type">UnknownNoteError</span>(id: noteID)
        <span class="s-keyword">return</span> responder.<span class="s-call">send</span>(completion: .<span class="s-call">failure</span>(error))
    }

    responder.<span class="s-call">send</span>(data)
    responder.<span class="s-call">send</span>(completion: .<span class="s-dotAccess">finished</span>)
}</code></pre><p>While the above is a really simple example in the grand scheme of things, I think if app developers would be able to write and deploy small cloud functions using a language and set of frameworks that they’re already familiar with (such as <a href="https://www.swiftbysundell.com/basics/combine">Combine</a>), then that could enable many kinds of apps to utilize dynamic, server-side functionality — without requiring those developers to either maintain their own servers, or rely on a third-party service.</p><h2>Conclusion</h2><p>So those are my biggest Swift-related dreams for this year’s WWDC. Hope you enjoyed reading this article, and if you did, then make sure to check out <a href="https://wwdcbysundell.com">WWDC by Sundell &amp; Friends</a> — a brand new website on which me and some of my friends will cover WWDC20 in great detail all throughout next week.</p><p>What do you think? Do you share some of my dreams, or do you have any other Swift-related things that you’d like to see Apple introduce next week? Let me know, either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/organizing-default-argument-values</guid><title>Tip: Organizing default argument values</title><description></description><link>https://www.swiftbysundell.com/tips/organizing-default-argument-values</link><pubDate>Sat, 20 Jun 2020 15:45:00 +0200</pubDate><content:encoded><![CDATA[<p>Using <a href="https://www.swiftbysundell.com/articles/default-arguments-in-swift">default arguments</a> can be a great way to make a given type or function easier to use, and can let us achieve a certain level of consistency between call sites that don’t require any form of customization.</p><p>As an example, let’s say that we’re working on an <code>ImageLoader</code>, which is initialized with a <code>ImageLoadingSettings</code> value that determines how each image loader instance should behave. Since we don’t want to <em>require</em> such a settings value to be explicitly passed, we’ll default to creating a new instance of it as a convenience — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> settings: <span class="s-type">ImageLoadingSettings</span>

    <span class="s-keyword">init</span>(settings: <span class="s-type">ImageLoadingSettings</span> = .<span class="s-keyword">init</span>()) {
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    ...
}</code></pre><p>For structs, such as the <code>ImageLoadingSettings</code> type that we used above, we can also make use of default parameter values — which will automatically get translated into default initializer arguments by the compiler:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageLoadingSettings {
    <span class="s-keyword">var</span> baseURL = <span class="s-type">URL</span>(string: <span class="s-string">"https://my-cdn.com"</span>)!
    <span class="s-keyword">var</span> timeoutInterval: <span class="s-type">TimeInterval</span> = <span class="s-number">120</span>
    <span class="s-keyword">var</span> defaultFormat = <span class="s-type">ImageFormat</span>.<span class="s-property">png</span>
}</code></pre><p class="info">Note that the memberwise initializers that the compiler automatically synthesizes are only visible internally within the same module that a given type is defined in. To learn more, check out <a href="https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used">“When can a struct’s memberwise initializer be used?”</a>.</p><p>Another option, which also works for public APIs that should be accessible outside of the module that they’re defined in, is to use <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static properties or factory methods</a>. For example, here’s how we could extend <code>ImageLoadingSettings</code> with a static <code>default</code> property that returns a new instance populated with the default settings values:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageLoadingSettings</span> {
    <span class="s-keyword">static var</span> `default`: <span class="s-type">ImageLoadingSettings</span> {
        <span class="s-type">ImageLoadingSettings</span>(
            baseURL: <span class="s-type">URL</span>(string: <span class="s-string">"https://my-cdn.com"</span>)!,
            timeoutInterval: <span class="s-number">120</span>,
            defaultFormat: .<span class="s-dotAccess">png</span>
        )
    }
}</code></pre><p>With the above in place, we can now use this really neat dot-syntax to define our default argument from before:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> settings: <span class="s-type">ImageLoadingSettings</span>

    <span class="s-keyword">init</span>(settings: <span class="s-type">ImageLoadingSettings</span> = .<span class="s-dotAccess">default</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    ...
}</code></pre><p>While either of the above two approaches tend to work great for types that we’ve created ourselves — they can be a bit tricky to use when it comes to types that ship as part of the standard library.</p><p>For example, let’s now say that we’re looking to provide a convenient way to initialize an <code>ImageTransformer</code> with an array of default <code>ImageEffect</code> values. One way to model those values would be to use a slight twist on the static property approach that we took above, and add such a property to the <code>Array</code> type itself, using a <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4/%23same-type-constraints">same-type constrained</a> extension:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">ImageEffect</span> {
    <span class="s-keyword">static var</span> defaultEffects: <span class="s-type">Self</span> {
        [.<span class="s-dotAccess">increaseContrast</span>, .<span class="s-dotAccess">normalizeColors</span>, .<span class="s-dotAccess">cropToSquare</span>]
    }
}

<span class="s-keyword">class</span> ImageTransformer {
    <span class="s-keyword">private let</span> effects: [<span class="s-type">ImageEffect</span>]

    <span class="s-comment">// We can again use this really nice dot-syntax to specify
    // our default argument value:</span>
    <span class="s-keyword">init</span>(effects: [<span class="s-type">ImageEffect</span>] = .<span class="s-dotAccess">defaultEffects</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">effects</span> = effects
    }
    
    ...
}</code></pre><p>However, while the above initializer looks really nice, it’s arguably a bit strange to have the <code>Array</code> type be aware of what our image transformer’s defaults are — even if we make that extension private (which works as long as our <code>ImageTransformer</code> remains internal in terms of <a href="https://www.swiftbysundell.com/basics/access-control">access level</a>).</p><p>So an alternative way to accomplish the exact same thing would be to instead add that static property to our <code>ImageTransformer</code> type itself — because it turns out that we can reference a type’s static properties directly within its initializer parameter list, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageTransformer {
    <span class="s-keyword">private let</span> effects: [<span class="s-type">ImageEffect</span>]

    <span class="s-keyword">init</span>(effects: [<span class="s-type">ImageEffect</span>] = defaultEffects) {
        <span class="s-keyword">self</span>.<span class="s-property">effects</span> = effects
    }
    
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">ImageTransformer</span> {
    <span class="s-keyword">static var</span> defaultEffects: [<span class="s-type">ImageEffect</span>] {
        [.<span class="s-dotAccess">increaseContrast</span>, .<span class="s-dotAccess">normalizeColors</span>, .<span class="s-dotAccess">cropToSquare</span>]
    }
}</code></pre><p>Of course, we could’ve also defined the above <code>defaultEffects</code> property within our main type declaration, rather than using an extension — but the above approach sort of gives us a nice separation between our main type declaration and its default values.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/uidesignmanager-june-2020</guid><title>Sponsor: UIDesignManager</title><description>Thanks a lot to UIDesignManager for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/uidesignmanager-june-2020</link><pubDate>Fri, 19 Jun 2020 12:45:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to the team behind <a href="https://uidesignmanager.com/?utm_source=swiftbysundell">UIDesignManager</a> for sponsoring Swift by Sundell this week, which helps me keep the site free and available to everyone around the world.</p><p>UIDesignManager is a tool that lets developers and designers quickly iterate on an app’s UI components — completely visually — without having to release a new version of it, whether that’s to TestFlight, or to the App Store.</p><p>If you’re building apps for clients, UIDesignManager can enable your clients to make tweaks to their apps on the fly, right on an iOS device, using the UIDesignStudio app. It works with both UIKit and SwiftUI, and you can try it for free for 30 days — so give it a go, and see just how fast it could let you iterate on your app’s UI.</p><p><a href="https://uidesignmanager.com/?utm_source=swiftbysundell">Try UIDesignManager for free</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/75</guid><title>Podcast: “The Swift package ecosystem”, with special guests Dave Verwer and Sven A. Schmidt</title><description>Dave Verwer and Sven A. Schmidt join John to talk about their newly launched Swift Package Index, and what the overall state of Swift’s package ecosystem currently is. Also, dependency management, composing libraries, deploying server-side Swift in production, and much more.</description><link>https://www.swiftbysundell.com/podcast/75</link><pubDate>Fri, 19 Jun 2020 10:45:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell75.mp3" type="audio/mpeg"/></audio><p>Dave Verwer and Sven A. Schmidt join John to talk about their newly launched Swift Package Index, and what the overall state of Swift’s package ecosystem currently is. Also, dependency management, composing libraries, deploying server-side Swift in production, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://nordvpn.com/sundell">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on. Get 50% off their one-year plan at <a href="https://nordvpn.com/sundell">nordvpn.com/sundell</a>, or when using offer code <em>SUNDELL</em>.</li><li><strong><a href="https://bitrise.io/swift">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href="https://bitrise.io/swift">bitrise.io/swift</a>, and also check out their new podcast <a href="https://blog.bitrise.io/mobile-devops-is-a-thing-a-podcast-by-bitrise">“Mobile DevOps is a Thing!”</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/daveverwer">Dave on Twitter</a></li><li><a href="https://twitter.com/_sa_s">Sven on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://iosdevweekly.com">iOS Dev Weekly</a></li><li><a href="https://swiftpackageindex.com">The Swift Package Index</a></li><li><a href="https://finestructure.co/hummingbird">Hummingbird</a></li><li><a href="https://finestructure.co/revisor">Revisor</a></li><li><a href="https://github.com/JohnSundell/Plot">Plot</a></li><li><a href="https://github.com/finestructure/Arena">Arena</a></li><li><a href="https://vapor.codes">Vapor</a></li><li><a href="https://www.docker.com">Docker</a></li><li><a href="https://www.macstadium.com/orka">Orka</a></li><li><a href="https://forums.swift.org/t/swift-package-registry-service/37219">The GitHub package registry pitch on the Swift forums</a></li><li><a href="http://flask.pocoo.org">Flask</a></li><li><a href="https://www.djangoproject.com">Django</a></li><li><a href="https://daveverwer.com">Dave’s website</a></li><li><a href="https://finestructure.co">Sven’s website</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/useful-apis-when-writing-scripts-and-tools-in-swift</guid><title>Useful APIs when writing scripts and tools in Swift</title><description>Let’s take a look at a few key APIs and techniques that can be really useful when building custom developer tools, scripts, or other kinds of automation, in Swift.</description><link>https://www.swiftbysundell.com/articles/useful-apis-when-writing-scripts-and-tools-in-swift</link><pubDate>Sun, 14 Jun 2020 21:50:00 +0200</pubDate><content:encoded><![CDATA[<p>When building apps, it’s really common to rely on various kinds of scripts and custom developer tools in order to build, ship, and debug a code base. From formatting or validating both code-level symbols and linked resources, to running different kinds of tests, and even generating code — there are so many different tasks that can be automated one way or another.</p><p>While Swift’s heavy focus on compile-time safety and strong types might initially make it seem like an odd choice for writing scripts and automation, it does bring a lot of quite unique advantages to the table — such as enabling us to share code between an app and the scripts used to develop it, or just the fact that there’s no <em>context switching</em> needed to jump between working on a tool and an app that uses it.</p><p>So this week, let’s take a look at a few key APIs that can come very much in handy when using Swift in the context of scripting and tooling — focusing on those that come built-in as part of either the Swift standard library, or macOS as a platform.</p><p class="info">This article assumes that you are somewhat familiar with the Swift Package Manager, and won’t go into details when it comes to how to set up a Swift package for writing a script or custom developer tool, since that was covered in <a href="https://www.swiftbysundell.com/articles/building-a-command-line-tool-using-the-swift-package-manager"><em>“Building a command line tool using the Swift Package Manager”</em></a>.</p><h2>Accepting arguments</h2><p>Let’s start by taking a look at a few different ways of handling input within command line tools — with the most basic of which being to simply access the static <code>arguments</code> property on the built-in <code>CommandLine</code> type. That property contains an array of strings representing the various arguments that were passed when invoking our script or tool on the command line, and also includes the tool’s own <em>execution path</em> as the first element.</p><p>Here’s how we might use that API to extract a few parameters within a tool used to resize a given image:</p><pre class="splash"><code><span class="s-keyword">let</span> arguments = <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>

<span class="s-comment">// Since the first element is our tool's execution path, we'll
// start extracting our arguments from index 1, rather than 0:</span>
<span class="s-keyword">let</span> imagePath = arguments[<span class="s-number">1</span>]
<span class="s-keyword">let</span> width = <span class="s-type">Double</span>(arguments[<span class="s-number">2</span>])
<span class="s-keyword">let</span> height = <span class="s-type">Double</span>(arguments[<span class="s-number">3</span>])</code></pre><p class="info">Tip: When working on a script or tool in Xcode, we can specify what arguments to send to our program by editing its <code>Run</code> scheme (which can be opened by pressing <code>⌥ + ⌘ + R</code>).</p><p>However, one problem with the above code is that it’ll cause a crash if fewer than three arguments were passed — which isn’t great — so let’s also add a <code>guard</code> statement for handling those situations. If we received fewer arguments than expected, then we’ll use the <code>exit</code> function to terminate our program with a given <em>exit code</em>, after printing an error message:</p><pre class="splash"><code><span class="s-keyword">let</span> arguments = <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>

<span class="s-keyword">guard</span> arguments.<span class="s-property">count</span> &gt; <span class="s-number">3</span> <span class="s-keyword">else</span> {
    <span class="s-call">print</span>(<span class="s-string">"""
    Error: Expected 3 arguments: imagePath, width, and height.
    """</span>)
    <span class="s-call">exit</span>(<span class="s-number">1</span>)
}

...</code></pre><p>While using <code>CommandLine.arguments</code> is a really convenient way of accessing all of a program’s arguments in a linear fashion, sometimes we might want to retrieve the value for a <em>named argument</em> — that is, two arguments that make up a key/value pair.</p><p>While we could of course iterate through each argument and create a key/value map manually, we can actually use Foundation’s <a href="https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift"><code>UserDefaults</code></a> type to retrieve any named command line argument passed into our program — completely automatically:</p><pre class="splash"><code><span class="s-comment">// This will parse the values passed for "-width" and "-height" on
// the command line (that is, each key name prefixed with a dash):</span>
<span class="s-keyword">let</span> namedArguments = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
<span class="s-keyword">let</span> width = namedArguments.<span class="s-call">double</span>(forKey: <span class="s-string">"width"</span>)
<span class="s-keyword">let</span> height = namedArguments.<span class="s-call">double</span>(forKey: <span class="s-string">"height"</span>)</code></pre><p>What’s great about using <code>UserDefaults</code> to parse command line arguments (besides the fact that it’s a built-in API), is that we can choose whether we want it to return a specific type (such as <code>Double</code>, like above), or an optional raw <code>String</code>. Here’s how we might extract such a string, then transform it into a URL (using <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap"><code>flatMap</code></a>), and finally map any non-<code>nil</code> value into a <code>downloadHTML</code> function:</p><pre class="splash"><code><span class="s-comment">// When calling a throwing function within the global scope of
// a command line tool, we can simply prefix it with 'try', without
// first having to wrap it within a 'do' clause (unless we want
// to customize exactly how an error gets presented to the user):</span>
<span class="s-keyword">let</span> html = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">string</span>(forKey: <span class="s-string">"url"</span>)
    .<span class="s-call">flatMap</span>(<span class="s-type">URL</span>.<span class="s-property">init</span>)
    .<span class="s-call">map</span>(downloadHTML)</code></pre><p>Although <code>UserDefaults</code> also offers a <code>url</code> API that returns a <code>URL</code> value, those URLs are assumed to be local file URLs — so in case we’re looking to use remote web URLs, then extracting raw strings is typically a better option.</p><p class="info">While this article is focused on APIs that ship as part of the system, it’s also worth pointing out that Apple offers a much more powerful framework for parsing command line arguments, called <em>Swift Argument Parser</em>, which is available as a Swift package <a href="https://github.com/apple/swift-argument-parser">on GitHub</a>.</p><h2>Networking and other asynchronous tasks</h2><p>Next, let’s take a look at a few ways of implementing that <code>downloadHTML</code> function that we called above.</p><p>Networking, and other tasks that are highly asynchronous, can at first seem a bit tricky to perform within the context of a script or tool, since — unlike apps — command line tools are executed synchronously from top to bottom, and then immediately terminated. So how can we ensure that our program keeps running while we wait for an asynchronous task to complete?</p><p>One way to do that is to use Grand Central Dispatch’s <a href="https://www.swiftbysundell.com/articles/a-deep-dive-into-grand-central-dispatch-in-swift/%23waiting-for-asynchronous-tasks-with-dispatchsemaphore"><code>DispatchSempahore</code></a> API, which enables us to synchronously wait for an operation that’s being performed on a background queue. Using that, along with <code>URLSession</code> and its new <a href="https://www.swiftbysundell.com/basics/combine">Combine-powered</a> <code>dataTaskPublisher</code> API, we could download a string over the network like this:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">let</span> semaphore = <span class="s-type">DispatchSemaphore</span>(value: <span class="s-number">0</span>)
    <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">String</span>, <span class="s-type">Error</span>&gt;?

    <span class="s-keyword">let</span> publisher = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>
        .<span class="s-call">dataTaskPublisher</span>(for: url)
        .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
        .<span class="s-call">map</span> { <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>) }

    <span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
        receiveCompletion: { completion <span class="s-keyword">in
            switch</span> completion {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                result = .<span class="s-call">failure</span>(error)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
                <span class="s-keyword">break</span>
            }

            <span class="s-comment">// Calling 'signal' on our semaphore will cause our
            // program to keep executing from the point at which
            // 'wait' was called.</span>
            semaphore.<span class="s-call">signal</span>()
        },
        receiveValue: { value <span class="s-keyword">in</span>
            result = .<span class="s-call">success</span>(value)
        }
    )

    <span class="s-keyword">_</span> = semaphore.<span class="s-call">wait</span>(timeout: .<span class="s-call">now</span>() + <span class="s-number">20</span>)

    <span class="s-keyword">guard let</span> html = <span class="s-keyword">try</span> result?.<span class="s-call">get</span>() <span class="s-keyword">else</span> {
        <span class="s-comment">// If no result was received after 20 seconds, we'll
        // consider our operation to have timed out, and will
        // both cancel our publisher, and throw a custom error:</span>
        cancellable.<span class="s-call">cancel</span>()
        <span class="s-keyword">throw</span> <span class="s-type">NetworkTimeoutError</span>(url: url)
    }

    <span class="s-keyword">return</span> html
}</code></pre><p class="info">Note that in order to use APIs that were introduced in macOS 10.15 Catalina, such as Combine, we need to add the <code>platforms: [.macOS(.v10_15)]</code> argument to our <code>Package.swift</code> manifest. Also worth noting is that Combine is not (yet) available on Linux, which might not be a problem, depending on how we’re planning to use the tool that we’re building.</p><p>While the above code works, there are very few things about it that are network-specific — so if we wanted to, we could also generalize it into a method that lets us <em>await</em> the result of any Combine <code>Publisher</code> — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Publisher</span> {
    <span class="s-keyword">private static var</span> defaultTimeoutMessage: <span class="s-type">String</span> {
        <span class="s-string">"An async operation timed out"</span>
    }

    <span class="s-keyword">func</span> awaitOutput(
        withTimeoutMessage timeoutMessage: <span class="s-type">String</span> = defaultTimeoutMessage,
        forTimeInterval timeInterval: <span class="s-type">TimeInterval</span> = <span class="s-number">20</span>
    ) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Output</span> {
        <span class="s-keyword">let</span> semaphore = <span class="s-type">DispatchSemaphore</span>(value: <span class="s-number">0</span>)
        <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Output</span>, <span class="s-type">Failure</span>&gt;?

        <span class="s-keyword">let</span> cancellable = <span class="s-call">sink</span>(
            receiveCompletion: { completion <span class="s-keyword">in
                switch</span> completion {
                <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                    result = .<span class="s-call">failure</span>(error)
                <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
                    <span class="s-keyword">break</span>
                }

                semaphore.<span class="s-call">signal</span>()
            },
            receiveValue: { value <span class="s-keyword">in</span>
                result = .<span class="s-call">success</span>(value)
            }
        )

        <span class="s-keyword">_</span> = semaphore.<span class="s-call">wait</span>(timeout: .<span class="s-call">now</span>() + timeInterval)

        <span class="s-keyword">guard let</span> output = <span class="s-keyword">try</span> result?.<span class="s-call">get</span>() <span class="s-keyword">else</span> {
            cancellable.<span class="s-call">cancel</span>()
            <span class="s-keyword">throw</span> <span class="s-type">TimeoutError</span>(description: timeoutMessage)
        }

        <span class="s-keyword">return</span> output
    }
}</code></pre><p>With the above in place, we can now drastically simplify our <code>downloadHTML</code> function, which can now consist of a single Combine pipeline:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">try</span> <span class="s-type">URLSession</span>.<span class="s-property">shared</span>
        .<span class="s-call">dataTaskPublisher</span>(for: url)
        .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
        .<span class="s-call">map</span> { <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>) }
        .<span class="s-call">awaitOutput</span>(withTimeoutMessage: <span class="s-string">"""
        Downloading HTML from '</span>\(url)<span class="s-string">' timed out.
        """</span>)
}</code></pre><p>Really cool! However, since we’re not just looking to perform this particular task, but rather our entire program, in a synchronous fashion — another option would be to simply initialize a <code>Data</code> instance with the URL that we’re looking to load, and the system will then take care of the rest, completely synchronously:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">Data</span>(contentsOf: url)
    <span class="s-keyword">return</span> <span class="s-type">String</span>(decoding: data, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>)
}</code></pre><p>We could even call the above <code>init(contentsOf:)</code> initializer directly on <code>String</code>, which would let us perform our entire HTML loading process inline within our tool’s global scope, without the need for any additional code — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> html = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">string</span>(forKey: <span class="s-string">"url"</span>)
    .<span class="s-call">flatMap</span>(<span class="s-type">URL</span>.<span class="s-property">init</span>)
    .<span class="s-call">map</span>(<span class="s-type">String</span>.<span class="s-property">init</span>)</code></pre><p>Now it might seem like the <code>Publisher</code> extension that we initially wrote is somewhat useless, given that we were able to completely remove it by using the built-in APIs that <code>Data</code> and <code>String</code> ship with, but that’s not really the case.</p><p>While the above synchronous APIs might be a better choice when writing simpler scripts that perform all of their operations in sequence — as soon as we want to perform multiple asynchronous operations in parallel, being able to await the result of any Combine pipeline can be incredibly useful.</p><h2>Reading and writing files</h2><p>Finally, let’s take a quick look at a few built-in APIs that let us read and write files within a Swift script or tool.</p><p>Going back to <code>UserDefaults</code> for a moment — the <code>url</code> method that we avoided earlier when handling remote web URLs is a really neat tool for extracting local file system URLs from our command line arguments — since it’ll automatically expand symbols, such as <code>~</code>, in order to give us an absolute file URL that can then be directly passed to the <code>String</code> initializer we previously used to download HTML over the network:</p><pre class="splash"><code><span class="s-keyword">let</span> fileContents = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">url</span>(forKey: <span class="s-string">"file"</span>)
    .<span class="s-call">map</span>(<span class="s-type">String</span>.<span class="s-property">init</span>)</code></pre><p>If we’d rather accept a file path based on argument index, rather than using parameter names, then we could also perform the same <em>“tilde expansion”</em> that <code>UserDefaults</code> performs, using Foundation’s <code>NSString</code> type:</p><pre class="splash"><code><span class="s-comment">// This will expand the '~' symbol into the absolute path to
// the current user's home directory:</span>
<span class="s-keyword">let</span> path = <span class="s-type">NSString</span>(string: <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>[<span class="s-number">3</span>]).<span class="s-property">expandingTildeInPath</span></code></pre><p>Not only does Swift’s <code>Data</code> type let us read files by passing it a <code>URL</code>, it also lets us do the same thing but for writing. All that we have to do to write a file is to initialize a <code>Data</code> value (for example using a string’s underlying <code>utf8</code> collection) and then call the <code>write</code> method on it with the URL that we want to write our file to:</p><pre class="splash"><code><span class="s-keyword">if let</span> outputURL = namedArguments.<span class="s-call">url</span>(forKey: <span class="s-string">"output"</span>) {
    <span class="s-keyword">let</span> data = <span class="s-type">Data</span>(html.<span class="s-property">utf8</span>)
    <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: outputURL)
}</code></pre><p>The above call to <code>write</code> will either create a new file (if needed), or overwrite any existing one. Similar to how we explored multiple options for performing asynchronous tasks and networking, there are also several other built-in APIs that offer more customization options and power when it comes to file I/O (such as <code>FileManager</code>), but for simpler write operations, the above might be all that we need.</p><h2>Conclusion</h2><p>Swift can definitely be a great choice for writing scripts and other kinds of command line tools that are used to build and distribute a Swift-based app. While it might not (currently) offer the same amount of dynamism or sheer number of libraries that more established scripting languages do — its got a solid foundation (no pun intended), and it gives us access to the same powerful suite of APIs that are used to build fully-featured Mac apps.</p><p>Hopefully, as Swift keeps maturing and its <a href="https://swiftpackageindex.com">package ecosystem</a> keeps expanding, more iOS and Mac developers will be able to quickly build their own, custom tools and augment their development process — using a language that they’re already familiar with. Because while Xcode might be a really capable IDE, and while there are numerous open source tools available to automate a wide range of tasks, sometimes a custom script or tool can be just what we need to make our development workflow faster and more smooth.</p><p>Got questions, comments, or feedback? Feel free to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/goodnotes-june-2020</guid><title>Sponsor: GoodNotes</title><description>Thanks a lot to GoodNotes for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/goodnotes-june-2020</link><pubDate>Fri, 12 Jun 2020 11:30:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://www.goodnotes.com/careers">GoodNotes</a> for sponsoring Swift by Sundell this week, and I’m really excited to let you know that they’re currently hiring multiple iOS/macOS developers to join their team. So if you, or someone you know, is currently looking for a (remote-friendly) job, then make sure to <a href="https://www.goodnotes.com/careers">check out these job offers from GoodNotes</a>.</p><p>GoodNotes is an Apple-featured app that transforms your iPad, iPhone, or Mac into digital paper. It’s full of interesting and cutting-edge technologies, such as high-performance vector rendering and custom OCR, and makes great use of many of Apple’s latest OS features as well. In fact, GoodNotes is so good that Apple pre-installs it on all display iPads in their retail stores around the world.</p><p>So if you’d like to join their team of 21 people, which operates out of Hong Kong, either on-site (with a visa sponsorship) or as a remote developer — then this is your chance to get to work on a really high-quality, top-ranking app that uses the latest and greatest technologies from Apple.</p><p><strong><a href="https://www.goodnotes.com/careers">Take a look at their job offers here</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/default-decoding-values</guid><title>Tip: Annotating properties with default decoding values</title><description></description><link>https://www.swiftbysundell.com/tips/default-decoding-values</link><pubDate>Wed, 10 Jun 2020 16:07:00 +0200</pubDate><content:encoded><![CDATA[<p>The introduction of <code>Codable</code> back in 2017 was, without a doubt, a big leap forward for Swift. Although multiple tools for encoding and decoding native Swift values to and from JSON had already been built by the community at that point, <code>Codable</code> offered an unprecedented level of convenience due to its integration with the Swift compiler itself — enabling us to define decodable types simply by making them adopt the <code>Decodable</code> protocol, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFeatured: <span class="s-type">Bool</span>
}</code></pre><p>However, one feature that has been missing from <code>Codable</code> ever since its introduction is the option to add default values to certain properties (without having to make them optionals). So for example, let’s say that the above <code>isFeatured</code> property won’t always appear in the JSON data that we’ll decode <code>Article</code> instances from, and that we want it to default to <code>false</code> in that case.</p><p>Even if we add that default value to our property declaration itself, the default decoding process will still fail in case that value is missing from our underlying JSON data:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFeatured: <span class="s-type">Bool</span> = <span class="s-keyword">false</span> <span class="s-comment">// This value isn't used when decoding</span>
}</code></pre><p>Now, we could always write our own decoding code (by overriding the default implementation of <code>init(from: Decoder)</code>), but that would require us to take over the entire decoding process — which kind of ruins the whole convenience aspect of <code>Codable</code>, and would require us to keep updating that code for any change to our model’s properties.</p><p>The good news is that there’s another path that we can take, and that’s to use Swift’s <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrappers feature</a></em>, which enables us to attach custom logic to any stored property. For example, we could use that feature to implement a <code>DecodableBool</code> wrapper, with <code>false</code> as its default value:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> DecodableBool {
    <span class="s-keyword">var</span> wrappedValue = <span class="s-keyword">false</span>
}</code></pre><p>We could then make our new property wrapper conform to <code>Decodable</code> to enable it <em>“take over”</em> the decoding process for any property that it’s attached to. In this case, we do want to use a manual decoding implementation, as that’d let us decode instances directly from <code>Bool</code> values — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableBool</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        wrappedValue = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Bool</span>.<span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">The reason we conform to <code>Decodable</code> through an extension is to <a href="https://www.swiftbysundell.com/tips/struct-convenience-initializers">not override</a> our type’s <a href="https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used">memberwise initializer</a>.</p><p>Finally, we’ll also need to make <code>Codable</code> treat instances of the above property wrapper as optional during the decoding process, which can be done by extending the <code>KeyedDecodingContainer</code> type with an overload for decoding <code>DecodableBool</code> specifically — in which we only continue decoding in case a value exists for the given key, otherwise we’ll fall back to an empty instance of our wrapper:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">KeyedDecodingContainer</span> {
    <span class="s-keyword">func</span> decode(<span class="s-keyword">_</span> type: <span class="s-type">DecodableBool</span>.<span class="s-type">Type</span>,
                forKey key: <span class="s-type">Key</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">DecodableBool</span> {
        <span class="s-keyword">try</span> <span class="s-call">decodeIfPresent</span>(type, forKey: key) ?? .<span class="s-keyword">init</span>()
    }
}</code></pre><p>With the above in place, we can now simply annotate any <code>Bool</code> property with our new <code>DecodableBool</code> attribute — and it’ll default to <code>false</code> when it’s being decoded:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableBool var</span> isFeatured: <span class="s-type">Bool</span>
}</code></pre><p>Really nice. However, while we’ve now solved this particular problem, our solution isn’t very flexible. What if we’d like <code>true</code> to be the default value in some cases, and what if we have non-<code>Bool</code> properties that we’d also like to provide default decoding values for?</p><p>So let’s see if we can generalize our solution into something that can be applied within a much larger range of situations. To do that, let’s start by creating a <a href="https://www.swiftbysundell.com/basics/generics">generic protocol</a> for default value sources — which will enable us to define all sorts of defaults, not just boolean ones:</p><pre class="splash"><code><span class="s-keyword">protocol</span> DecodableDefaultSource {
    <span class="s-keyword">associatedtype</span> Value: <span class="s-type">Decodable</span>
    <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Value</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Then, let’s use an enum to create a <em>namespace</em> for the decoding code that we’re about to write — which will both give us a really nice syntax, and also provide a neat degree of code encapsulation:</p><pre class="splash"><code><span class="s-keyword">enum</span> DecodableDefault {}</code></pre><p class="info">The advantage of using case-less enums to implement namespaces is that they can’t be initialized, which makes them act as pure wrappers, rather than stand-alone types that can be instantiated.</p><p>The first type that we’ll add to our new namespace is a generic variant of our <code>DecodableBool</code> property wrapper from before — which now uses a <code>DecodableDefaultSource</code> to retrieve its default <code>wrappedValue</code>, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">@propertyWrapper
    struct</span> Wrapper&lt;Source: <span class="s-type">DecodableDefaultSource</span>&gt; {
        <span class="s-keyword">typealias</span> Value = <span class="s-type">Source</span>.<span class="s-type">Value</span>
        <span class="s-keyword">var</span> wrappedValue = <span class="s-type">Source</span>.<span class="s-property">defaultValue</span>
    }
}</code></pre><p>Next, let’s make the above property wrapper conform to <code>Decodable</code>, and we’ll also implement another <code>KeyedDecodingContainer</code> overload that’s specific to our new type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        wrappedValue = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Value</span>.<span class="s-keyword">self</span>)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">KeyedDecodingContainer</span> {
    <span class="s-keyword">func</span> decode&lt;T&gt;(<span class="s-keyword">_</span> type: <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>&lt;<span class="s-type">T</span>&gt;.<span class="s-type">Type</span>,
                   forKey key: <span class="s-type">Key</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>&lt;<span class="s-type">T</span>&gt; {
        <span class="s-keyword">try</span> <span class="s-call">decodeIfPresent</span>(type, forKey: key) ?? .<span class="s-keyword">init</span>()
    }
}</code></pre><p>With the above base infrastructure in place, let’s now go ahead and implement a few default value sources. We’ll again use an enum to provide an additional level of namespacing for our sources (just like <a href="https://developer.apple.com/documentation/combine/publishers">Combine does for its publishers</a>), and we’ll also add a few <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type aliases</a> to make our code slightly easier to read:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">typealias</span> Source = <span class="s-type">DecodableDefaultSource</span>
    <span class="s-keyword">typealias</span> List = <span class="s-type">Decodable</span> &amp; <span class="s-type">ExpressibleByArrayLiteral</span>
    <span class="s-keyword">typealias</span> Map = <span class="s-type">Decodable</span> &amp; <span class="s-type">ExpressibleByDictionaryLiteral</span>

    <span class="s-keyword">enum</span> Sources {
        <span class="s-keyword">enum</span> True: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Bool</span> { <span class="s-keyword">true</span> }
        }

        <span class="s-keyword">enum</span> False: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Bool</span> { <span class="s-keyword">false</span> }
        }

        <span class="s-keyword">enum</span> EmptyString: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">String</span> { <span class="s-string">""</span> }
        }

        <span class="s-keyword">enum</span> EmptyList&lt;T: <span class="s-type">List</span>&gt;: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">T</span> { [] }
        }

        <span class="s-keyword">enum</span> EmptyMap&lt;T: <span class="s-type">Map</span>&gt;: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">T</span> { [:] }
        }
    }
}</code></pre><p class="info">By constraining our <code>EmptyList</code> and <code>EmptyMap</code> types to two of Swift’s literal protocols, rather than concrete types like <code>Array</code> and <code>Dictionary</code>, we can cover a lot more ground — since many different types adopt those protocols, including <code>Set</code>, <code>IndexPath</code>, and more.</p><p>To wrap things up, let’s also define a series of convenience type aliases that’ll let us reference the above sources as specialized versions of our property wrapper type — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">typealias</span> True = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">True</span>&gt;
    <span class="s-keyword">typealias</span> False = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">False</span>&gt;
    <span class="s-keyword">typealias</span> EmptyString = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyString</span>&gt;
    <span class="s-keyword">typealias</span> EmptyList&lt;T: <span class="s-type">List</span>&gt; = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyList</span>&lt;<span class="s-type">T</span>&gt;&gt;
    <span class="s-keyword">typealias</span> EmptyMap&lt;T: <span class="s-type">Map</span>&gt; = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyMap</span>&lt;<span class="s-type">T</span>&gt;&gt;
}</code></pre><p>That last piece gives us a really nice syntax for annotating properties with decodable defaults, which can now simply be done like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyString var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">False var</span> isFeatured: <span class="s-type">Bool</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">True var</span> isActive: <span class="s-type">Bool</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyList var</span> comments: [<span class="s-type">Comment</span>]
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyMap var</span> flags: [<span class="s-type">String</span> : <span class="s-type">Bool</span>]
}</code></pre><p>Really neat, and perhaps the best part is that our solution is now truly generic — we can easily add new sources whenever we need to, all while keeping our call sites as clean as possible.</p><p>As a series of finishing touches, let’s also use Swift’s <em><a href="https://www.swiftbysundell.com/articles/conditional-conformances-in-swift">conditional conformances feature</a></em> to make our property wrapper conform to common protocols — such as <code>Equatable</code>, <code>Hashable</code> and also <code>Encodable</code> — whenever its wrapped <code>Value</code> type does:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Equatable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Equatable</span> {}
<span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Hashable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Hashable</span> {}

<span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Encodable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Encodable</span> {
    <span class="s-keyword">func</span> encode(to encoder: <span class="s-type">Encoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">var</span> container = encoder.<span class="s-call">singleValueContainer</span>()
        <span class="s-keyword">try</span> container.<span class="s-call">encode</span>(wrappedValue)
    }
}</code></pre><p>And with that in place, we now have a finished solution for annotating properties with default decoding values — all without requiring any changes to the property types that are being decoded, and with a neatly encapsulated implementation, thanks to our <code>DecodableDefault</code> enum.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/handling-model-variants-in-swift</guid><title>Handling model variants in Swift</title><description>This week, let’s explore a few different techniques for handling dynamic, polymorphic model data, in ways that still leans into Swift’s strong emphasis on type-safety.</description><link>https://www.swiftbysundell.com/articles/handling-model-variants-in-swift</link><pubDate>Sun, 7 Jun 2020 20:55:00 +0200</pubDate><content:encoded><![CDATA[<p>As programmers, we’re often working on apps and systems that consist of multiple parts that need to be connected one way or another — and doing so in ways that are elegant, robust, and future proof can often be easier said than done.</p><p>Especially when using highly static languages (such as Swift), it can sometimes be tricky to figure out how to model certain conditions or pieces of data in a way that both satisfies the compiler, and results in code that’s easy to work with.</p><p>This week, let’s take a look at one such situation, which involves modeling multiple variants of the same data model, and explore a few different techniques and approaches that can let us handle dynamic data in ways that still leans into Swift’s strong emphasis on type-safety.</p><h2>Mixed structures</h2><p>As an example, let’s say that we’re working on a cooking app that includes both videos and written recipes, and that our content is loaded from a web service that returns JSON formatted like this:</p><pre><code class="no-highlight">{
    "items": [
        {
            "type": "video",
            "title": "Making perfect toast",
            "imageURL": "https://image-cdn.com/toast.png",
            "url": "https://videoservice.com/toast.mp4",
            "duration": "00:12:09",
            "resolution": "720p"
        },
        {
            "type": "recipe",
            "title": "Tasty burritos",
            "imageURL": "https://image-cdn.com/burritos.png",
            "text": "Here's how to make the best burritos...",
            "ingredients": [
                "Tortillas",
                "Salsa",
                ...
            ]
        }
    ]
}</code></pre><p>While the above way of structuring JSON responses is incredibly common, creating Swift representations that match it can prove to be quite challenging. Since we’re receiving an <code>items</code> array that contains both recipes and videos mixed together, we’ll need to write our model code in a way that lets us decode both of those two variants simultaneously.</p><p>One way to do that would be to create an <code>ItemType</code> enum that includes cases for each of our two variants, as well as a unified <code>Item</code> data model that contains all of the properties that we’re expecting to encounter, and an <code>ItemCollection</code> wrapper that we’ll be able to decode our JSON into:</p><pre class="splash"><code><span class="s-keyword">enum</span> ItemType: <span class="s-type">String</span>, <span class="s-type">Decodable</span> {
    <span class="s-keyword">case</span> video
    <span class="s-keyword">case</span> recipe
}

<span class="s-keyword">struct</span> Item: <span class="s-type">Decodable</span> {
    <span class="s-keyword">let</span> type: <span class="s-type">ItemType</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>?
    <span class="s-keyword">var</span> duration: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]?
}

<span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
}</code></pre><p class="info">The reason why the above <code>type</code> property is a constant, while all other <code>Item</code> properties remain variables, is because that’s the only piece of data that we don’t want to be modified under any circumstances — since a recipe shouldn’t be able to turn into a video, and vice versa. For the other properties, we’re <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">utilizing Swift’s value semantics</a> by making them variables.</p><p>While the above approach lets us successfully decode our JSON, it’s quite far from ideal — since we’re forced to implement the majority of our properties as optionals, given that they’re unique to one of our two variants. Doing so will in turn require us to constantly unwrap those optionals, even within code that only deals with a single variant, such as this <code>VideoPlayer</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    ...

    <span class="s-keyword">func</span> playVideoItem(<span class="s-keyword">_</span> item: <span class="s-type">Item</span>) {
        <span class="s-comment">// We can't establish a compile-time guarantee that the
        // item passed to this method will, in fact, be a video.</span>
        <span class="s-keyword">guard let</span> url = item.<span class="s-property">url</span> <span class="s-keyword">else</span> {
            <span class="s-call">assertionFailure</span>(<span class="s-string">"Video item doesn't have a URL:</span> \(item)<span class="s-string">"</span>)
            <span class="s-keyword">return</span>
        }

        <span class="s-call">startPlayback</span>(from: url)
    }
}</code></pre><p>So let’s explore a few ways of solving the above problem, and take a look at what sort of trade-offs that each of those approaches might give us.</p><h2>Complete polymorphism</h2><p>Since we are, at the end of the day, attempting to model a set of <em>polymorphic data</em> (as our models can take on multiple forms), one approach would be to make our Swift representations of that data polymorphic as well.</p><p>To do that, we might create an <code>Item</code> protocol that contains all of the properties that are shared between our two variants, as well as two separate types — one for videos and one for recipes — that both conform to that new protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Item: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">struct</span> Video: <span class="s-type">Item</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { .<span class="s-dotAccess">video</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> duration: <span class="s-type">String</span>
    <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> Recipe: <span class="s-type">Item</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { .<span class="s-dotAccess">recipe</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>
    <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]
}</code></pre><p>As our items are now represented by two distinct types, we probably also want to modify our <code>ItemCollection</code> wrapper to include separate arrays for each of those two types as well — as otherwise we’d have to constantly type cast <code>Item</code> values to either <code>Video</code> or <code>Recipe</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> videos: [<span class="s-type">Video</span>]
    <span class="s-keyword">var</span> recipes: [<span class="s-type">Recipe</span>]
}</code></pre><p>However, while the above model structure might look great in theory, in practice it’ll require a bit of extra work, since our Swift code no longer matches the format of our JSON responses. That’s not a huge problem, however, as we can always do what we did in <em><a href="https://www.swiftbysundell.com/articles/customizing-codable-types-in-swift">“Customizing Codable types in Swift”</a></em> — and create dedicated types specifically for decoding, along with a custom <code>Decodable</code> implementation.</p><p>In this case, let’s reuse our <code>Item</code> and <code>ItemCollection</code> implementations from before, while renaming them to fit their new purpose — like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">struct</span> Encoded: <span class="s-type">Decodable</span> {
        <span class="s-keyword">var</span> items: [<span class="s-type">EncodedItem</span>]
    }

    <span class="s-keyword">struct</span> EncodedItem: <span class="s-type">Decodable</span> {
        <span class="s-keyword">let</span> type: <span class="s-type">ItemType</span>
        <span class="s-keyword">var</span> title: <span class="s-type">String</span>
        <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
        <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> url: <span class="s-type">URL</span>?
        <span class="s-keyword">var</span> duration: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]?
    }
}</code></pre><p>We’re now <em>almost</em> ready to write our custom <code>Decodable</code> implementation — but since we’re going to need to unwrap quite a few optionals when doing that, let’s first create a small utility method that’ll make that process much simpler:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">struct</span> MissingEncodedValue: <span class="s-type">Error</span> {
        <span class="s-keyword">var</span> name: <span class="s-type">String</span>
        ...
    }

    <span class="s-keyword">private func</span> unwrap&lt;T&gt;(<span class="s-keyword">_</span> value: <span class="s-type">T</span>?, name: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">guard let</span> value = value <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">MissingEncodedValue</span>(name: name)
        }

        <span class="s-keyword">return</span> value
    }
}</code></pre><p class="info">If the above <code>unwrap</code> method looks familiar, it might be because it’s really similar to <a href="https://www.swiftbysundell.com/tips/unwrapping-an-optional-or-throwing-an-error">this extension</a> on the <code>Optional</code> type itself, which has appeared in several previous articles.</p><p>With the above pieces in place, let’s now write our actual decoding code. We’ll start by decoding an instance of our new <code>Encoded</code> wrapper, and we’ll then convert its items into <code>Video</code> and <code>Recipe</code> values, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        <span class="s-keyword">let</span> collection = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Encoded</span>.<span class="s-keyword">self</span>)

        <span class="s-keyword">for</span> item <span class="s-keyword">in</span> collection.<span class="s-property">items</span> {
            <span class="s-keyword">switch</span> item.<span class="s-property">type</span> {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>:
                <span class="s-keyword">try</span> videos.<span class="s-call">append</span>(<span class="s-type">Video</span>(
                    type: item.<span class="s-property">type</span>,
                    title: item.<span class="s-property">title</span>,
                    imageURL: item.<span class="s-property">imageURL</span>,
                    url: <span class="s-call">unwrap</span>(item.<span class="s-property">url</span>, name: <span class="s-string">"url"</span>),
                    duration: <span class="s-call">unwrap</span>(item.<span class="s-property">duration</span>, name: <span class="s-string">"duration"</span>),
                    resolution: <span class="s-call">unwrap</span>(item.<span class="s-property">resolution</span>, name: <span class="s-string">"resolution"</span>)
                ))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>:
                <span class="s-keyword">try</span> recipes.<span class="s-call">append</span>(<span class="s-type">Recipe</span>(
                    type: item.<span class="s-property">type</span>,
                    title: item.<span class="s-property">title</span>,
                    imageURL: item.<span class="s-property">imageURL</span>,
                    text: <span class="s-call">unwrap</span>(item.<span class="s-property">text</span>, name: <span class="s-string">"text"</span>),
                    ingredients: <span class="s-call">unwrap</span>(item.<span class="s-property">ingredients</span>, name: <span class="s-string">"ingredients"</span>)
                ))
            }
        }
    }
}</code></pre><p>With that final piece in place, we now have a fully type-safe representation of our JSON data, all without any <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optionals</a></em>. However, not only did the above approach require a fair amount of decoding-specific code, we’re now also losing track of the overall order of our items (as we’re splitting them up into two arrays while decoding them).</p><p>While there are of course different ways that we could fix that, including maintaining a separate <code>[Item]</code> array that we could use for sorting and ordering, let’s also explore a third approach that might turn out to be a neat <em>middle ground</em> between our first two implementations.</p><p>Rather than treating our variants as two separate implementations that share a common interface, let’s actually treat them as variants of <em>the same model</em> instead. That might seem like a subtle change, but it’ll turn out to have quite a big impact on our final model structure.</p><p>To get started, let’s rename our previous <code>Item</code> protocol to <code>ItemVariant</code> instead, while also dropping its <code>type</code> property:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ItemVariant: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Then, let’s model our actual <code>Item</code> type as an enum, with one case for each of our two variants — each containing an instance of that variant’s dedicated model as an associated value:</p><pre class="splash"><code><span class="s-keyword">enum</span> Item {
    <span class="s-keyword">case</span> video(<span class="s-type">Video</span>)
    <span class="s-keyword">case</span> recipe(<span class="s-type">Recipe</span>)
}</code></pre><p>With the above change in place, we can now heavily simplify our custom <code>Decodable</code> implementation — which can now take place entirely within our new <code>Item</code> type itself, and just involves inspecting each JSON item’s <code>type</code> value in order to decide which underlying type to decode:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">struct</span> InvalidTypeError: <span class="s-type">Error</span> {
        <span class="s-keyword">var</span> type: <span class="s-type">String</span>
        ...
    }

    <span class="s-keyword">private enum</span> CodingKeys: <span class="s-type">CodingKey</span> {
        <span class="s-keyword">case</span> type
    }

    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">container</span>(keyedBy: <span class="s-type">CodingKeys</span>.<span class="s-keyword">self</span>)
        <span class="s-keyword">let</span> type = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">String</span>.<span class="s-keyword">self</span>, forKey: .<span class="s-dotAccess">type</span>)

        <span class="s-keyword">switch</span> type {
        <span class="s-keyword">case</span> <span class="s-string">"video"</span>:
            <span class="s-keyword">self</span> = .<span class="s-call">video</span>(<span class="s-keyword">try</span> <span class="s-type">Video</span>(from: decoder))
        <span class="s-keyword">case</span> <span class="s-string">"recipe"</span>:
            <span class="s-keyword">self</span> = .<span class="s-call">recipe</span>(<span class="s-keyword">try</span> <span class="s-type">Recipe</span>(from: decoder))
        <span class="s-keyword">default</span>:
            <span class="s-keyword">throw</span> <span class="s-type">InvalidTypeError</span>(type: type)
        }
    }
}</code></pre><p class="info">An alternative to using raw strings to represent each type would be to keep using our <code>ItemType</code> enum from before. However, given that we’ve now introduced an <code>ItemVariant</code> protocol, keeping that enum around might add some confusion, and doesn’t really give us any benefits compared to defining our strings inline within the above initializer.</p><p>Since our <code>Item</code> implementation is once again responsible for decoding its own instances, we can now revert our <code>ItemCollection</code> back to simply being a container for an array of <code>Item</code> values — which also lets it rely on the default implementation of <code>Decodable</code>, just like before:</p><pre class="splash"><code><span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
}</code></pre><p>While this last iteration has the benefit of letting us keep using our dedicated models, while also keeping our decoding code simple, and our overall item order intact, it does come with the downside of requiring us to <em>unpack</em> each <code>Item</code> value before using it — for example by using a <code>switch</code> statement, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">func</span> allTitles() -&gt; [<span class="s-type">String</span>] {
        items.<span class="s-call">map</span> { item <span class="s-keyword">in
            switch</span> item {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>(<span class="s-keyword">let</span> video):
                <span class="s-keyword">return</span> video.<span class="s-property">title</span>
            <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>(<span class="s-keyword">let</span> recipe):
                <span class="s-keyword">return</span> recipe.<span class="s-property">title</span>
            }
        }
    }
}</code></pre><p>While we’re going to have to keep writing code like the above whenever we need to access data that’s specific to either <code>Recipe</code> or <code>Video</code> (which is arguably a good thing, since that <em>“forces”</em> us to handle both of those two possible cases), there is something we can do to give us direct access to any property defined within our <code>ItemVariant</code> protocol — and that’s to use Swift’s <em>dynamic member lookup</em> feature.</p><p>Doing that first involves adding the <code>@dynamicMemberLookup</code> attribute to our main <code>Item</code> declaration:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
enum</span> Item {
    <span class="s-keyword">case</span> video(<span class="s-type">Video</span>)
    <span class="s-keyword">case</span> recipe(<span class="s-type">Recipe</span>)
}</code></pre><p>The second part of the puzzle is to implement a <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift"><code>subscript</code></a> that resolves a value for a given dynamic member. While doing so initially required such a subscript to accept any arbitrary string as input, since Swift 5.1 it’s possible to <em><a href="https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths">instead use key paths</a></em> — which lets us add support for dynamic members in a fully type-safe manner, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">ItemVariant</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>(<span class="s-keyword">let</span> video):
            <span class="s-keyword">return</span> video[keyPath: keyPath]
        <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>(<span class="s-keyword">let</span> recipe):
            <span class="s-keyword">return</span> recipe[keyPath: keyPath]
        }
    }
}</code></pre><p>With the above in place, we can now access any property that’s shared between <code>Video</code> and <code>Recipe</code> (through our <code>ItemVariant</code> protocol) as if that property was defined within our <code>Item</code> type itself. Combine that with the fact that key paths can now <a href="https://www.swiftbysundell.com/tips/passing-key-paths-as-functions">be converted into functions</a> (yes, I love key paths), and we can transform our <code>allTitles</code> method from before to now simply look like this instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">func</span> allTitles() -&gt; [<span class="s-type">String</span>] {
        items.<span class="s-call">map</span>(\.<span class="s-property">title</span>)
    }
}</code></pre><p>Really cool! Using the above setup we can sort of achieve the best of both worlds, in that we now get direct access to all of the properties that both of our variants support — while also being able to use our specialized <code>Video</code> and <code>Recipe</code> models when we want to write code that’s specific to any of those two variants.</p><h2>Conclusion</h2><p>While it can occasionally be difficult to cleanly represent dynamic or polymorphic data in Swift, there are often ways to make that happen — although finding the right structure within each given situation might require us to try out a few different approaches, just like we did in this article.</p><p>Although that sort of <em>“trial and error”</em> might take some extra time, going through that process is often a good investment to make when it comes to model code, as an app’s data models tend to make up the very foundation of its overall code base.</p><p>Of course, the very best would arguably be for our serialized data to always match the format that we expect within our Swift code, but that’s not always possible — especially when working on a product that ships on multiple platforms.</p><p>What do you think? How do you typically structure models that have multiple variants, and would any of the techniques covered in this article be useful within your code base? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/bitrise-june-2020</guid><title>Sponsor: Bitrise</title><description>Thanks a lot to Bitrise for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/bitrise-june-2020</link><pubDate>Fri, 5 Jun 2020 12:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Thanks a lot to <a href="https://bitrise.io/swift">Bitrise</a>, my favorite continuous integration service, for sponsoring Swift by Sundell this week. I’ve been using Bitrise since long before they became a sponsor, both for my own projects and when working with clients, and it’s truly a fantastic service.</p><p>Bitrise lets you easily set up all sorts of automation to be run when some form of change is made within your project. For example, you can have it run all of your unit or UI tests when a new Pull Request is opened, or automatically submit a new build to TestFlight or App Store Connect when you create a new release branch.</p><p>The power of Bitrise is that it both has more than 300 common actions built-in, which can be added to your build pipeline with just a few clicks within their web UI, while also providing full command line access as well. And perhaps the best part is that you don’t need to make <em>any changes</em> to your project to use Bitrise — and it’s completely free to try — so take it for a spin, and I think you’ll see why I like it so much.</p><p><strong><a href="https://bitrise.io/swift">Using this link to try out Bitrise also supports Swift by Sundell</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/74</guid><title>Podcast: “Let’s build a camera app”, a conversation with the Halide and Spectre team</title><description>On this special episode, John is joined by the entire team behind the award-winning apps Halide and Spectre, Apple’s 2019 App of the Year. Ben, Sebastiaan and Rebecca share their stories of how these apps came to life, how they’re working together between design and development, and how technologies like Computational Photography and Augmented Reality are influencing their work.</description><link>https://www.swiftbysundell.com/podcast/74</link><pubDate>Thu, 4 Jun 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell74.mp3" type="audio/mpeg"/></audio><p>On this special episode, John is joined by the entire team behind the award-winning apps Halide and Spectre, Apple’s 2019 App of the Year. Ben, Sebastiaan and Rebecca share their stories of how these apps came to life, how they’re working together between design and development, and how technologies like Computational Photography and Augmented Reality are influencing their work.</p><h2>Sponsor</h2><ul><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/sandofsky">Ben on Twitter</a></li><li><a href="https://twitter.com/sdw">Sebastiaan on Twitter</a></li><li><a href="https://twitter.com/rebeccaslatkin">Rebecca on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://lux.camera">Lux Optics Inc.</a></li><li><a href="https://blog.halide.cam/lux-year-3-the-end-of-the-beginning-14a271711743">Lux Year 3: The End of the Beginning</a></li><li><a href="https://halide.cam">Halide</a></li><li><a href="https://spectre.cam">Spectre</a></li><li><a href="https://dribbble.com">Dribbble</a></li><li><a href="https://developer.apple.com/documentation/metalperformanceshaders">Metal Performance Shaders</a></li><li><a href="https://developer.apple.com/documentation/vision">The Vision framework</a></li><li><a href="https://developer.apple.com/documentation/coreml">Core ML</a></li><li><a href="https://blog.halide.cam/lidar-peek-into-the-future-with-ipad-pro-11d38910e9f8">The iPad Pro LIDAR sensor and the Esper prototype</a></li><li><a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/designing-reusable-swift-libraries</guid><title>Designing reusable Swift libraries</title><description>This week’s article is about library development, and contains a few techniques and principles that can be good to keep in mind when designing and building reusable Swift libraries.</description><link>https://www.swiftbysundell.com/articles/designing-reusable-swift-libraries</link><pubDate>Sun, 31 May 2020 22:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Code reuse is one of those programming concepts that can be much more complex than what it first might seem like. While it’s easy to argue that code duplication should be avoided at all costs and that implementations should always be reused and shared whenever possible — it’s important to remember that all abstractions that we end up introducing also come with a certain cost.</p><p>So writing pragmatic, reusable code often comes down to striking a balance between reducing duplication wherever possible, while also trying to avoid having to introduce too many layers of abstraction or complexity in order to unify our various implementations.</p><p>Striking such a balance becomes especially important (and, arguably, difficult) when designing and building reusable libraries — so this week, let’s take a look at a few principles and techniques that can be good to keep in mind when doing just that.</p><h2>Packaging up a generic concept</h2><p>Whether we’re working on a single code base, or multiple ones, there are often opportunities for us to share code by extracting narrowly scoped pieces of logic into separate libraries. Apart from the code reuse aspect, doing so also enables us to test and iterate on that logic in isolation — which can be incredibly useful, especially within larger code bases with long overall build times.</p><p>When deciding what kind of code to extract into a separate library, it’s usually a good idea to try to pick something that can be implemented as a <em>truly generic concept</em>. That doesn’t necessarily mean that the code itself needs to be completely <a href="https://www.swiftbysundell.com/basics/generics">generic</a>, but rather that the logic itself isn’t tied to any specific <em>feature or domain</em>.</p><p>As an example, imagine that we’re working on an app that makes heavy use of <em>tags</em> in order to sort, filter and provide recommendations for various kinds of content. While the way that we actually use those tags within our app might be really specific to our particular domain, the concept of tags itself is something that could definitely be generalized into a reusable library — a <em>TagKit</em>, if you will.</p><p>Let’s say that a core part of our app’s tagging logic is implemented using a <code>Tagged</code> protocol, as well as a <code>TaggedCollection</code> that lets us store and retrieve elements based on their tags:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Tagged: <span class="s-type">Hashable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">String</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()

    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag, default: []].<span class="s-call">insert</span>(element)
        }
    }

    <span class="s-keyword">mutating func</span> remove(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag]?.<span class="s-call">remove</span>(element)
        }
    }

    <span class="s-keyword">func</span> elements(taggedWith tag: <span class="s-type">String</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        elements[tag] ?? []
    }
}</code></pre><p>Let’s start the process of creating our TagKit by moving the above protocol and type into a separate library, which we’ll create as a Swift package. Once we’ve <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager">set up the package itself</a>, the first step would be to mark all of the APIs that we wish to be part of our library’s <em>public interface</em> as <code>public</code>, so that they’ll be accessible outside of our library module — like this:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged: <span class="s-type">Hashable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">String</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()
    
    <span class="s-comment">// Note that we have to explicitly add a public initializer
    // in order to be able to initialize a type outside of
    // the module that it's declared in:</span>
    <span class="s-keyword">public init</span>() {}

    <span class="s-keyword">public mutating func</span> add(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag, default: []].<span class="s-call">insert</span>(element)
        }
    }

    <span class="s-keyword">public mutating func</span> remove(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag]?.<span class="s-call">remove</span>(element)
        }
    }

    <span class="s-keyword">public func</span> elements(taggedWith tag: <span class="s-type">String</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        elements[tag] ?? []
    }
}</code></pre><p>While the above kind of change is quick and easy to make, a key aspect of library development is to carefully consider what to actually make parts of our public API, versus what to keep internal within the library itself.</p><p>As an example, let’s say that we now want to enable instances of our <code>TaggedCollection</code> type to be encoded and decoded using Swift’s built-in <code>Codable</code> API. Since all of our collection’s elements would also need to be <code>Codable</code> in order to make that happen, one approach would be to add that protocol as an additional requirement for conforming to <code>Tagged</code> — which would let us simply mark <code>TaggedCollection</code> as being <code>Codable</code> as well:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt;: <span class="s-type">Codable</span> {
    ...
}</code></pre><p>However, here’s where we have to put on our <em>“API designer hat”</em> for a second, and think about whether requiring all <code>Tagged</code> types to also conform to <code>Codable</code> is <em>really</em> a good idea. After all, what does encoding and decoding have to do with having support for tags?</p><p>Although making that association might not seem like a big deal, adding more requirements than what’s absolutely needed could make our library less flexible and harder to adopt — especially as we might continue to add more requirements in the future if we choose to follow this design.</p><p>Thankfully, there’s another approach that we could take in this case, and that’s to use Swift’s <em><a href="https://www.swiftbysundell.com/articles/conditional-conformances-in-swift">conditional conformances feature</a></em> — which enables us to make our <code>TaggedCollection</code> conform to a given protocol only when its <code>Element</code> type also does.</p><p>Using that — while also moving the requirement of conforming to <code>Hashable</code> into our <code>TaggedCollection</code> itself — lets us simplify our <code>Tagged</code> protocol to now only require a single property, all without sacrificing any functionality:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">TaggedCollection</span>: <span class="s-type">Codable</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Codable</span> {}</code></pre><p>With the above change in place, our API now scales really nicely — from simply adopting our <code>Tagged</code> protocol, to using it within <code>TaggedCollection</code>, to being able to encode and decode collection instances — with requirements that are gradually introduced only when needed.</p><h2>Strong types and escape hatches</h2><p>Currently, our tagging system uses raw strings to represent each tag, which might’ve been completely fine when that system was implemented specifically for a single app — but since we’re now looking to turn it into a stand-alone library, we might want to make things a bit more strongly typed.</p><p>An initial idea on how to achieve that might be to model all of the tags that we’re currently using as an enum, with one case for each tag, and to then update both our <code>Tagged</code> protocol and our <code>TaggedCollection</code> to use that type instead of <code>String</code> values:</p><pre class="splash"><code><span class="s-keyword">public enum</span> Tag: <span class="s-type">String</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">case</span> newRelease
    <span class="s-keyword">case</span> onSale
    <span class="s-keyword">case</span> promoted
    ...
}

<span class="s-keyword">public protocol</span> Tagged {
    <span class="s-keyword">var</span> tags: [<span class="s-type">Tag</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">Tag</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()

    ...

    <span class="s-keyword">public func</span> elements(taggedWith tag: <span class="s-type">Tag</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        ...
    }
}</code></pre><p>However, while the above approach might’ve worked great within a single app, it’s quite problematic in the context of a reusable library — since the library itself will need to contain all of the tags that any of the apps using it will ever need, which isn’t very sustainable in the long run.</p><p>One way to fix that problem would be to add an <em>”escape hatch”</em> to the above enum — that is, an API that enables us to implement our own custom tags when needed — for example by introducing a <code>custom</code> case, like this:</p><pre class="splash"><code><span class="s-keyword">public enum</span> Tag: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">case</span> newRelease
    <span class="s-keyword">case</span> onSale
    <span class="s-keyword">case</span> promoted
    ...
    <span class="s-keyword">case</span> custom(<span class="s-type">String</span>)
}</code></pre><p>While the above approach does work, and might even be the right design decision in certain situations, it comes with the downsides that we’d both have to implement our own conversion to and from strings (since our enum is no longer backed by a raw <code>String</code> value), and we’d also have to manually conform to <code>Codable</code> as well.</p><p>Instead, let’s take a different approach, and implement our <code>Tag</code> type as a struct — which enables us to keep track of each tag’s underlying <code>String</code> value using a property. We’ll also take this opportunity to enable <code>Tag</code> values to be easily expressed using <a href="https://www.swiftbysundell.com/articles/string-literals-in-swift">string literals</a> as well:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Tag: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">public var</span> string: <span class="s-type">String</span>

    <span class="s-keyword">public init</span>(<span class="s-keyword">_</span> string: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">string</span> = string
    }
}

<span class="s-keyword">extension</span> <span class="s-type">Tag</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">public init</span>(stringLiteral value: <span class="s-type">String</span>) {
        string = value
    }
}</code></pre><p>The great thing about the above approach is that not only are we now free to define app-specific <code>Tag</code> values in whichever way we want — we can still enable the same <em>“enum-like”</em> dot-syntax to be used for our most frequent tags by adding static computed properties for them, for example like this:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Tag</span> {
    <span class="s-keyword">static var</span> newRelease: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    <span class="s-keyword">static var</span> onSale: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    <span class="s-keyword">static var</span> promoted: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    ...
}</code></pre><p class="info">The above <code>#function</code> symbols will at compile time automatically expand to the name of their enclosing property, giving us the exact same raw string mapping as enums provide.</p><p>With the above in place, we now both get the convenience of being able to easily define our tags using raw strings, while also getting the additional type safety and <a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code/%23dedicated-types">self-documenting qualities</a> that strong types provide.</p><h2>The importance of testing the public API</h2><p>It’s fair to say that a major part of building a solid library is putting enough automated tests in place to ensure that its various functionality and behaviors will keep working as expected as it continues to evolve.</p><p>As an example, let’s say that our new tagging library also contains a <code>RecommendationEngine</code> that lets us quickly generate an array of recommendations from a collection of tagged elements. For the sake of simplicity, we’ll use the following implementation — which generates its recommendations by shuffling all of the elements that match a given tag, and then returns the first three matches:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(elements.<span class="s-call">shuffled</span>().<span class="s-call">prefix</span>(<span class="s-number">3</span>))
    }
}</code></pre><p class="info">Fun fact: While the above is just an example, it’s actually quite close to how the first version of this website’s recommendation system was implemented. Nothing wrong with using simple algorithms if they end up doing the job.</p><p>While the above implementation is indeed simple, it’s actually quite problematic from a testing perspective, since it contains an element of randomness (through its use of <code>shuffled()</code>). One way to address that problem would be to extract that source of randomness into a closure that could then be overridden within our tests — for example like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="highlight offset-adjust"><span class="s-keyword">internal var</span> sorting: (<span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;) -&gt; [<span class="s-type">Element</span>] = { $0.<span class="s-call">shuffled</span>() }</span>

    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(<span class="s-call">sorting</span>(elements).<span class="s-call">prefix</span>(<span class="s-number">3</span>))
    }
}</code></pre><p>Our new <code>sorting</code> property is marked as <code>internal</code>, since we’re currently considering it an implementation detail of our library, rather than a part of its public API. We could then access that property within our tests using the <code>@testable import</code> command — which gives us access to all of the imported module’s <code>internal</code> APIs, as well as its public ones. That way, we could write tests like this:</p><pre class="splash"><code><span class="s-keyword">@testable import</span> TagKit

<span class="s-keyword">class</span> RecommendationEngineTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testReturningFirstThreeMatchedElements() {
        <span class="s-keyword">let</span> articles = (<span class="s-number">0</span>..&lt;<span class="s-number">5</span>).<span class="s-call">map</span> { index <span class="s-keyword">in</span>
            <span class="s-type">Article</span>(
                title: <span class="s-string">"Article-</span>\(index)<span class="s-string">"</span>,
                tags: [<span class="s-string">"tag"</span>]
            )
        }

        <span class="s-keyword">var</span> collection = <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Article</span>&gt;()
        articles.<span class="s-call">forEach</span> { collection.<span class="s-call">add</span>($0) }

        <span class="s-keyword">var</span> engine = <span class="s-type">RecommendationEngine</span>(collection: collection)

        engine.<span class="s-property">sorting</span> = { array <span class="s-keyword">in</span>
            array.<span class="s-call">sorted</span>(by: { $0.<span class="s-property">title</span> &lt; $1.<span class="s-property">title</span> })
        }

        <span class="s-keyword">let</span> recommendations = engine.<span class="s-call">recommendations</span>(forTag: <span class="s-string">"tag"</span>)
        <span class="s-call">XCTAssertEqual</span>(recommendations, <span class="s-type">Array</span>(articles[..&lt;<span class="s-number">3</span>]))
    }
}</code></pre><p>While the above approach works, and is a very common way of writing unit tests for app targets, it’s questionable whether it’s a good approach for testing libraries.</p><p>The problem with using internal APIs to write library tests is that those capabilities won’t be available to the actual production code that’ll use our library — which in turn makes it easy to overlook design flaws and APIs that are too limited. After all, if we need a certain API to be able to test our library, chances are that at least one of the apps using it will need that API too.</p><p>So let’s turn our new <code>sorting</code> API into a proper public one instead. While we could of course just change that property’s access level to <code>public</code> and leave things like that, let’s tweak it a bit before exposing it as a part of our official API.</p><p>Just like how we earlier introduced a dedicated type for representing tags, let’s do the same thing here — and create a <code>Sorting</code> type that’ll act as a thin wrapper around a closure that’ll perform the actually sorting:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Sorting&lt;Element: <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">public typealias</span> Body = (<span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;) -&gt; [<span class="s-type">Element</span>]

    <span class="s-keyword">public var</span> body: <span class="s-type">Body</span>

    <span class="s-keyword">public init</span>(body: <span class="s-keyword">@escaping</span> <span class="s-type">Body</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">body</span> = body
    }
}</code></pre><p>For convenience, let’s also provide a default <code>shuffled</code> implementation of our new <code>Sorting</code> type, using the same static property-based technique that we used earlier:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sorting</span> {
    <span class="s-keyword">static var</span> shuffled: <span class="s-type">Self</span> {
        .<span class="s-keyword">init</span> { $0.<span class="s-call">shuffled</span>() }
    }
}</code></pre><p>With the above in place, let’s now go back to our <code>RecommendationEngine</code> and make it accept an instance of our new <code>Sorting</code> type as part of its initializer. We’ll also take this opportunity to parameterize our <code>maxElementCount</code> as well — further making our public API more customizable and powerful without sacrificing any convenience:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;
    <span class="s-keyword">private let</span> sorting: <span class="s-type">Sorting</span>&lt;<span class="s-type">Element</span>&gt;
    <span class="s-keyword">private let</span> maxElementCount: <span class="s-type">Int</span>

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;,
                sorting: <span class="s-type">Sorting</span>&lt;<span class="s-type">Element</span>&gt; = .<span class="s-dotAccess">shuffled</span>,
                maxElementCount: <span class="s-type">Int</span> = <span class="s-number">3</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
        <span class="s-keyword">self</span>.<span class="s-property">sorting</span> = sorting
        <span class="s-keyword">self</span>.<span class="s-property">maxElementCount</span> = maxElementCount
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(sorting.<span class="s-call">body</span>(elements).<span class="s-call">prefix</span>(maxElementCount))
    }
}</code></pre><p>A really neat side-effect of the above change is that we can now keep implementing different <code>Sorting</code> variants — both within our library itself, and externally within our app projects. For example, here’s another implementation which sorts the <code>Set</code> that it’s given based on a key path:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sorting</span> {
    <span class="s-keyword">static func</span> basedOn&lt;V: <span class="s-type">Comparable</span>&gt;(
        <span class="s-keyword">_</span> keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">V</span>&gt;
    ) -&gt; <span class="s-type">Self</span> {
        .<span class="s-keyword">init</span> { <span class="s-keyword">set in
            set</span>.<span class="s-call">sorted</span> {
                $0[keyPath: keyPath] &lt; $1[keyPath: keyPath]
            }
        }
    }
}</code></pre><p>With the above pieces in place, we can now drop the <code>@testable</code> prefix from our unit test’s <code>import</code> statement, and write our test using the exact same set of APIs that our production code will have access to — like this:</p><pre class="splash"><code><span class="s-keyword">import</span> TagKit

<span class="s-keyword">class</span> RecommendationEngineTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testReturningFirstThreeMatchedElements() {
        <span class="s-keyword">let</span> articles = (<span class="s-number">0</span>..&lt;<span class="s-number">5</span>).<span class="s-call">map</span> { index <span class="s-keyword">in</span>
            <span class="s-type">Article</span>(
                title: <span class="s-string">"Article-</span>\(index)<span class="s-string">"</span>,
                tags: [<span class="s-string">"tag"</span>]
            )
        }

        <span class="s-keyword">var</span> collection = <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Article</span>&gt;()
        articles.<span class="s-call">forEach</span> { collection.<span class="s-call">add</span>($0) }

        <span class="s-keyword">let</span> engine = <span class="s-type">RecommendationEngine</span>(
            collection: collection,
            sorting: .<span class="s-call">basedOn</span>(\.<span class="s-property">title</span>)
        )

        <span class="s-keyword">let</span> recommendations = engine.<span class="s-call">recommendations</span>(forTag: <span class="s-string">"tag"</span>)
        <span class="s-call">XCTAssertEqual</span>(recommendations, <span class="s-type">Array</span>(articles[..&lt;<span class="s-number">3</span>]))
    }
}</code></pre><p>In general, using unit tests while developing libraries is a great way to <em>“dog-food”</em> all of our APIs and to work out how to handle various edge cases. Because at the end of the day, if our library is difficult to test, it’ll likely be difficult to use in production as well.</p><h2>Conclusion</h2><p>While this article didn’t manage to cover every single aspect of library design and development, I hope that it has provided some useful insight into how I approach building stand-alone Swift libraries.</p><p>It’s also important to point out that not all reusable components need to be implemented as separate libraries — sometimes simply sharing a piece of logic as an internal class or struct is more than good enough — especially since libraries are also dependencies that need to be managed, updated and maintained. But when warranted, building a completely reusable system as its own library definitely has a ton of benefits.</p><p>What do you think? Do you tend to structure parts of your code as reusable libraries, or is it something that you’ll try out? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/my-origin-story-on-ios-dev-discussions</guid><title>Link: My origin story on Sean Allen’s podcast</title><description></description><link>https://podcasts.apple.com/us/podcast/origin-story-john-sundell/id1426167395?i=1000476052675</link><pubDate>Fri, 29 May 2020 12:30:00 +0200</pubDate><content:encoded><![CDATA[<p>This week, I joined my friend Sean Allen on his podcast <em>iOS Dev Discussions</em> to share my “origin story” — that is, how I got started with programming, how writing and podcasting ended up becoming my full-time job, how I’ve been progressing through my career, and examples of the mistakes that I’ve learned from along the way.</p><p>Even though I don’t typically like to spend an hour and a half talking about myself non-stop, I really enjoyed recording this episode, and hope you’ll enjoy it too.</p><p><strong><a href="https://podcasts.apple.com/us/podcast/origin-story-john-sundell/id1426167395?i=1000476052675">Listen to the episode in your podcast player of choice, for example Apple Podcasts</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/instabug-may-2020</guid><title>Sponsor: Instabug</title><description>Thanks a lot to Instabug for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/instabug-may-2020</link><pubDate>Thu, 28 May 2020 19:55:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to Instabug for supporting Swift by Sundell with another two-week sponsorship, and this time they’ve even got a brand new offer, created exclusively for all Swift by Sundell readers.</p><p>If you sign up for a free trial of Instabug using <a href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-may-18-2">this link</a>, then they’ll give you an additional <strong>two months for free</strong> — giving you lots of time to try it out to see if it’s a good fit for you and your team.</p><p>So what’s Instabug? It started out as a really rock solid crash reporter with a strong focus on both privacy and security, and it still is, but it has also evolved into a complete package for improving an app’s overall quality and stability.</p><p>Apart from getting detailed crash reports completely automatically, you can use Instabug to run in-app surveys, to provide direct support to your users, and to monitor your app’s overall performance. Each Instabug report contains a ton of useful debugging information — such as network logs, reproduction steps, and much more.</p><p>I’ve used Instabug myself in several projects, and it’s always been truly great. But don’t take my word for it — <a href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-may-18-2">sign up for a completely free trial</a> to try Instabug for yourself. Using that link also helps keep Swift by Sundell free and available to everyone.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/quickly-replacing-singletons-with-functions</guid><title>Tip: Quickly replacing singletons with functions</title><description></description><link>https://www.swiftbysundell.com/tips/quickly-replacing-singletons-with-functions</link><pubDate>Wed, 27 May 2020 16:35:00 +0200</pubDate><content:encoded><![CDATA[<p>The singleton pattern, while incredibly widely used, is a common source of debate within the Apple developer community. On one hand, singletons provide a really convenient way to share state and functionality across an application — but on the other hand, they also tend to blur the boundaries between the various layers of a code base, and often make tasks like testing more difficult than they otherwise would be.</p><p>As an example, let’s say that we’re working on a <code>UserLoader</code>, which provides a way to load a <code>User</code> with a given ID. Internally, our loader uses two singletons to perform its work — a <code>UserCache</code> and a <code>NetworkManager</code> — and currently looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">User</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-comment">// If our shared cache already contains the user we're
        // about to load, then use that cached value instead:</span>
        <span class="s-keyword">if let</span> user = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-call">user</span>(withID: id) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
        }

        <span class="s-comment">// Use our application's shared network manager to perform
        // a network call, and then decode the result:</span>
        <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-call">loadData</span>(from: .<span class="s-call">user</span>(id: id)) { result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-call">insert</span>(user)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>While the above type does everything that we need it to do in terms of our production code, unit testing its internal logic would be quite difficult — as it currently offers no way for us to inject <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mocked versions</a> of its dependencies.</p><p>For example, let’s say that we wanted to write a test that verifies our caching logic — to make sure that we’re not performing duplicate network requests when loading the same user multiple times. How could we do that using our current singleton-based setup — given that there’s currently no way for us to observe, or otherwise control, what type of networking that our <code>UserLoader</code> is using?</p><p>While there are a number of different approaches that we could take in order to solve this problem, including <a href="https://www.swiftbysundell.com/articles/testing-swift-code-that-uses-system-singletons-in-3-easy-steps">abstracting our dependencies behind protocols</a>, or using some form of mocked networking session — it turns out that there’s a quite easy way to make most singletons mockable, without having to introduce a ton of new abstractions.</p><p>Since Swift supports <a href="https://www.swiftbysundell.com/clips/1">first class functions</a>, we could simply extract each of the functions that we’re looking to call on our singletons, and store them as properties instead — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>
    
    ...
}</code></pre><p>What’s really neat about the above approach is that it barely requires us to change our production code at all. All usages of our <code>UserLoader</code> type can remain identical, there’s no need for advanced dependency injection techniques, and within the implementation of our type we just need to replace our singleton calls with calls to our stored functions — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>

    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">User</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-keyword">if let</span> user = <span class="s-call">cacheRetrieval</span>(id) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
        }

        <span class="s-call">networking</span>(.<span class="s-call">user</span>(id: id)) { [cacheInsertion] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-call">cacheInsertion</span>(user)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>With just that little tweak in place, our <code>UserLoader</code> has now been transformed from being really difficult to test, to being fully testable. All that we now have to do to write the test that we initially wanted to (for verifying our caching logic) is to replace our real networking code with a local closure within our test — for example like this:</p><pre class="splash"><code><span class="s-keyword">class</span> UserLoaderTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testUserCaching() {
        <span class="s-keyword">let</span> user = <span class="s-type">User</span>(id: <span class="s-type">UUID</span>(), name: <span class="s-string">"John"</span>)
        <span class="s-keyword">var</span> loader = <span class="s-type">UserLoader</span>()
        <span class="s-keyword">var</span> networkCallCount = <span class="s-number">0</span>

        <span class="s-comment">// Mock our networking using a closure</span>
        loader.<span class="s-property">networking</span> = { endpoint, handler <span class="s-keyword">in</span>
            networkCallCount += <span class="s-number">1</span>

            <span class="s-call">handler</span>(<span class="s-type">Result</span> {
                <span class="s-keyword">try</span> <span class="s-type">JSONEncoder</span>().<span class="s-call">encode</span>(user)
            })
        }

        <span class="s-comment">// Call our load method twice and capture both results:</span>
        <span class="s-keyword">var</span> results = [<span class="s-type">User</span>?]()
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { results.<span class="s-call">append</span>(<span class="s-keyword">try</span>? $0.<span class="s-call">get</span>()) }
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { results.<span class="s-call">append</span>(<span class="s-keyword">try</span>? $0.<span class="s-call">get</span>()) }

        <span class="s-call">XCTAssertEqual</span>(networkCallCount, <span class="s-number">1</span>, <span class="s-string">"""
        Only one network call should have been made,
        as the first one should have been cached.
        """</span>)

        <span class="s-call">XCTAssertEqual</span>(results, [user, user], <span class="s-string">"""
        The same user should have been loaded both times.
        """</span>)
    }
}</code></pre><p class="info">To learn more about the above approach to writing tests, check out <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift">“Mock-free unit tests in Swift”</a> and <a href="https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments">“Using test assertion messages as comments”</a>.</p><p>As an added bonus, if we wanted to make sure that our dependencies are only ever overridden within our tests, and other types of debug builds — then we could bring in the property wrapper from <em><a href="https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds">“Making properties overridable only in debug builds”</a></em> and annotate each of our functional properties as <code>@DebugOverridable</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">@DebugOverridable
    var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>
    
    ...
}</code></pre><p>Now, is the above technique a <em>“silver bullet”</em> that should always be used to manage singletons? Of course not. Creating proper abstractions and using <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependency injection</a> to keep track of our various dependencies is often the way to go for larger objects and dependency graphs — but if we only want to quickly make a given singleton-reliant type testable, then the above technique can be great to keep in mind.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/getting-the-most-out-of-xcode-previews</guid><title>Getting the most out of Xcode Previews for SwiftUI</title><description>Let’s take a look at a number of techniques, patterns, and ways of structuring UI code that can help us get the very most out of Xcode’s SwiftUI-powered preview system.</description><link>https://www.swiftbysundell.com/articles/getting-the-most-out-of-xcode-previews</link><pubDate>Sun, 24 May 2020 18:42:00 +0200</pubDate><content:encoded><![CDATA[<p>Depending on who you ask, the SwiftUI-powered Previews feature introduced in Xcode 11 either provides a revolutionary new way of building UIs, or falls more towards the gimmick end of the usefulness spectrum.</p><p>However, like with most development tools, the amount of utility that Xcode’s previews can provide is to a large extent determined by how they’re used, and whether our code is set up in a way that’s compatible with them. So this week, let’s take a look at a few techniques, patterns, and ways of structuring UI code that can help us get the very most out of that new preview system.</p><h2>Screens, components, and interactivity</h2><p>Regardless of what framework that’s used to build a given UI, it’s typically useful to separate our various views into two main categories — <em>screens</em> and <em>components</em>. While each of those can then have any number of subcategories, we’re often either working on a given app screen as a whole, or on a (more or less reusable) subset of it.</p><p>As an example, let’s say that we’re using SwiftUI to build such a reusable component — in this case a row for rendering a reminder within something like a todo or reminders list:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Text</span>(title)
            <span class="s-type">Text</span>(description)
                .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">footnote</span>)
        }
    }
}</code></pre><p>Now, as we’re iterating on the above component, we could of course constantly build and run the app, navigate to a screen that its being used on, and verify that everything renders correctly — but that’s boring, repetitive and error prone <em>(which just so happens to be my three main criteria for tasks that should ideally be automated)</em>.</p><p>This type of automation is exactly what Xcode’s Previews feature is all about — as it lets us set up specific instances of our screens and components that’ll automatically get updated as we iterate on our code.</p><p>To create a preview, all that we have to do is to define a type conforming to the <code>PreviewProvider</code> protocol, and place it within the Swift file that we wish the preview to appear alongside of — like this:</p><pre class="splash"><code><span class="s-preprocessing">#if DEBUG</span>
<span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>
        )
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note how we encapsulate the above preview using the <code>DEBUG</code> compiler directive. That’s to prevent us from accidentally using that type within our production code, as if we did, the compiler would throw an error once we build our app in release mode. You can assume that all preview-specific code within this article would be surrounded by that compiler directive, even if it won’t be typed out for the sake of brevity.</p><p>The cool thing is that Xcode’s preview system uses the same <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">DSL-like API</a> that SwiftUI uses, which gives us a lot of power and flexibility when it comes to how we set up our various previews throughout our code base.</p><p>However, the above <code>ReminderRow</code> implementation is currently quite simple, and only relies on read-only data that can easily be passed into its initializer — but what if it required a bit more interactivity? For example, let’s say that we wanted to add a <code>Toggle</code> to our row, to enable our users to easily mark a given reminder as completed:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">@Binding var</span> isCompleted: <span class="s-type">Bool</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Toggle</span>(isOn: $isCompleted) {
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(title)
                <span class="s-type">Text</span>(description)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    .<span class="s-call">font</span>(.<span class="s-dotAccess">footnote</span>)
            }
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Since we’re now using the <code>Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> to set up a <em>two-way binding</em> between our reminder row and any parent that’ll contain it, we also need to pass such a binding when creating our preview as well. One simple (but limited) way to do that would be to use the <code>.constant</code> API, which — like the name implies — enables us to pass a constant value that’ll act as a preview <em>stand-in</em> for a proper binding:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">constant</span>(<span class="s-keyword">false</span>)
        )
    }
}</code></pre><p>However, as alluded to above, constant bindings do have quite strict limits, and they’ll often prevent us from interacting with our UI as we’re previewing it. For example, even if we tap our above <code>Toggle</code>, its <code>isCompleted</code> value will always remain constant, which makes our view seem broken.</p><p>One way to fix that problem would be to instead introduce a custom <code>Binding</code> API for creating fully dynamic mocks — for example by <a href="https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics/%23capturing-values">capturing a given value</a> within a pair of getter and setter closures, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Binding</span> {
    <span class="s-keyword">static func</span> mock(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">var</span> value = value
        <span class="s-keyword">return</span> <span class="s-type">Binding</span>(get: { value }, set: { value = $0 })
    }
}</code></pre><p>With the above in place, we can now go back to our <code>ReminderRowPreview</code> implementation and make it fully interactive — simply by replacing <code><span class="highlight">.constant</code> with <code>.mock</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)</span>
        )
    }
}</code></pre><p>The beauty of the fact that Xcode previews are declared using normal Swift code is that it lets us write our own utilities and abstractions, that in turn can let us use previews in much more powerful ways. But that’s just the beginning.</p><h2>Specific environments</h2><p>Next, let’s take a look at how modifying a component’s surrounding <em>environment</em> can let us preview how it’ll behave under various simulated conditions.</p><p>To get started, let’s use the built-in <code>.colorScheme</code> <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier</a> to preview what our <code>ReminderRow</code> will look like when rendered on a device that’s running in <em>dark mode</em> — like this:</p><pre data-preview="partial-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p>While the above preview setup will render our component <em>itself</em> in dark mode, its surroundings will still remain in light mode, which (given that our view doesn’t have a background color) gives us white text rendered on a white background. Not great.</p><p class="info">Tip: you can use the above <code>PREVIEW</code> button to see the result of that code block. <em>A preview of a preview, if you will. Very meta</em>.</p><p>Now, there are two main ways to solve the above problem. One way is to embed our <code>ReminderRow</code> component in a platform-provided container, such as a <code>NavigationView</code>, before previewing it. If we do that, while also hiding that container view’s navigation bar, then our component will still be rendered using the same layout as before — but now in full dark mode:</p><pre data-preview="complete-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">ReminderRow</span>(
                title: <span class="s-string">"Write weekly article"</span>,
                description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
                isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
            )
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">""</span>)
            .<span class="s-call">navigationBarHidden</span>(<span class="s-keyword">true</span>)
        }
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p class="info">Another variant of the above approach would be to use a <code>TabView</code> instead, and then hide its tab bar in a similar fashion.</p><p>The other way, which doesn’t involve adding any form of navigation stack, would be to give our component an explicit background color — and if we use the <code>systemBackground</code> API on <code>UIColor</code>, then we can mimmic what our component will look like when displayed in dark mode (even if its environment will still remain in light mode):</p><pre data-preview="local-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p>However, what color scheme that our previews will be rendered using is just one of many different environment parameters that we can tweak. For example, we can also tell SwiftUI to preview our component using a given size category (which is what the system’s <em>dynamic type</em> settings translate into), and even control what device that the preview will be rendered on:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewDevice</span>(<span class="s-string">"iPhone 11"</span>)
        .<span class="s-call">environment</span>(\.<span class="s-property">sizeCategory</span>, .<span class="s-dotAccess">accessibilityExtraExtraExtraLarge</span>)
    }
}</code></pre><p class="info">No, the above <code>ExtraExtraExtra</code> name is not a typo, that’s actually what the real API is called, believe it or not.</p><p>So Xcode’s preview system can be tweaked and adjusted in many different ways — which either lets us set up a specific environment for each component, or even create multiple simultaneous ones.</p><h2>Group, iterations, and convenience APIs</h2><p>Just like standard SwiftUI views, multiple preview views can be grouped into a single container using the <code>Group</code> API. However, within Xcode’s Preview feature, such groups are treated in a special way, as the system will create a separate preview for each group member — which in turn enables us to easily preview multiple view configurations at the same time.</p><p>For example, here’s how we could quickly preview what our <code>ReminderRow</code> will look like when rendered in both light and dark mode, using a single <code>PreviewProvider</code>:</p><pre data-preview="multiple-previews"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">let</span> row = <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewLayout</span>(.<span class="s-dotAccess">sizeThatFits</span>)

        <span class="s-keyword">return</span> <span class="s-type">Group</span> {
            row

            row.<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
               .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
        }
    }
}</code></pre><p class="info">Note how we’re using the <code>.previewLayout</code> modifier above to tell Xcode to render our previews without any “device chrome”, and instead just display each component configuration as a stand-alone view.</p><p>While the above approach is really convenient when we just want to preview a small number of permutations — if we want to combine multiple environment modifiers in order to preview more layout variants, then writing the above kind of code each time can start to become a bit tedious.</p><p>But again, we’re working with normal Swift code here, so just like whenever we discover a repetitive source of boilerplate within our production code, we can build our own custom abstractions on top of the preview system — to help us generate a large number of previews with very little effort.</p><p>But before we get started, we’re going to need a few small extensions that’ll help us label each of the previews that we’re about to generate. In this case, we’re going to combine each possible <code>ColorScheme</code> (that is, currently, light and dark mode) with the smallest and largest <code>ContentSizeCategory</code> values — so let’s write the following pair of extensions for generating preview-specific names for those types, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ColorScheme</span> {
    <span class="s-keyword">var</span> previewName: <span class="s-type">String</span> {
        <span class="s-type">String</span>(describing: <span class="s-keyword">self</span>).<span class="s-property">capitalized</span>
    }
}

<span class="s-keyword">extension</span> <span class="s-type">ContentSizeCategory</span> {
    <span class="s-keyword">static let</span> smallestAndLargest = [allCases.<span class="s-property">first</span>!, allCases.<span class="s-property">last</span>!]

    <span class="s-keyword">var</span> previewName: <span class="s-type">String</span> {
        <span class="s-keyword">self</span> == <span class="s-type">Self</span>.<span class="s-property">smallestAndLargest</span>.<span class="s-property">first</span> ? <span class="s-string">"Small"</span> : <span class="s-string">"Large"</span>
    }
}</code></pre><p>Next, let’s borrow the following <code>ForEach</code> extension from <em><a href="https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values">“Using SwiftUI’s ForEach with raw values”</a></em>, which’ll let us more easily loop over an array of values within our SwiftUI code:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ForEach</span> <span class="s-keyword">where</span> <span class="s-type">Data</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span>, <span class="s-type">ID</span> == <span class="s-type">Data</span>.<span class="s-type">Element</span>, <span class="s-type">Content</span>: <span class="s-type">View</span> {
    <span class="s-keyword">init</span>(values: <span class="s-type">Data</span>, content: <span class="s-keyword">@escaping</span> (<span class="s-type">Data</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(values, id: \.<span class="s-keyword">self</span>, content: content)
    }
}</code></pre><p>With the above pieces in place, we can now start building our custom abstractions for generating multiple previews. First, let’s create one for previewing individual components — by implementing a wrapper <code>View</code> that iterates over each possible <code>ColorScheme</code>, as well as the <code>ContentSizeCategory</code> array we defined above, and sets up each preview accordingly:</p><pre class="splash"><code><span class="s-keyword">struct</span> ComponentPreview&lt;Component: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> component: <span class="s-type">Component</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ForEach</span>(values: <span class="s-type">ColorScheme</span>.<span class="s-property">allCases</span>) { scheme <span class="s-keyword">in</span>
            <span class="s-type">ForEach</span>(values: <span class="s-type">ContentSizeCategory</span>.<span class="s-property">smallestAndLargest</span>) { category <span class="s-keyword">in
                self</span>.<span class="s-property">component</span>
                    .<span class="s-call">previewLayout</span>(.<span class="s-dotAccess">sizeThatFits</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
                    .<span class="s-call">colorScheme</span>(scheme)
                    .<span class="s-call">environment</span>(\.<span class="s-property">sizeCategory</span>, category)
                    .<span class="s-call">previewDisplayName</span>(
                        <span class="s-string">"</span>\(scheme.<span class="s-property">previewName</span>) <span class="s-string">+</span> \(category.<span class="s-property">previewName</span>)<span class="s-string">"</span>
                    )
            }
        }
    }
}</code></pre><p class="info">Note that <code>ForEach</code> has the same effect as <code>Group</code> within previews, in that using it generates a separate preview for each value that is being iterated over.</p><p>While the above type is ready to be used as-is, let’s also create a convenience API that’ll let us easily generate a component preview for any <code>View</code> within our code base:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> previewAsComponent() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ComponentPreview</span>(component: <span class="s-keyword">self</span>)
    }
}</code></pre><p>With that done, we can now go back to our <code>ReminderRowPreview</code> from before and easily make it generate four different previews, simply by calling our new <code>previewAsComponent</code> API on our component:</p><pre data-preview="generated-previews"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewAsComponent</span>()
    }
}</code></pre><p>Next, let’s implement a similar abstraction for previewing complete screens, rather than individual components. While we were primarily interested in seeing how a given component behaves when rendered using different color schemes and content size categories — when previewing a whole screen, we might instead want to see how it gets rendered on multiple devices. That way, we’ll be able to get a more wholistic view of our UI, especially if we also combine that list of devices with all possible <code>ColorScheme</code> variants as well — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ScreenPreview&lt;Screen: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> screen: <span class="s-type">Screen</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ForEach</span>(values: deviceNames) { device <span class="s-keyword">in</span>
            <span class="s-type">ForEach</span>(values: <span class="s-type">ColorScheme</span>.<span class="s-property">allCases</span>) { scheme <span class="s-keyword">in</span>
                <span class="s-type">NavigationView</span> {
                    <span class="s-keyword">self</span>.<span class="s-property">screen</span>
                        .<span class="s-call">navigationBarTitle</span>(<span class="s-string">""</span>)
                        .<span class="s-call">navigationBarHidden</span>(<span class="s-keyword">true</span>)
                }
                .<span class="s-call">previewDevice</span>(<span class="s-type">PreviewDevice</span>(rawValue: device))
                .<span class="s-call">colorScheme</span>(scheme)
                .<span class="s-call">previewDisplayName</span>(<span class="s-string">"</span>\(scheme.<span class="s-property">previewName</span>)<span class="s-string">:</span> \(device)<span class="s-string">"</span>)
                .<span class="s-call">navigationViewStyle</span>(<span class="s-type">StackNavigationViewStyle</span>())
            }
        }
    }

    <span class="s-keyword">private var</span> deviceNames: [<span class="s-type">String</span>] {
        [
            <span class="s-string">"iPhone 8"</span>,
            <span class="s-string">"iPhone 11"</span>,
            <span class="s-string">"iPhone 11 Pro Max"</span>,
            <span class="s-string">"iPad (7th generation)"</span>,
            <span class="s-string">"iPad Pro (12.9-inch) (4th generation)"</span>
        ]
    }
}

<span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> previewAsScreen() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ScreenPreview</span>(screen: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">Note how the above list of <code>deviceNames</code> need to exactly match the names that appear in Xcode’s device selector, otherwise the preview system will throw an error.</p><p>With the above abstractions in place, we can now easily generate either a compact or full-screen preview for any of our views with just a single method call — with in turn lets us iterate on our UI code while instantly seeing how it’ll get rendered within multiple kinds of environments. Really cool!</p><h2>Previews are not just for SwiftUI views</h2><p>Finally, let’s take a look at how we can even use Xcode’s Previews feature to iterate on views that are <em>not</em> built using SwiftUI — but rather using any of Apple’s older UI frameworks, such as UIKit, Core Animation, or AppKit.</p><p>Since each preview is defined as a SwiftUI view, and since there are a built-in <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match">backward compatible APIs</a> that let us bring any <code>UIView</code> or <code>UIViewController</code> (or their AppKit equivalents) into the world of SwiftUI — we can connect those two things to make the preview system even more flexible.</p><p>One way to make that happen would be to create specific bridging types for individual views or view controllers — for example like this:</p><pre class="splash"><code><span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingView: <span class="s-type">UIViewControllerRepresentable</span> {
    <span class="s-keyword">var</span> schedule: <span class="s-type">Schedule</span>

    <span class="s-keyword">func</span> makeUIViewController(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">SchedulingViewController</span> {
        <span class="s-type">SchedulingViewController</span>(schedule: schedule)
    }

    <span class="s-keyword">func</span> updateUIViewController(<span class="s-keyword">_</span> uiViewController: <span class="s-type">SchedulingViewController</span>,
                                context: <span class="s-type">Context</span>) {
        <span class="s-comment">// We don’t need to write any update code in this case.</span>
    }
}

<span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingViewPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">SchedulingView</span>(schedule: <span class="s-type">Schedule</span>())
    }
}</code></pre><p class="info">Note how both of the above types are marked as iOS 13-only, using Swift’s <code>@available</code> attribute. While that’s not required for apps that have iOS 13 as their minimum deployment target, many apps that were written using UIKit or AppKit still need to support older versions of Apple’s operating systems.</p><p>While the above works perfectly fine for previewing a single view controller, having to write a dedicated wrapper type each time that we want to create a new preview can again become a source of boilerplate and friction. So let’s create one more abstraction — this time to enable any <code>UIViewController</code> to easily be turned into a SwiftUI preview, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
    <span class="s-keyword">private struct</span> Preview: <span class="s-type">UIViewControllerRepresentable</span> {
        <span class="s-keyword">var</span> viewController: <span class="s-type">UIViewController</span>

        <span class="s-keyword">func</span> makeUIViewController(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">UIViewController</span> {
            viewController
        }

        <span class="s-keyword">func</span> updateUIViewController(<span class="s-keyword">_</span> uiViewController: <span class="s-type">UIViewController</span>,
                                    context: <span class="s-type">Context</span>) {
            <span class="s-comment">// No-op</span>
        }
    }

    <span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
    <span class="s-keyword">func</span> asPreview() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Preview</span>(viewController: <span class="s-keyword">self</span>)
    }
}</code></pre><p>With the above in place, we can now easily make any of our view controllers compatible with Xcode Previews. All that we have to do is to create a thin <code>PreviewProvider</code> that calls our new <code>asPreview</code> method on the view controller that we wish to preview:</p><pre class="splash"><code><span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingViewPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">SchedulingViewController</span>(schedule: <span class="s-type">Schedule</span>()).<span class="s-call">asPreview</span>()
    }
}</code></pre><p>In general, defining lightweight abstractions through small wrappers and extensions can often be a great way to improve a team’s overall productivity. Especially when it comes to things like UI previews, and other kinds of tooling, we’d ideally like to reduce the amount of friction and setup required to the absolute minimum — so that we can spend less time configuring our tools, and more time building fantastic UIs.</p><h2>Conclusion</h2><p>Whether you’ve been using Xcode Previews since the first beta of Xcode 11, or whether they’re completely new to you, I hope that this article has showed you at least one new way of using them. Of course, there are several other ways that these previews can be used, and I’m sure that Apple will introduce even more previewing capabilities at WWDC20, which (at the time of writing) kicks off in just a few weeks.</p><p>Reducing iteration cycle times can really be a big productivity booster, and that’s something that Xcode Previews can definitely help us achieve — by turning time consuming <em>“Build and run”</em> cycles into almost instant updates. They’re not perfect, and can (just like Xcode itself) sometimes be a bit unstable, but — at least if you ask me — they’re a big leap forward for UIKit, AppKit and SwiftUI-based UI development.</p><p>What do you think? Do you enjoy using Xcode’s Preview feature? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/properties</guid><title>Basics: Properties</title><description>In this Basics article, let’s take a look at a few examples of the various kinds of properties that Swift supports, and what their characteristics are.</description><link>https://www.swiftbysundell.com/basics/properties</link><pubDate>Fri, 22 May 2020 18:10:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like many other programming languages, Swift enables us to organize our in-memory data by storing it in <em>properties</em> — constants and variables that are attached to a given type, value, or object. In this Basics article, let’s take a look at a few examples of various kinds of properties and what their characteristics are.</p><p><em>Mutable properties</em> are declared using the <code>var</code> keyword, along with the type of value that the property is going to store — unless the latter can be inferred by the compiler. For example, here we’re defining three properties within a <code>Book</code> type — two of which are manually typed as <code>String</code>, while the third will have its type (<code>Int</code>) inferred from its <em>default value</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">String</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>On the other hand, if we want to <em>prevent</em> one of our properties from being mutated after being initialized, then we can use the <code>let</code> keyword to make it a <em>constant property</em> instead — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="highlight offset-adjust"><span class="s-keyword">let</span> id: <span class="s-type">UUID</span></span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">String</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>The above setup lets us create a <code>Book</code> instance using any value for the above four properties (although we can also omit <code>numberOfStars</code> if we’d like, since it has a default value), but only our mutable properties may be modified afterwards:</p><pre class="splash"><code><span class="s-keyword">var</span> book = <span class="s-type">Book</span>(
    id: <span class="s-type">UUID</span>(),
    name: <span class="s-string">"The Swift Programming Language"</span>,
    author: <span class="s-string">"Apple"</span>
)

book.<span class="s-property">id</span> = <span class="s-type">UUID</span>() <span class="s-comment">// Compiler error</span>
book.<span class="s-property">name</span> = <span class="s-string">"New name"</span> <span class="s-comment">// Allowed</span>
book.<span class="s-property">numberOfStars</span> += <span class="s-number">1</span> <span class="s-comment">// Also allowed</span></code></pre><p>All of the above are examples of <em>stored properties</em> — properties which values are stored in memory once assigned. <em>Computed properties</em>, on the other hand, enable us to define convenience APIs in the shape of properties that are recomputed each time that they’re accessed.</p><p>For example, if different parts of our logic requires us to check if a given book’s name is longer than 30 characters — we might want to encapsulate that calculation within a computed <code>hasLongName</code> property, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">var</span> hasLongName: <span class="s-type">Bool</span> {
        name.<span class="s-property">count</span> &gt; <span class="s-number">30</span>
    }
}</code></pre><p class="info">The benefit of computed properties is that we don’t need to manually sync them with the underlying state that they’re derived from, since they’re recomputed each time. However, that also means that we have to be careful not to perform any heavy computation within them. For more on that topic, check out <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">“Computed properties in Swift”</a>.</p><p>While the above computed property is read-only, we can also define ones that have both a getter and a setter (making them act identical to a <code>var</code>, apart from the fact that their values aren’t stored). As an example, let’s say that we wanted to modify our <code>Book</code> type’s <code>author</code> property to contain an <code>Author</code> value, rather than a <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Author {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> country: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> Book {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">Author</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>To still be able to easily access and modify a given book’s author name, we could then add a computed property with both a getter and setter for doing just that — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">var</span> authorName: <span class="s-type">String</span> {
        <span class="s-keyword">get</span> { author.<span class="s-property">name</span> }
        <span class="s-keyword">set</span> { author.<span class="s-property">name</span> = newValue }
    }
}</code></pre><p>Next, let’s take a look at <em>lazy properties</em>. A property marked with the <code>lazy</code> keyword must be mutable, and have a default value assigned to it — however, that default value won’t be computed until the property is <em>accessed for the first time</em>. That characteristic sort of makes lazy properties act as a <em>“middle ground”</em> between computed and stored ones, which comes very much in handy when building view controller-based UIs.</p><p>Since view controllers shouldn’t start creating their subviews until the <code>viewDidLoad</code> method has been called by the system, one really neat way to avoid having to store such subviews as <a href="https://www.swiftbysundell.com/basics/optionals">optionals</a> is to make them lazy instead — which will defer their creation until they’re accessed (for example in <code>viewDidLoad</code>):</p><pre class="splash"><code><span class="s-keyword">class</span> BookViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private lazy var</span> nameLabel = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> authorLabel = <span class="s-type">UILabel</span>()
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(nameLabel)
        view.<span class="s-call">addSubview</span>(authorLabel)
    }
}</code></pre><p class="info">The above two properties are marked as <code>private</code> to only make them visible within our view controller itself. To learn more about that, check out the <a href="https://www.swiftbysundell.com/basics/access-control">Basics article about access control</a>.</p><p>Lazy properties can also have their value computed by a closure or a function. For example, here we’re now using a private <code>makeNameLabel</code> method to create and setup the <code>UILabel</code> for our <code>nameLabel</code> property:</p><pre class="splash"><code><span class="s-keyword">class</span> BookViewController: <span class="s-type">UIViewController</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">private lazy var</span> nameLabel = <span class="s-call">makeNameLabel</span>()</span>
    <span class="s-keyword">private lazy var</span> authorLabel = <span class="s-type">UILabel</span>()

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(nameLabel)
        view.<span class="s-call">addSubview</span>(authorLabel)
    }
    
    <span class="s-keyword">private func</span> makeNameLabel() -&gt; <span class="s-type">UILabel</span> {
        <span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
        label.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">largeTitle</span>)
        label.<span class="s-property">textColor</span> = .<span class="s-dotAccess">orange</span>
        <span class="s-keyword">return</span> label
    }
}</code></pre><p>So far, we’ve been focusing on <em>instance properties</em>, which are all associated with a single instance of a type. But we can also define <em>static properties</em> — ones that are attached to a type itself, rather than to instances of it. Such properties can be really useful when we want to share a given object across all instances of a type, in order to avoid having to recreate it multiple times.</p><p>For example, here we’ve defined a static <code>dateFormatter</code> property, which is computed through a <em>self-executing <a href="https://www.swiftbysundell.com/basics/closures">closure</a></em>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">static let</span> dateFormatter: <span class="s-type">DateFormatter</span> = {
        <span class="s-keyword">let</span> formatter = <span class="s-type">DateFormatter</span>()
        formatter.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd"</span>
        <span class="s-keyword">return</span> formatter
    }()
}</code></pre><p class="info">Static properties are also implicitly lazy, in that they’re only computed once they’re accessed for the first time.</p><p>We can now use the above date formatter whenever we want to convert a <code>Book</code>-related date into a string, or vice versa:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-type">Book</span>.<span class="s-property">dateFormatter</span>.<span class="s-call">string</span>(from: date)</code></pre><p>We can also attach <em>observers</em> to any stored property, which enables us to run code each time that a value was (or will be) assigned to that property. For example, here we’re using the <code>didSet</code> property observer to automatically update a label every time that a <code>numberOfStars</code> property was changed:</p><pre class="splash"><code><span class="s-keyword">class</span> RatingViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> { starCountLabel.<span class="s-property">text</span> = <span class="s-type">String</span>(numberOfStars) }
    }

    <span class="s-keyword">private lazy var</span> starCountLabel = <span class="s-type">UILabel</span>()
    
    ...
}</code></pre><p class="info">There’s also a <code>willSet</code> variant that gets triggered <em>before</em> the property’s value was assigned, rather than afterwards. To learn more, check out <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">“Property observers in Swift”</a>.</p><p>Property observers can also be used to validate or modify each new value — for example to make sure that a numeric value stays within a certain range, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">Author</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> {
            <span class="s-comment">// If the new value was higher than 9999, we reduce
            // it down to that value, which is our maximum:</span>
            numberOfStars = <span class="s-call">min</span>(<span class="s-number">9999</span>, numberOfStars)
        }
    }
}</code></pre><p>Finally, properties can also be referred to in more dynamic ways using <em>key paths</em> — which let us pass a reference to a property <em>itself</em>, rather than to its <em>value</em>.</p><p>Key paths can also automatically be converted into functions (since Swift 5.2), which means that they’re really useful in situations when we want to extract values for a given property from a collection of instances — for example by using <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap"><code>map</code></a> on an array, like this:</p><pre class="splash"><code><span class="s-comment">// Converting an array of books into an array of strings, by
// extracting each book's name:</span>
<span class="s-keyword">let</span> books = <span class="s-call">loadBooks</span>() <span class="s-comment">// [Book]</span>
<span class="s-keyword">let</span> bookNames = books.<span class="s-call">map</span>(\.<span class="s-property">name</span>) <span class="s-comment">// [String]</span></code></pre><p class="info">To learn more about key paths and how they relate to functions, check out <a href="https://www.swiftbysundell.com/clips/6">this episode of Swift Clips</a>.</p><p>Those are just a few examples of the many ways to use properties in Swift, but hopefully this article has either given you a useful recap of some of their basic set of capabilities, or have inspired you to explore some of these topics further — for example <a href="https://www.swiftbysundell.com/tags/properties">using these articles</a>, or by downloading this article’s playground using the link below.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/javascript-free</guid><title>Why does Swift by Sundell not use any client-side JavaScript?</title><description>In this article, I’ll aim to explain both why I chose not to use any client-side JavaScript when building Swift by Sundell, and why I thought that it was important to emphasize that fact at the bottom of every page.</description><link>https://www.swiftbysundell.com/special/javascript-free</link><pubDate>Thu, 21 May 2020 16:30:00 +0200</pubDate><content:encoded><![CDATA[<p>You might’ve noticed that this website contains the phrase <em>”100% JavaScript-free”</em> at the bottom of every page, which might seem like an odd thing to include — given that most of the modern web is, to a large extent, powered by JavaScript.</p><p>So in this article, I’ll aim to explain both why I chose not to use any client-side JavaScript when building this website, and why I thought that it was important to emphasize that fact at the bottom of every page.</p><h2>The good, the bad and the ugly parts of the modern web</h2><p>Over the past few decades, the web has evolved in truly magnificent ways — from a limited network of computers exchanging plain text, into a fundamental part of modern life. A major step in that evolution process was, without a doubt, the popularization of dynamic, scriptable websites in the early 2000s — so major that it’s often referred to as the birth of <em>“Web 2.0”</em>.</p><p>However, while much of that dynamism is used to enable rich user experiences and powerful web applications, it does often come with a cost. As websites went from simple collections of hypertext files and stylesheets into increasingly sophisticated pieces of software — they also, in general, became much heavier and slower to load.</p><p>Engineering is all about tradeoffs, and when building web experiences that need to be truly dynamic — the tradeoff of having a website be slower to load in order to enable powerful features might be completely worth making. However, even websites that simply display text and images can sometimes take seconds to load and render — even if they don’t (seemingly) include any form of dynamism whatsoever.</p><p>If dynamism is the good, slowness is the bad, then the modern web’s relentless user tracking is definitely the ugly. From user profiling, to invasive analytics libraries, to data harvesting — big data gathering is everywhere, and the same dynamic code execution that’s used to enable those great user experiences is, sadly, often used for the exact opposite — to track visitors, to display disruptive, animated banner ads and autoplaying videos, to interrupt users with growth hacking popups, and much more.</p><p class="info">I’m not saying that all ads are bad. In fact, this website is kept free and available to everyone thanks to <a href="https://www.swiftbysundell.com/ads">responsible advertising</a>, with referral links as the only means of tracking clicks.</p><p>When I set out to build this latest version of Swift by Sundell, I knew that I wanted to stay as far away from those ugly parts of the modern web as possible. So I started to ask myself: What could my website look like if I went the complete opposite direction — if it didn’t include any form of dynamism, but still looked and felt like a modern web experience?</p><p>Basically, could I build a modern website more or less the same way as websites were built in the late 90s — as static collections of HTML, CSS and image files?</p><h2>Back to basics</h2><p>I love a good engineering challenge. In fact, I think that one of the quickest ways to grow as an engineer is to constantly set up small little challenges while doing your daily work. Not only does that encourage you to learn new skills, and to <em>“think outside of the box”</em> — it also often improves the end result as well.</p><p><em>Would it be possible to make this algorithm more efficient, how could I simplify this view hierarchy, or what would this API look like if I refined it down to its simplest possible form?</em> Those are all examples of the types of questions that I love to ask myself while writing code on a daily basis, and — perhaps even more importantly — when starting a new project.</p><p>So, when I set out to build Swift by Sundell 2.0, I expanded that idea of building a website using a basic set of technologies into somewhat of a personal engineering challenge.</p><p>I had initially planned to use client-side JavaScript to implement all of my site’s interactive features — things like theming, search, signing up for my newsletter, podcast audio playback, and more. To me, someone who hadn’t really done any serious web development for the past five or six years, it seemed like running JavaScript code client-side would be the only way to realistically implement those types of features.</p><p>However, as I kicked off pre-production — with prototyping and research as my two main areas of focus — I eventually realized that it might be possible to build everything that I wanted my site to include, without using <em>any client-side JavaScript at all</em>. That got me incredibly excited, as not only would that let me make my website blazingly fast (as each web browser could simply download HTML and CSS files from my server and render them directly), it would also let me show (both myself and others) that building a modern-looking, nice website doesn’t necessarily require any form of dynamic client-side code execution.</p><p>Just like the web itself, both HTML and CSS have evolved so much during the past decade. CSS can now do things like animations, light/dark mode theming, dynamically showing and hiding elements, and much more. HTML also features more built-in components and widgets than ever — enabling websites to leverage functionality that’s built into every modern web browser, rather than having to ship their own JavaScript code that does more or less the exact same thing.</p><p>While using client-side JavaScript to render a website is still a completely valid option, the fact of the matter is, for some use cases — it’s simply not <em>strictly required</em> anymore. Sure, you still might embed external web clips (for example YouTube videos) that execute JavaScript within their own <code>iframe</code>, or use JavaScript server-side, but it turns out that it’s perfectly possible to render a modern web UI without relying on any sort of client-side code execution.</p><h2>I don’t hate JavaScript</h2><p>So the reason Swift by Sundell doesn’t use any client-side JavaScript is not because I hate the language. In fact, making such technical decisions out of some form of spite would, in my opinion, be incredibly short-sighted. This site doesn’t use client-side code execution simply because I wanted to make it as fast as it possibly could be, because I wanted to get as far away from the slowness and creepiness of the modern web as I could, and because I wanted to set myself an engineering challenge.</p><p>I still use JavaScript for certain tools that are run offline, and for some of my server-side code (such as the backend logic that drives my search feature). I also occasionally embed external web pages (like YouTube and Vimeo videos) that use JavaScript. But I wanted to see if I could realize my vision for this website without using it myself on the client side.</p><p>At the end of the day, this whole thing is not about JavaScript as a language — it’s about the concept of dynamic code execution on websites. Honestly, even if Swift somehow ends up becoming the new scripting language for the web, I’d still feel the exact same way. I don’t think every website needs to be a complex <em>“web app”</em>. In fact, I think many websites would become better if they weren’t.</p><p>So there you have it. That’s why this website is 100% JavaScript-free, and I felt that it was important to include that fact on the site itself — not just because I’m honestly quite proud of what I’ve built, but also to provide a (in the grand scheme of things, tiny) counterweight to the modern trend of websites relying more and more on client-side JavaScript.</p><p>I don’t have any delusions of grandeur that my little footer text will change the web as we know it, nor do I claim that I invented this approach in any way — but I thought that if I could provide an example of a somewhat complex website that isn’t rendered using JavaScript, then that could be an interesting point of discussion.</p><p>Now, does this mean that I’m encouraging other developers to take the same approach as me? Just like anything that’s remotely interesting to discuss within technology — it depends.</p><p>Here’s what I suggest: If you’re starting a new website project today, think about what its goals are, and what type of user experience that you’re looking to provide. Will you exclusively be serving static content, with user interactions that could happen through browser navigation and page reloads? If so, perhaps building things using just HTML and CSS might be a way to go. But if that’s not the case, then there’s no shame in using JavaScript either. Use the tools needed to build the products you want to build, and the tools that you and your team prefer. That’s, at the end of the day, what matters the most.</p><p>Just because building a JavaScript-free website was my challenge to myself, doesn’t mean that it has to be yours. And if you prefer building websites using JavaScript, or any other language, then that’s of course fine too. All that matters is that we, collectively as an industry, constantly try to make our software the best, fastest, and most respectful of our users as it possibly can be.</p><p>Thanks for reading! 🚀</p><p class="info">All of the core tools used to build this website are open source. Check out the <a href="https://github.com/johnsundell/publish">Publish static site generator</a> if you wish to learn more, and you’re of course more than welcome to contact me with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/73</guid><title>Podcast: “Truly a general-purpose language”, with special guest Kilo Loco</title><description>Kyle Lee, also known as Kilo Loco, joins John to go behind the scenes of Publish — the static site generator used to build Swift by Sundell. Also, how to make a code base accessible to new team members, learning from open source, getting started with Swift-based web development, and much more.</description><link>https://www.swiftbysundell.com/podcast/73</link><pubDate>Tue, 19 May 2020 21:20:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell73.mp3" type="audio/mpeg"/></audio><p>Kyle Lee, also known as Kilo Loco, joins John to go behind the scenes of Publish — the static site generator used to build Swift by Sundell. Also, how to make a code base accessible to new team members, learning from open source, getting started with Swift-based web development, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://www.goodnotes.com/careers">GoodNotes</a>:</strong> Apply to work on a popular, Apple-featured app, which makes great use of the latest iOS and macOS technologies. GoodNotes is hiring multiple iOS developers to join their team. Check out <a href="https://www.goodnotes.com/careers">goodnotes.com/careers</a> for more info.</li><li><strong><a href="https://instabug.com/sundell">Instabug</a>:</strong> Join thousands of companies, including Lyft and eBay, who use Instabug to enhance their app quality and iterate faster. It’s perfect for teams that are working remotely. Go to <a href="https://instabug.com/sundell">instabug.com/sundell</a> to start your 14-day free trial.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/kilo_loco">Kyle on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.youtube.com/kiloloco">Kilo Loco on YouTube</a></li><li><a href="https://www.youtube.com/watch?v=8IwUMfNpDQI">Kyle’s video about being hired by AWS</a></li><li><a href="https://youtu.be/JqdS-oi96Gk">Kyle’s video tutorial on how to get started with Publish</a></li><li><a href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a href="https://github.com/JohnSundell/Plot">Plot</a></li><li><a href="https://github.com/JohnSundell/Ink">Ink</a></li><li><a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift">The Publish Foundation theme</a></li><li><a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42/%23caseiterable">CaseIterable</a></li><li><a href="https://vapor.codes">Vapor</a></li><li><a href="https://workers.cloudflare.com">Cloudflare Workers</a></li><li><a href="https://www.w3schools.com">W3Schools</a></li><li><a href="https://developer.mozilla.org">The Mozilla Developer Network</a></li><li><a href="https://aws.amazon.com/amplify">AWS Amplify</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/avoiding-deeply-nested-swift-code</guid><title>Avoiding deeply nested Swift code</title><description>This week, let’s take a look at a few techniques that can help us make our code easier to read, test and maintain, by reducing the amount of indentation within it.</description><link>https://www.swiftbysundell.com/articles/avoiding-deeply-nested-swift-code</link><pubDate>Sun, 17 May 2020 21:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Code style and structure are arguably two of the trickiest topics within programming in general. Not because they require any particular skills or vast experience building software, but because they’re so incredibly subjective in nature. What one person might consider the most readable and elegantly structured code in the world, another person might find cryptic and complicated.</p><p>However, there are a few techniques that can be employed to make the code that we write more generally accessible to other people (even if they might disagree with our particular choice of style). This week, let’s take a look at a few such techniques, that all have the same goal — reducing the amount of indentation within our code.</p><h2>Early returns and code extraction</h2><p>Let’s start by taking a look at a relatively simple example of how using early returns within functions can have quite a big impact on the overall readability of our code — even without any additional changes to the way our expressions are formed, or the way our APIs are designed.</p><p>As an example, let’s say that we’ve extended a <code>DocumentLibraryViewController</code> with a short but useful method that filters an array of documents to only include ones that are unread and accessible by the current user:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentLibraryViewController</span> {
    <span class="s-keyword">func</span> unreadDocuments(from list: [<span class="s-type">Document</span>]) -&gt; [<span class="s-type">Document</span>] {
        list.<span class="s-call">filter</span> { document <span class="s-keyword">in
            if</span> user.<span class="s-property">accessLevel</span> &gt;= document.<span class="s-property">requiredAccessLevel</span> {
                <span class="s-keyword">if</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>) {
                    <span class="s-keyword">if</span> document.<span class="s-property">expirationDate</span> &gt; <span class="s-type">Date</span>() {
                        <span class="s-keyword">return true</span>
                    }
                }
            }
    
            <span class="s-keyword">return false</span>
        }
    }
}</code></pre><p>While the above code works as intended, the fact that it’s quite heavily indented arguably makes it more difficult to <em>“mentally parse”</em> than it has to be. So let’s see if we can fix that by using Swift’s <code>guard</code> statement to instead exit out of our method as early as possible — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentLibraryViewController</span> {
    <span class="s-keyword">func</span> unreadDocuments(from list: [<span class="s-type">Document</span>]) -&gt; [<span class="s-type">Document</span>] {
        list.<span class="s-call">filter</span> { document <span class="s-keyword">in
            guard</span> user.<span class="s-property">accessLevel</span> &gt;= document.<span class="s-property">requiredAccessLevel</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
    
            <span class="s-keyword">guard</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
    
            <span class="s-keyword">return</span> document.<span class="s-property">expirationDate</span> &gt; date
        }
    }
}</code></pre><p>Although our logic remains exactly the same, it’s now a bit easier to quickly get an overview of what our function’s actual conditions are — as they’re now listed from top to bottom at the same level of indentation.</p><p>Apart from making our code easier to read and understand for others, one major benefit of doing the above kind of restructuring is that it often lets us discover new ways in which we could improve the overall structure of our code even further.</p><p>For example, since two of our function’s three conditions operate on a <code>Document</code> instance, we could move those conditions into a separate extension instead — which not only makes it easier for that code to be read and tested in isolation, it also enables us to reuse it within other parts of our code base as well:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Document</span> {
    <span class="s-keyword">func</span> isAccessible(for user: <span class="s-type">User</span>, date: <span class="s-type">Date</span> = .<span class="s-keyword">init</span>()) -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">guard</span> user.<span class="s-property">accessLevel</span> &gt;= requiredAccessLevel <span class="s-keyword">else</span> {
            <span class="s-keyword">return false</span>
        }

        <span class="s-keyword">return</span> expirationDate &gt; date
    }
}</code></pre><p class="info">Note how we now also inject the current <code>Date</code>, rather than creating it inline, which further improves the testability of our code (for example through <a href="https://www.swiftbysundell.com/articles/time-traveling-in-swift-unit-tests/">“time traveling”</a>).</p><p>Along the same lines, since our main <code>unreadDocuments(from:)</code> method is directly operating on an array of documents — and only requires a <code>User</code> instance and the current <code>Date</code> apart from that — we could also choose to extract it out from our <code>DocumentLibraryViewController</code>, and instead implement it within an extension on any <code>Sequence</code> that contains <code>Document</code> elements, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">Document</span> {
    <span class="s-keyword">func</span> unread(for user: <span class="s-type">User</span>, date: <span class="s-type">Date</span> = .<span class="s-keyword">init</span>()) -&gt; [<span class="s-type">Document</span>] {
        <span class="s-call">filter</span> { document <span class="s-keyword">in
            guard</span> document.<span class="s-call">isAccessible</span>(for: user, date: date) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }

            <span class="s-keyword">return</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>)
        }
    }
}</code></pre><p class="info"><a href="https://www.swiftbysundell.com/basics/unit-testing">Unit testing</a> the above API is now simply a matter of creating a collection of <code>Document</code> values, along with a <code>User</code> instance and a date according to what part of our logic that we wish to test, and then verifying that our method returns an array of correctly filtered documents.</p><p>With the above tweaks in place, we’ve now not only modeled our logic as separate functions that can be independently used and tested, we’ve also made our call sites read really nicely as well:</p><pre class="splash"><code><span class="s-keyword">let</span> unreadDocuments = allDocuments.<span class="s-call">unread</span>(for: user)</code></pre><p>While we ended up doing much more than <em>just</em> reducing the amount of indentation above, it all started when we decided to do something about a heavily indented piece of code. That’s the magic of refactoring — in that revising an implementation in order to simplify it often reveals brand new venues for improvement as well.</p><h2>Untangling nested logic branches</h2><p>However, not all logic can be modeled as a simple sequence of boolean conditions — sometimes we need to handle a much larger amount of states and permutations, which in turn might require us to branch our logic into several nested <code>if</code> and <code>else</code> statements.</p><p>For example, here we’re working on a <code>ProductViewController</code> that uses a private <code>update</code> method to populate its views once it received a new <code>Product</code> model. Since the overall state that our UI will end up in depends on a number of factors — such as whether a user is currently logged in, if there are any discounts available, and so on — we’ve currently ended up with a quite lengthly, nested implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> sessionController: <span class="s-type">SessionController</span>
    <span class="s-keyword">private lazy var</span> descriptionLabel = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> favoriteButton = <span class="s-type">UIButton</span>()
    <span class="s-keyword">private lazy var</span> priceView = <span class="s-type">PriceView</span>()
    <span class="s-keyword">private lazy var</span> buyButton = <span class="s-type">UIButton</span>()
    
    ...

    <span class="s-keyword">private func</span> update(with product: <span class="s-type">Product</span>) {
        <span class="s-keyword">if let</span> user = sessionController.<span class="s-property">loggedInUser</span> {
            <span class="s-keyword">if let</span> discount = product.<span class="s-call">discount</span>(in: user.<span class="s-property">region</span>) {
                <span class="s-keyword">let</span> lowerPrice = product.<span class="s-property">price</span> - discount
                priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(lowerPrice)
                priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(discount)
            } <span class="s-keyword">else</span> {
                priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(product.<span class="s-property">price</span>)
                priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-string">""</span>
            }

            <span class="s-keyword">if</span> user.<span class="s-property">favoriteProductIDs</span>.<span class="s-call">contains</span>(product.<span class="s-property">id</span>) {
                favoriteButton.<span class="s-call">setTitle</span>(<span class="s-string">"Remove from favorites"</span>,
                    for: .<span class="s-dotAccess">normal</span>
                )
            } <span class="s-keyword">else</span> {
                favoriteButton.<span class="s-call">setTitle</span>(<span class="s-string">"Add to favorites"</span>,
                    for: .<span class="s-dotAccess">normal</span>
                )
            }

            favoriteButton.<span class="s-property">isHidden</span> = <span class="s-keyword">false</span>
        } <span class="s-keyword">else</span> {
            favoriteButton.<span class="s-property">isHidden</span> = <span class="s-keyword">true</span>
            priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(product.<span class="s-property">price</span>)
            priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-string">""</span>
        }

        priceView.<span class="s-property">currencyLabel</span>.<span class="s-property">text</span> = product.<span class="s-property">currency</span>.<span class="s-property">symbol</span>
        descriptionLabel.<span class="s-property">text</span> = product.<span class="s-property">description</span>
    }
}</code></pre><p>At first glance, it might seem like the above is the best that we can do given the number of conditions and separate states that we need to handle — but, just like earlier, once we start breaking our implementation apart into separate pieces, we’ll likely discover new approaches that we could take.</p><p>To get started, let’s move all of our product-bound logic into a private extension on <code>Product</code> instead. That way, we can perform those computations in isolation, and simply return values that represent the current state that our app is in — like this:</p><pre class="splash"><code><span class="s-comment">// By keeping this extension private, we're able to implement
// logic that's specific to our product view within it:</span>
<span class="s-keyword">private extension</span> <span class="s-type">Product</span> {
    <span class="s-keyword">typealias</span> PriceInfo = (price: <span class="s-type">Double</span>, discount: <span class="s-type">Double</span>)

    <span class="s-keyword">func</span> priceInfo(in region: <span class="s-type">Region</span>?) -&gt; <span class="s-type">PriceInfo</span> {
        <span class="s-keyword">guard let</span> discount = region.<span class="s-call">flatMap</span>(discount) <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> (price, <span class="s-number">0</span>)
        }

        <span class="s-keyword">return</span> (price - discount, discount)
    }

    <span class="s-keyword">func</span> favoriteButtonTitle(for user: <span class="s-type">User</span>) -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">if</span> user.<span class="s-property">favoriteProductIDs</span>.<span class="s-call">contains</span>(id) {
            <span class="s-keyword">return</span> <span class="s-string">"Remove from favorites"</span>
        } <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-string">"Add to favorites"</span>
        }
    }
}</code></pre><p class="info">The above <code>ProductInfo</code> type is implemented as a tuple, which provide a great way to <a href="https://www.swiftbysundell.com/articles/using-tuples-as-lightweight-types-in-swift">create lightweight types in Swift</a>.</p><p>Next, let’s encapsulate all of our <em>view state computation</em> within a dedicated type. We’ll call it <code>ProductViewState</code>, given that its only purpose will be to represent the current state of our product view in a read-only fashion. We’ll initialize it with a <code>Product</code> and an optional <code>User</code>, and will then compute our view’s current state using the private <code>Product</code> APIs that we just implemented:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductViewState {
    <span class="s-comment">// By making all of our properties constants, the compiler
    // will generate an error if we forget to assign a value to
    // one of them (including those that are optionals):</span>
    <span class="s-keyword">let</span> priceText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> discountText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> currencyText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> favoriteButtonTitle: <span class="s-type">String</span>?
    <span class="s-keyword">let</span> description: <span class="s-type">String</span>

    <span class="s-keyword">init</span>(product: <span class="s-type">Product</span>, user: <span class="s-type">User</span>?) {
        <span class="s-keyword">let</span> priceInfo = product.<span class="s-call">priceInfo</span>(in: user?.<span class="s-property">region</span>)
        priceText = <span class="s-type">String</span>(priceInfo.<span class="s-property">price</span>)
        discountText = priceInfo.<span class="s-property">discount</span> &gt; <span class="s-number">0</span> ? <span class="s-type">String</span>(priceInfo.<span class="s-property">discount</span>) : <span class="s-string">""</span>
        currencyText = product.<span class="s-property">currency</span>.<span class="s-property">symbol</span>
        favoriteButtonTitle = user.<span class="s-call">map</span>(product.<span class="s-property">favoriteButtonTitle</span>) ?? <span class="s-string">""</span>
        description = product.<span class="s-property">description</span>
    }
}</code></pre><p class="info">We could’ve also modeled the above type as a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift/%23read-only-structs">read-only view model</a>, by calling it <code>ProductViewModel</code> instead.</p><p>With the above two pieces in place, we can now go back to our view controller’s <code>update</code> method and <em>heavily</em> simplify it. Gone are all the nested <code>if</code> and <code>else</code> statements, and we no longer have any duplicate assignments to the same property. Plus, our implementation can now easily be read from top to bottom, since we’ve extracted all of the decision-making conditions into separate, smaller functions:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">private func</span> update(with product: <span class="s-type">Product</span>) {
        <span class="s-keyword">let</span> state = <span class="s-type">ProductViewState</span>(
            product: product,
            user: sessionController.<span class="s-property">loggedInUser</span>
        )

        priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">priceText</span>
        priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">discountText</span>
        priceView.<span class="s-property">currencyLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">currencyText</span>

        favoriteButton.<span class="s-call">setTitle</span>(state.<span class="s-property">favoriteButtonTitle</span>, for: .<span class="s-dotAccess">normal</span>)
        favoriteButton.<span class="s-property">isHidden</span> = (state.<span class="s-property">favoriteButtonTitle</span> == <span class="s-keyword">nil</span>)

        descriptionLabel.<span class="s-property">text</span> = state.<span class="s-property">description</span>
    }
}</code></pre><p>Just like when we previously extracted our <code>Document</code>-related methods into separate APIs, a big benefit of the above kind of refactoring is that it makes unit testing so much simpler — as all of our logic is now structured as <a href="https://www.swiftbysundell.com/articles/pure-functions-in-swift">pure functions</a> that can be individually developed and tested.</p><h2>SwiftUI views</h2><p>Finally, let’s take a look at how we can employ some of the same techniques that we used above when constructing views using SwiftUI.</p><p>Since <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">SwiftUI’s DSL</a> uses closures to encapsulate the construction of our various views, it’s quite easy to end up with an implementation that’s heavily indented, even when building a relatively simple list view — such as this one:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> manager: <span class="s-type">EventManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(manager.<span class="s-property">upcomingEvents</span>) { event <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(
                    destination: <span class="s-type">EventView</span>(event: event),
                    label: {
                        <span class="s-type">HStack</span> {
                            <span class="s-type">Image</span>(event.<span class="s-property">iconName</span>)
                            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                                <span class="s-type">Text</span>(event.<span class="s-property">title</span>)
                                <span class="s-type">Text</span>(event.<span class="s-property">location</span>.<span class="s-property">name</span>)
                            }
                        }
                    }
                )
            }
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Upcoming events"</span>)
        }
    }
}</code></pre><p>Although it might seem like the above kind of <em>“code pyramid”</em> is inevitable when working with nested SwiftUI views, there are once again a number of ways that we could heavily flatten (and simplify) our code in this case.</p><p>Just like how we previously extracted parts of our various logic into separate types and functions, we can do the same thing here as well — for example by creating a dedicated type for rendering the rows that appear within the above list. Since SwiftUI views are just lightweight descriptions of our UI, that can most often be done by simply moving the code in question into a new <code>View</code>-conforming type — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> event: <span class="s-type">Event</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(event.<span class="s-property">iconName</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(event.<span class="s-property">title</span>)
                <span class="s-type">Text</span>(event.<span class="s-property">location</span>.<span class="s-property">name</span>)
            }
        }
    }
}</code></pre><p>Apart from creating stand-alone view types, using private factory methods can also be a great way to split a SwiftUI view up into separate pieces. For example, here’s how we could define a method that wraps an instance of our new <code>EventListRow</code> type within a <code>NavigationLink</code>, making it ready to be displayed within our list:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EventListView</span> {
    <span class="s-keyword">func</span> makeRow(for event: <span class="s-type">Event</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationLink</span>(
            destination: <span class="s-type">EventView</span>(event: event),
            label: {
                <span class="s-type">EventListRow</span>(event: event)
            }
        )
    }
}</code></pre><p>The cool thing is that, with just the above two tweaks in place, we can now remove almost all of the indentation from our <code>EventListView</code> — by passing the above <code>makeRow</code> method as a <a href="https://www.swiftbysundell.com/clips/1">first class function</a> when creating our <code>List</code>, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> manager: <span class="s-type">EventManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(manager.<span class="s-property">upcomingEvents</span>, rowContent: makeRow)
                .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Upcoming events"</span>)
        }
    }
}</code></pre><p>While always removing all sources of indentation is hardly a good goal to have — as the right amount of indentation can also help us <em>improve</em> the readability of a given type or function — it’s interesting to see just how much flexibility Swift gives us in terms of code structure, which in turn lets us adapt our choice of structure within each given situation.</p><h2>Conclusion</h2><p>Although it might seem like a heavy amount of indentation is inevitable within certain parts of a code base, that’s actually rarely the case — as there are often multiple approaches that we can take to structure our logic in ways that not only reduces the amount of indentation needed, but also makes the overall flow of our logic easier to follow.</p><p>Once we start untangling a piece of heavily indented code, it’s also likely that we’ll discover new ways to structure, reuse and test that code as well — which can make refactoring a very natural and neat way to come up with shared abstractions, and to improve the overall testability of a code base.</p><p>But again, not all indentation deserves to be removed, but hopefully this article has given you some insights into how I approach these kinds of refactoring and maintenance tasks. Feel free to let me know what you think — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/loca-studio-may-2020</guid><title>Sponsor: Loca Studio</title><description>Thanks a lot to Loca Studio for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/loca-studio-may-2020</link><pubDate>Thu, 14 May 2020 19:50:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to the team behind <a href="https://www.cunningo.com/locastudio/index.html?campaign=swiftbysundell-202005">Loca Studio</a>, a fantastic app for managing Xcode’s localization files, for sponsoring Swift by Sundell this week. Their support helps me keep the website, and this RSS feed, free and open to everyone.</p><p>Loca Studio is a fast, native Mac app that can help you detect common mistakes within your localization files, help you find the right format strings to use, and much more. As an example, Loca Studio will validate strings referring to system features (such as the name of the Settings app, or other operating system terms), and will warn you if any of your app’s translations seem incorrect.</p><p>It also includes features for merging localized strings, for previewing what a formatted string will look like in various locales and languages, and much more.</p><p><a href="https://www.cunningo.com/locastudio/index.html?campaign=swiftbysundell-202005">Try Loca Studio for free</a>, which also helps support Swift by Sundell.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/building-an-observable-type-for-swiftui-views</guid><title>Tip: Building an Observable type for SwiftUI views</title><description></description><link>https://www.swiftbysundell.com/tips/building-an-observable-type-for-swiftui-views</link><pubDate>Thu, 14 May 2020 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>SwiftUI ships with a number of tools for connecting a view to a piece of state, which in turn makes the framework automatically re-render that view whenever its state was modified.</p><p>For example, the <code>@State</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> can be used to keep track of a view’s internal, local state — while <code>@Binding</code> enables us to pass mutable state between different views. There’s also <code>@ObservedObject</code>, which along with its <code>ObservableObject</code> protocol counterpart, enables us to construct custom objects that our views can then observe.</p><p>Here’s how we might implement a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a> as such an observed object, which uses a <a href="https://www.swiftbysundell.com/basics/combine">Combine publisher</a> to subscribe to changes in its underlying data model — in this case a <code>Podcast</code> type:</p><pre class="splash"><code><span class="s-keyword">class</span> PodcastViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> podcast: <span class="s-type">Podcast</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">Publisher</span>&gt;(
        podcast: <span class="s-type">Podcast</span>,
        publisher: <span class="s-type">T</span>
    ) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Output</span> == <span class="s-type">Podcast</span>, <span class="s-type">T</span>.<span class="s-type">Failure</span> == <span class="s-type">Never</span> {
        <span class="s-keyword">self</span>.<span class="s-property">podcast</span> = podcast
        <span class="s-keyword">self</span>.<span class="s-property">cancellable</span> = publisher.<span class="s-call">assign</span>(to: \.<span class="s-property">podcast</span>, on: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">To learn more about the <code>@Published</code> property wrapper used above, check out <a href="https://www.swiftbysundell.com/articles/published-properties-in-swift">“Published properties in Swift”</a>.</p><p>We could then build a corresponding <code>PodcastView</code> that uses the above <code>PodcastViewModel</code> as its data source, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> PodcastView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">PodcastViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: viewModel.<span class="s-property">podcast</span>.<span class="s-property">image</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(viewModel.<span class="s-property">podcast</span>.<span class="s-property">name</span>)
                    .<span class="s-call">bold</span>()
                <span class="s-type">Text</span>(viewModel.<span class="s-property">podcast</span>.<span class="s-property">creator</span>)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            }
        }
    }
}</code></pre><p>While view models can be incredibly useful in order to encapsulate the logic required to bridge the gap between a view and its data model (while also enforcing some separation of concerns between those two layers), in the above case, our view model simply acts as an <em>observable wrapper</em> for our <code>Podcast</code> model — which in turn requires us to always access that model using <code>viewModel.podcast</code>.</p><p>Since there’s really nothing <code>Podcast</code> model-specific about our view model implementation — let’s see if we can generalize it instead, and in doing so, make it easier to use as well. To do that, let’s rename it to <code>Observable</code>, and make it a generic over any <code>Value</code> — with one important addition: we’ll also make it support <em><a href="https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths">dynamic member lookup</a></em>, like this:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
final class</span> Observable&lt;Value&gt;: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> value: <span class="s-type">Value</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">Publisher</span>&gt;(
        value: <span class="s-type">Value</span>,
        publisher: <span class="s-type">T</span>
    ) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Output</span> == <span class="s-type">Value</span>, <span class="s-type">T</span>.<span class="s-type">Failure</span> == <span class="s-type">Never</span> {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
        <span class="s-keyword">self</span>.<span class="s-property">cancellable</span> = publisher.<span class="s-call">assign</span>(to: \.<span class="s-property">value</span>, on: <span class="s-keyword">self</span>)
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}</code></pre><p>The big benefit of the above approach (apart from the fact that we now have a completely reusable type that can be used to observe <em>any model</em>) is that we can now access each of our <code>Podcast</code> model properties <em>directly</em>, thanks to <code>@dynamicMemberLookup</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> PodcastView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> podcast: <span class="s-type">Observable</span>&lt;<span class="s-type">Podcast</span>&gt;

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: podcast.<span class="s-property">image</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(podcast.<span class="s-property">name</span>)
                    .<span class="s-call">bold</span>()
                <span class="s-type">Text</span>(podcast.<span class="s-property">creator</span>)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            }
        }
    }
}</code></pre><p>Much nicer! Now, time for the bonus round. Since our new <code>Observable</code> type is very similar to Combine’s built-in <code>CurrentValueSubject</code> (in that it keeps track of the latest emitted value), let’s also create a convenience API that’ll let us easily convert any such subject into an <code>Observable</code> object:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">CurrentValueSubject</span> <span class="s-keyword">where</span> <span class="s-type">Failure</span> == <span class="s-type">Never</span> {
    <span class="s-keyword">func</span> asObservable() -&gt; <span class="s-type">Observable</span>&lt;<span class="s-type">Output</span>&gt; {
        <span class="s-type">Observable</span>(value: value, publisher: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">Note that a key difference between our <code>Observable</code> and Combine’s <code>CurrentValueSubject</code> is that the latter is mutable, which might not be something that we want to expose to certain parts of our view layer.</p><p>With the above in place, we can now easily create instances of our <code>PodcastView</code> from a <code>CurrentValueSubject</code> that emits new values whenever the podcast in question was updated:</p><pre class="splash"><code><span class="s-keyword">func</span> makePodcastView(
    with subject: <span class="s-type">CurrentValueSubject</span>&lt;<span class="s-type">Podcast</span>, <span class="s-type">Never</span>&gt;
) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
    <span class="s-type">PodcastView</span>(podcast: subject.<span class="s-call">asObservable</span>())
}</code></pre><p>While there are several other approaches can be used to update SwiftUI views whenever their models change (including using the built-in <code>.onReceive</code> view modifier to let a view subscribe to a Combine publisher directly), I feel like the above kind of <code>Observable</code> type provides a really neat way to let a view subscribe to a single model in a read-only fashion, without requiring that view to contain any form of subscription logic.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments</guid><title>Tip: Using test assertion messages as comments</title><description></description><link>https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments</link><pubDate>Tue, 12 May 2020 18:55:00 +0200</pubDate><content:encoded><![CDATA[<p>Often when writing tests, we might want to add some additional information to our code — for example in order to explain why a certain operation is being performed, to give debugging hints in case of a future failure, or to make the code easier to follow.</p><p>One way to do that is of course to use good old fashioned comments — like in the following test, which verifies that we’re able to add and then remove an item from a <code>TodoList</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> TodoListTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testAddingAndRemovingItem() {
        <span class="s-comment">// First, add an item and make sure that it's added</span>
        <span class="s-keyword">var</span> list = <span class="s-type">TodoList</span>()
        <span class="s-keyword">let</span> item = list.<span class="s-call">addItem</span>(named: <span class="s-string">"My item"</span>)
        <span class="s-call">XCTAssertTrue</span>(list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>))

        <span class="s-comment">// Then, remove the item and make sure that it was removed</span>
        list.<span class="s-call">removeItem</span>(item)
        <span class="s-call">XCTAssertFalse</span>(list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>))
    }
}</code></pre><p>There’s certainly nothing wrong with the above approach, but like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">“Writing self-documenting Swift code”</a></em>, if we can find ways to let our code <em>explain itself</em>, then that can often remove much of the need for the above kind of contextual comments.</p><p>One way to do that within our testing code is to make use of the fact that we can pass custom messages to each of XCTest’s various assertion functions. That way, we can convert our comments into messages that are directly attached to our verification code — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> TodoListTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testAddingAndRemovingItem() {
        <span class="s-keyword">var</span> list = <span class="s-type">TodoList</span>()
        <span class="s-keyword">let</span> item = list.<span class="s-call">addItem</span>(named: <span class="s-string">"My item"</span>)
        
        <span class="s-call">XCTAssertTrue</span>(
            list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>),
            <span class="s-string">"A TodoList should contain an item that was added"</span>
        )

        list.<span class="s-call">removeItem</span>(item)
        
        <span class="s-call">XCTAssertFalse</span>(
            list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>),
            <span class="s-string">"Item should have been removed after calling 'removeItem()'"</span>
        )
    }
}</code></pre><p>The major benefit of the above approach is that not only will our messages still be fully readable within our source code — they’ll also be displayed within our logs when an assertion failed, which often makes it much easier to identify and debug test failures when using <a href="https://www.swiftbysundell.com/articles/adding-continuous-integration-to-a-swift-project">continuous integration</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/propagating-user-facing-errors-in-swift</guid><title>Propagating user-facing errors in Swift</title><description>Let’s take a look at a few techniques that can make it much simpler to propagate runtime errors to our users, and how employing some of those techniques could help us present richer error messages without having to add a ton of complexity within each UI implementation.</description><link>https://www.swiftbysundell.com/articles/propagating-user-facing-errors-in-swift</link><pubDate>Sun, 10 May 2020 20:25:00 +0200</pubDate><content:encoded><![CDATA[<p>If it’s one thing that almost all programs have in common is that they will, at some point, encounter some form of error. While some errors might be the result of bugs and failures caused by faulty code, incorrect assumptions, or system incompatibilities — there are also multiple kinds of errors that are completely normal, valid parts of a program’s execution.</p><p>One challenge with such errors is how to propagate and present them to the user, which can be really tricky, even if we disregard tasks like crafting informative and actionable error messages. It’s so incredibly common to see apps either display a generic <em>”An error occurred”</em> message regardless of what kind of error that was encountered, or throw walls of highly technical debugging text at the user — neither of which is a great user experience.</p><p>So this week, let’s take a look at a few techniques that can make it much simpler to propagate runtime errors to our users, and how employing some of those techniques could help us present richer error messages without having to add a ton of complexity within each UI implementation.</p><h2>An evolution from simple to complex</h2><p>When starting to build a new app feature, it’s arguably a good idea to start out as simple as possible — which typically helps us avoid <em>premature optimization</em>, by enabling us to discover the most appropriate structure and abstractions as we iterate on our code.</p><p>When it comes to error propagation, such a simple implementation might look like the following example — in which we attempt to load a list of conversations within some form of messaging app, and then pass any error that was encountered into a private <code>handle</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> loader: <span class="s-type">ConversationLoader</span>
    
    ...

    <span class="s-keyword">private func</span> loadConversations() {
        <span class="s-comment">// Load our list of converstions, and then either render
        // our results, or handle any error that was encountered:</span>
        loader.<span class="s-call">loadConversations</span> { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> conversations):
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(conversations)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-keyword">self</span>?.<span class="s-call">handle</span>(error)
            }
        }
    }
}</code></pre><p>Our <code>handle</code> method might then, for example, create a <code>UIAlertController</code> in order to render the passed error’s <code>localizedDescription</code> to the user, along with a <em>”Retry”</em> button — like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ConversationListViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )
        
        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Retry"</span>,
            style: .<span class="s-dotAccess">default</span>,
            handler: { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_ in
                self</span>?.<span class="s-call">loadConversations</span>()
            }
        ))

        <span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above approach (or something like it, such as using a custom error <a href="https://www.swiftbysundell.com/articles/using-child-view-controllers-as-plugins-in-swift">child view controller</a>, rather than an alert view) is incredibly common, it does come with a few significant drawbacks.</p><p>First of all, since we’re directly rendering any error that was encountered while loading our list of models, chances are high that we’ll end up displaying code-level implementation details to the user — which isn’t great — and secondly, we’re always showing a <em>“Retry”</em> button, regardless of whether retrying the operation will realistically yield a different result.</p><p>To address those two issues, we might try to make our errors a bit more granular and well-defined, for example by introducing a dedicated <code>NetworkingError</code> enum that we make sure has proper localized messages for each case:</p><pre class="splash"><code><span class="s-keyword">enum</span> NetworkingError: <span class="s-type">LocalizedError</span> {
    <span class="s-keyword">case</span> deviceIsOffline
    <span class="s-keyword">case</span> unauthorized
    <span class="s-keyword">case</span> resourceNotFound
    <span class="s-keyword">case</span> serverError(<span class="s-type">Error</span>)
    <span class="s-keyword">case</span> missingData
    <span class="s-keyword">case</span> decodingFailed(<span class="s-type">Error</span>)
}</code></pre><p>If we then go back and retrofit our <code>ConversationLoader</code> with support for our new error enum, we’ll end up with a much more <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">unified error API</a> that our various UI components will be able to use to handle errors in a more precise manner:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;[<span class="s-type">Conversation</span>], <span class="s-type">NetworkingError</span>&gt;) -&gt; <span class="s-type">Void</span>
    
    ...

    <span class="s-keyword">func</span> loadConverstions(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        ...
    }
}</code></pre><p>However, performing error handling in a <em>”precise manner”</em> is easier said than done, and often leads to a ton of complicated code that needs to be specifically written for each feature or use case — since each part of our code base is likely to use a slightly different set of errors.</p><p>As an example, here’s how complex our previous <code>handle</code> method now has become, once we’ve started customizing the way we present our errors depending on what type of error that was encountered:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ConversationListViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">NetworkingError</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )
        
        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        <span class="s-comment">// Here we take different actions depending on the error
        // that was encontered. We've decided that only some
        // errors warrant a "Retry" button, while an "unauthorized"
        // error should redirect the user to the login screen,
        // since their login session has most likely expired:</span>
        <span class="s-keyword">switch</span> error {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">deviceIsOffline</span>, .<span class="s-dotAccess">serverError</span>:
            alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
                title: <span class="s-string">"Retry"</span>,
                style: .<span class="s-dotAccess">default</span>,
                handler: { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_ in
                    self</span>?.<span class="s-call">loadConversations</span>()
                }
            ))
        <span class="s-keyword">case</span> .<span class="s-dotAccess">resourceNotFound</span>, .<span class="s-dotAccess">missingData</span>, .<span class="s-dotAccess">decodingFailed</span>
            <span class="s-keyword">break
        case</span> .<span class="s-dotAccess">unauthorized</span>:
            <span class="s-keyword">return</span> navigator.<span class="s-call">logOut</span>()
        }

        <span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above will most likely lead to an improved user experience — since we’re now tailoring the presentation of each error according to what the user can reasonably do about it — maintaining that sort of complexity within each feature isn’t going to be fun, so let’s see if we can find a better solution.</p><h2>Using the power of the responder chain</h2><p>If we remain within the realm of UIKit for now, one way to improve the way that UI-related errors are propagated within an app is to make use of the <em>responder chain</em>.</p><p>The responder chain is a system that both UIKit and AppKit have in common (although its implementation does differ between the two frameworks), and is how all sorts of system events — from touches, to keyboard events, to input focus — are handled. Any <code>UIResponder</code> subclass (such as <code>UIView</code> and <code>UIViewController</code>) can participate in the responder chain, and the system will automatically add all of our views and view controllers to it as soon as they’re added to our view hierarchy.</p><p>On iOS, the responder chain starts at the app’s <code>AppDelegate</code>, and goes all the way through our view hierarchy until it reaches our topmost views — which means that it is, in many ways, an ideal tool to use for tasks like propagation.</p><p>So let’s take a look at how we could move our error handling and propagation code to the responder chain — by first extending <code>UIResponder</code> with a method that, by default, moves any error that we send to it upwards through the chain using the built-in <code>next</code> property:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-comment">// We're dispatching our new method through the Objective-C
    // runtime, to enable us to override it within subclasses:</span>
    <span class="s-keyword">@objc func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                      from viewController: <span class="s-type">UIViewController</span>,
                      retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-comment">// This assertion will help us identify errors that were
        // either emitted by a view controller *before* it was
        // added to the responder chain, or never handled at all:</span>
        <span class="s-keyword">guard let</span> nextResponder = next <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-call">assertionFailure</span>(<span class="s-string">"""
            Unhandled error</span> \(error) <span class="s-string">from</span> \(viewController)
            <span class="s-string">"""</span>)
        }

        nextResponder.<span class="s-call">handle</span>(error,
            from: viewController,
            retryHandler: retryHandler
        )
    }
}</code></pre><p class="info">The above design is quite similar to AppKit’s <code>presentError</code> API, which also uses the responder chain in a similar fashion.</p><p>Since much of our UI-based error propagation is likely to originate from view controllers, let’s also extend <code>UIViewController</code> with the following convenience API to avoid having to manually pass <code>self</code> every time that we want to handle an error:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-call">handle</span>(error, from: <span class="s-keyword">self</span>, retryHandler: retryHandler)
    }
}</code></pre><p>Using our new API is now <em>almost</em> as simple as calling the private <code>handle</code> method that we previously used within our <code>ConversationListViewController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">func</span> loadConversations() {
        loader.<span class="s-call">loadConversations</span> { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> conversations):
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(conversations)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-keyword">self</span>?.<span class="s-call">handle</span>(error, retryHandler: {
                    <span class="s-keyword">self</span>?.<span class="s-call">loadConversations</span>()
                })
            }
        }
    }
}</code></pre><p>With our new error propagation system in place, we can now implement our error handling code anywhere within the responder chain — which both gives us a ton of flexibility, and also lets us move away from requiring each view controller to manually implement its own error handling code.</p><h2>Generic error categories</h2><p>However, before we’ll be able to fully utilize our new error handling system, we’re going to need a slightly more generic way to identify the various errors that our code can produce — otherwise we’ll likely end up with quite massive implementations that need to perform lots of type casting between our different error types.</p><p>One way to make that happen would be to introduce a set of <em>error categories</em> that we can divide our app’s errors into — for example by using an enum and a <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">specialized</a> <code>CategorizedError</code> protocol:</p><pre class="splash"><code><span class="s-keyword">enum</span> ErrorCategory {
    <span class="s-keyword">case</span> nonRetryable
    <span class="s-keyword">case</span> retryable
    <span class="s-keyword">case</span> requiresLogout
}

<span class="s-keyword">protocol</span> CategorizedError: <span class="s-type">Error</span> {
    <span class="s-keyword">var</span> category: <span class="s-type">ErrorCategory</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Now all that we have to do to categorize an error is make it conform to the above protocol, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkingError</span>: <span class="s-type">CategorizedError</span> {
    <span class="s-keyword">var</span> category: <span class="s-type">ErrorCategory</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">deviceIsOffline</span>, .<span class="s-dotAccess">serverError</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">retryable</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">resourceNotFound</span>, .<span class="s-dotAccess">missingData</span>, .<span class="s-dotAccess">decodingFailed</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">nonRetryable</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">unauthorized</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">requiresLogout</span>
        }
    }
}</code></pre><p>Finally, let’s also extend <code>Error</code> with a convenience API that’ll let us retrieve an <code>ErrorCategory</code> from any error — by falling back to a default category for errors that don’t yet support categorization:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Error</span> {
    <span class="s-keyword">func</span> resolveCategory() -&gt; <span class="s-type">ErrorCategory</span> {
        <span class="s-keyword">guard let</span> categorized = <span class="s-keyword">self as</span>? <span class="s-type">CategorizedError</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// We could optionally choose to trigger an assertion
            // here, if we consider it important that all of our
            // errors have categories assigned to them.</span>
            <span class="s-keyword">return</span> .<span class="s-dotAccess">nonRetryable</span>
        }

        <span class="s-keyword">return</span> categorized.<span class="s-property">category</span>
    }
}</code></pre><p>With the above in place, we’ll now be able to write our error handling code in a complete reusable way, without losing any precision. In this case, we’ll do that by extending our <code>AppDelegate</code> (which sits at the top of the responder chain) with the following implementation:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">AppDelegate</span> {
    <span class="s-keyword">override func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                         from viewController: <span class="s-type">UIViewController</span>,
                         retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        <span class="s-keyword">switch</span> error.<span class="s-call">resolveCategory</span>() {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">retryable</span>:
            alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
                title: <span class="s-string">"Retry"</span>,
                style: .<span class="s-dotAccess">default</span>,
                handler: { <span class="s-keyword">_ in</span> <span class="s-call">retryHandler</span>() }
            ))
        <span class="s-keyword">case</span> .<span class="s-dotAccess">nonRetryable</span>:
            <span class="s-keyword">break
        case</span> .<span class="s-dotAccess">requiresLogout</span>:
            <span class="s-keyword">return</span> <span class="s-call">performLogout</span>()
        }

        viewController.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>Apart from the fact that we now have a single error handling implementation that can be used to present any error that was encountered by any of our view controllers, the power of the responder chain is that we can also easily insert more specific handling code anywhere within that chain.</p><p>For example, if an error that requires logout (such as an authorization error) was encountered on our login screen, we probably want to display an error message, rather than attempting to log the user out. To make that happen, we just have to implement <code>handle</code> within that view controller, add our custom error handling, and then pass any errors that we don’t wish to handle at that level to our superclass — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">LoginViewController</span> {
    <span class="s-keyword">override func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                         from viewController: <span class="s-type">UIViewController</span>,
                         retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">guard</span> error.<span class="s-call">resolveCategory</span>() == .<span class="s-dotAccess">requiresLogout</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return super</span>.<span class="s-call">handle</span>(error,
                from: viewController,
                retryHandler: retryHandler
            )
        }

        errorLabel.<span class="s-property">text</span> = <span class="s-string">"""
        Login failed. Check your username and password.
        """</span>
    }
}</code></pre><p class="info">The above override will also catch all errors produced by our login view controller’s children.</p><p>While there are a number of other factors that we might want to take into account when handling errors (such as avoiding stacking multiple alerts on top of each other, or to automatically retry certain operations rather than showing an error), using the responder chain to propagate user-facing errors can be incredibly powerful — as it lets us write finely grained error handling code without having to spread that code across all of our various UI implementations.</p><h2>From UIKit to SwiftUI</h2><p>Next, let’s take a look at how we could achieve a setup similar to the UIKit-based one that we just explored, but within SwiftUI instead. While SwiftUI does not have an <em>actual responder chain</em>, it does feature other mechanisms that let us propagate information upwards and downwards through a view hierarchy.</p><p>To get started, let’s create an <code>ErrorHandler</code> protocol that we’ll use to define our various error handlers. When asked to handle an error, we’ll also give each handler access to the <code>View</code> that the error was encountered in, as well as a <code>LoginStateController</code> that’s used to manage our app’s login state, and just like within our UIKit-based implementation, we’ll use a <code>retryHandler</code> closure to enable failed operations to be retried:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ErrorHandler {
    <span class="s-keyword">func</span> handle&lt;T: <span class="s-type">View</span>&gt;(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        <span class="s-keyword">in</span> view: <span class="s-type">T</span>,
        loginStateController: <span class="s-type">LoginStateController</span>,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">AnyView</span>
}</code></pre><p class="info">Note that the above <code>error</code> parameter is an optional, which will later enable us to pass in our view errors in a declarative, SwiftUI-friendly way.</p><p>Next, let’s write a default implementation of the above protocol, which (just like when using UIKit) will present an alert view for each error that was encountered. It’ll do so by converting its passed parameters into an internal <code>Presentation</code> model, which will then be wrapped in a <code>Binding</code> value and used to present an <code>Alert</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> AlertErrorHandler: <span class="s-type">ErrorHandler</span> {
    <span class="s-comment">// We give our handler an ID, so that SwiftUI will be able
    // to keep track of the alerts that it creates as it updates
    // our various views:</span>
    <span class="s-keyword">private let</span> id = <span class="s-type">UUID</span>()

    <span class="s-keyword">func</span> handle&lt;T: <span class="s-type">View</span>&gt;(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        <span class="s-keyword">in</span> view: <span class="s-type">T</span>,
        loginStateController: <span class="s-type">LoginStateController</span>,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">AnyView</span> {
        <span class="s-keyword">guard</span> error?.<span class="s-call">resolveCategory</span>() != .<span class="s-dotAccess">requiresLogout</span> <span class="s-keyword">else</span> {
            loginStateController.<span class="s-property">state</span> = .<span class="s-dotAccess">loggedOut</span>
            <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(view)
        }

        <span class="s-keyword">var</span> presentation = error.<span class="s-call">map</span> { <span class="s-type">Presentation</span>(
            id: id,
            error: $0,
            retryHandler: retryHandler
        )}

        <span class="s-comment">// We need to convert our model to a Binding value in
        // order to be able to present an alert using it:</span>
        <span class="s-keyword">let</span> binding = <span class="s-type">Binding</span>(
            get: { presentation },
            set: { presentation = $0 }
        )

        <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(view.<span class="s-call">alert</span>(item: binding, content: makeAlert))
    }
}</code></pre><p>The reason we need a <code>Presentation</code> model is because SwiftUI requires a value to be <code>Identifiable</code> in order to be able to display an alert for it. By using our handler’s own <code>UUID</code> as our identifier (like we do above), we’ll be able to provide SwiftUI with a stable identity for each alert that we create, even as it updates and re-renders our views.</p><p>Let’s now implement that <code>Presentation</code> model, along with the private <code>makeAlert</code> method that we call above, and our default <code>ErrorHandler</code> implementation will be complete:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">AlertErrorHandler</span> {
    <span class="s-keyword">struct</span> Presentation: <span class="s-type">Identifiable</span> {
        <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
        <span class="s-keyword">let</span> error: <span class="s-type">Error</span>
        <span class="s-keyword">let</span> retryHandler: () -&gt; <span class="s-type">Void</span>
    }
    
    <span class="s-keyword">func</span> makeAlert(for presentation: <span class="s-type">Presentation</span>) -&gt; <span class="s-type">Alert</span> {
        <span class="s-keyword">let</span> error = presentation.<span class="s-property">error</span>

        <span class="s-keyword">switch</span> error.<span class="s-call">resolveCategory</span>() {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">retryable</span>:
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(
                title: <span class="s-type">Text</span>(<span class="s-string">"An error occured"</span>),
                message: <span class="s-type">Text</span>(error.<span class="s-property">localizedDescription</span>),
                primaryButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Dismiss"</span>)),
                secondaryButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Retry"</span>),
                    action: presentation.<span class="s-property">retryHandler</span>
                )
            )
        <span class="s-keyword">case</span> .<span class="s-dotAccess">nonRetryable</span>:
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(
                title: <span class="s-type">Text</span>(<span class="s-string">"An error occured"</span>),
                message: <span class="s-type">Text</span>(error.<span class="s-property">localizedDescription</span>),
                dismissButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Dismiss"</span>))
            )
        <span class="s-keyword">case</span> .<span class="s-dotAccess">requiresLogout</span>:
            <span class="s-comment">// We don't expect this code path to be hit, since
            // we're guarding for this case above, so we'll
            // trigger an assertion failure here.</span>
            <span class="s-call">assertionFailure</span>(<span class="s-string">"Should have logged out"</span>)
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(title: <span class="s-type">Text</span>(<span class="s-string">"Logging out..."</span>))
        }
    }
}</code></pre><p>The next thing that we’ll need is a way to pass the current error handler downwards through our view hierarchy, which interestingly is the opposite direction compared to how we implemented things using the UIKit responder chain. While SwiftUI does feature APIs for upwards propagation (such as the <em>preferences system</em> that we used to implement syncing between views in <em><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2/%23geometry-preferences-and-layout-dependencies">part two of “A guide to the SwiftUI layout system”</a></em>), passing objects and information downwards is often a much better fit for SwiftUI’s highly declarative nature.</p><p>To make that happen, let’s use SwiftUI’s <em>environment system</em>, which enables us to add key objects and values to our view hierarchy’s overall environment — which any view or modifier will then be able to obtain.</p><p>Doing so involves two steps in this case. First, we’ll define an <code>EnvironmentKey</code> for storing our current error handler, and we’ll then extend the <code>EnvironmentValues</code> type with a <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">computed property</a> for accessing it — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ErrorHandlerEnvironmentKey: <span class="s-type">EnvironmentKey</span> {
    <span class="s-keyword">static var</span> defaultValue: <span class="s-type">ErrorHandler</span> = <span class="s-type">AlertErrorHandler</span>()
}

<span class="s-keyword">extension</span> <span class="s-type">EnvironmentValues</span> {
    <span class="s-keyword">var</span> errorHandler: <span class="s-type">ErrorHandler</span> {
        <span class="s-keyword">get</span> { <span class="s-keyword">self</span>[<span class="s-type">ErrorHandlerEnvironmentKey</span>.<span class="s-keyword">self</span>] }
        <span class="s-keyword">set</span> { <span class="s-keyword">self</span>[<span class="s-type">ErrorHandlerEnvironmentKey</span>.<span class="s-keyword">self</span>] = newValue }
    }
}</code></pre><p>Since we’ve made an instance of <code>AlertErrorHandler</code> our default environment value, we don’t need to explicitly inject an error handler when constructing our views — except when we’ll want to override the default handler for a subset of our hierarchy (like we did for our login screen when using UIKit). To make such overrides simpler to add, let’s create a convenience API for it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> handlingErrors(
        using handler: <span class="s-type">ErrorHandler</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">environment</span>(\.<span class="s-property">errorHandler</span>, handler)
    }
}</code></pre><p>With the above in place, we now have everything that’s needed for <em>handling errors</em>, so now let’s implement the other side of the coin — <em>emitting them</em>.</p><p>To enable any view to easily emit the user-facing errors that it encounters, let’s use SwiftUI’s <em><a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier system</a></em> to encapsulate all of the logic required to connect an error and a retry handler to the error handling system that we built above:</p><pre class="splash"><code><span class="s-keyword">struct</span> ErrorEmittingViewModifier: <span class="s-type">ViewModifier</span> {
    <span class="s-keyword">@EnvironmentObject var</span> loginStateController: <span class="s-type">LoginStateController</span>
    <span class="s-keyword">@Environment</span>(\.<span class="s-property">errorHandler</span>) <span class="s-keyword">var</span> handler

    <span class="s-keyword">var</span> error: <span class="s-type">Error</span>?
    <span class="s-keyword">var</span> retryHandler: () -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">func</span> body(content: <span class="s-type">Content</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        handler.<span class="s-call">handle</span>(error,
            in: content,
            loginStateController: loginStateController,
            retryHandler: retryHandler
        )
    }
}</code></pre><p class="info">Note how we use two different property wrappers for accessing our above environment objects. The <code>@Environment</code> wrapper enables us to read values directly from the environment itself, while the <code>@EnvironmentObject</code> one enables us to obtain an object that was passed down from a parent view.</p><p>While we <em>could</em> simply use our new view modifier directly within our views, let’s also create a convenience API for it, for example like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> emittingError(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">modifier</span>(<span class="s-type">ErrorEmittingViewModifier</span>(
            error: error,
            retryHandler: retryHandler
        ))
    }
}</code></pre><p>With the above in place, our SwiftUI-based error propagation system is now finished — so let’s take it for a spin! Even though the system itself was quite complex to build, the resulting call sites can remain very simple — since all that a view needs to do to propagate an error is to call the <code>emittingError</code> API that we just defined, and our new error propagation system will take care of the rest.</p><p>Here’s what that might look like in a rewritten SwiftUI-version of our <code>ConversationListViewController</code> from before (which now also has an accompanying <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a>):</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> error: <span class="s-type">Error</span>?
    <span class="s-keyword">@Published private(set) var</span> conversations: [<span class="s-type">Conversation</span>]
    ...
}

<span class="s-keyword">struct</span> ConversationListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ConversationListViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">conversations</span>, rowContent: makeRow)
            .<span class="s-call">emittingError</span>(viewModel.<span class="s-property">error</span>, retryHandler: {
                <span class="s-keyword">self</span>.<span class="s-property">viewModel</span>.<span class="s-call">load</span>()
            })
            .<span class="s-call">onAppear</span>(perform: viewModel.<span class="s-property">load</span>)
            ...
    }

    <span class="s-keyword">private func</span> makeRow(for conversation: <span class="s-type">Conversation</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>The final piece of the puzzle is that when we’re setting up our view hierarchy, we need to make sure to inject our <code>LoginStateController</code> into our environment (to enable it to later be retrieved by our <code>ErrorEmittingViewModifier</code>), which can be done like this:</p><pre class="splash"><code><span class="s-type">RootView</span>(...).<span class="s-call">environmentObject</span>(loginStateController)</code></pre><p class="info">We’ll take a much closer look at SwiftUI’s various environment APIs, and how they can be used for dependency injection, in future articles.</p><p>In many ways, the two implementations of our error propagation system really show just how different UIKit and SwiftUI are — as SwiftUI required us to add several new types, but also enabled us construct a fully declarative API that’s inline with the built-in APIs that SwiftUI itself ships with.</p><h2>Conclusion</h2><p>When dealing with user-facing errors, such as those encountered within our UI code, it’s typically a good idea to come up with some form of system or architecture that lets us propagate those kinds of errors to a central handling mechanism.</p><p>When using UIKit or AppKit, that could be done using the responder chain, while SwiftUI-based apps might opt to use either the environment or preferences system, or by going for some kind of unidirectional approach for both emitting errors and other events.</p><p>Either way, let’s make those simple <em>“An error occurred”</em> dialogs a thing of the past, shall we? 🙂</p><p>Got questions, comments, or feedback? Feel free to reach out either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/clips/6</guid><title>Video: Key paths and functions</title><description>Let’s take a look at how Swift’s key paths work, and how they relate to functions — both in terms of what comes built into the language itself, and what kind of utilities that we can write ourselves to form some really nice convenience APIs.</description><link>https://www.swiftbysundell.com/clips/6</link><pubDate>Fri, 8 May 2020 18:50:00 +0200</pubDate><content:encoded><![CDATA[<div class="video-player"><iframe frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="true" src="https://www.youtube-nocookie.com/embed/OJPFwSA1AbA"></iframe></div><p>Let’s take a look at how Swift’s key paths work, and how they relate to functions — both in terms of what comes built into the language itself, and what kind of utilities that we can write ourselves to form some really nice convenience APIs.</p><p>For more on Swift’s key paths feature, check out <a href="https://www.swiftbysundell.com/tags/key-paths">this category page</a>.</p><h2>Sample code</h2><p>Using key paths to extract property values from a <code>Product</code> value:</p><pre class="splash"><code><span class="s-keyword">struct</span> Product {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> kind: <span class="s-type">Kind</span>
    ...
}

<span class="s-keyword">let</span> keyPath = \<span class="s-type">Product</span>.<span class="s-property">name</span>

<span class="s-keyword">var</span> product = <span class="s-type">Product</span>(name: <span class="s-string">"iPhone 11"</span>, kind: .<span class="s-dotAccess">phone</span>)

product[keyPath: keyPath] <span class="s-comment">// iPhone 11</span>
product[keyPath: \.<span class="s-property">kind</span>] <span class="s-comment">// Product.Kind.phone</span>
product[keyPath: keyPath] = <span class="s-string">"iPhone SE"</span></code></pre><p>Passing a key path as a function when using <code>map</code> to transform an array:</p><pre class="splash"><code><span class="s-keyword">let</span> products: [<span class="s-type">Product</span>] = [...]
<span class="s-keyword">let</span> names = products.<span class="s-call">map</span> { $0.<span class="s-property">name</span> }
<span class="s-keyword">let</span> names = products.<span class="s-call">map</span>(\.<span class="s-property">name</span>)</code></pre><p>Extending the <code>Sequence</code> protocol with a key path-based convenience API for sorting:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> sorted&lt;T: <span class="s-type">Comparable</span>&gt;(
        by keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">T</span>&gt;
    ) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-call">sorted</span> { a, b <span class="s-keyword">in</span>
            a[keyPath: keyPath] &lt; b[keyPath: keyPath]
        }
    }
}</code></pre><p>How using our new <code>sorted</code> method compares to using an inline sorting closure:</p><pre class="splash"><code><span class="s-comment">// Using an inline closure:</span>
products.<span class="s-call">sorted</span>(by: { $0.<span class="s-property">name</span> &lt; $1.<span class="s-property">name</span> })

<span class="s-comment">// Using a key path:</span>
products.<span class="s-call">sorted</span>(by: \.<span class="s-property">name</span>)</code></pre><p>A <code>CanvasViewController</code> that currently uses an asynchronous completion handler closure to assign a <code>UIImage</code> to a <code>UIImageView</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController {
    <span class="s-keyword">private var</span> canvas = <span class="s-type">Canvas</span>()
    <span class="s-keyword">private lazy var</span> previewImageView = <span class="s-type">UIImageView</span>()

    ...

    <span class="s-keyword">func</span> renderPreviewImage() {
        canvas.<span class="s-call">renderAsImage</span> { [<span class="s-keyword">weak self</span>] image <span class="s-keyword">in
            self</span>?.<span class="s-property">previewImageView</span>.<span class="s-property">image</span> = image
        }
    }
}</code></pre><p>Writing a utility function that enables us to convert a reference writable key path into a setter closure:</p><pre class="splash"><code><span class="s-keyword">func</span> setter&lt;O: <span class="s-type">AnyObject</span>, V&gt;(
    for object: <span class="s-type">O</span>,
    <span class="s-keyword">_</span> keyPath: <span class="s-type">ReferenceWritableKeyPath</span>&lt;<span class="s-type">O</span>, <span class="s-type">V</span>&gt;
) -&gt; (<span class="s-type">V</span>) -&gt; <span class="s-type">Void</span> {
    { [<span class="s-keyword">weak</span> object] value <span class="s-keyword">in</span>
        object?[keyPath: keyPath] = value
    }
}</code></pre><p>Using our new utility function:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController {
    <span class="s-keyword">private var</span> canvas = <span class="s-type">Canvas</span>()
    <span class="s-keyword">private lazy var</span> previewImageView = <span class="s-type">UIImageView</span>()

    ...

    <span class="s-keyword">func</span> renderPreviewImage() {
        canvas.<span class="s-call">renderAsImage</span>(
            then: <span class="s-call">setter</span>(for: previewImageView, \.<span class="s-property">image</span>)
        )
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/72</guid><title>Podcast: “Many layers of SwiftUI”, with special guest Tobias Due Munk</title><description>Tobias Due Munk joins John to talk about using SwiftUI to build prototypes, how third party developers can extend SwiftUI’s built-in APIs in various ways, and to discuss the challenges of writing highly dynamic systems in Swift.</description><link>https://www.swiftbysundell.com/podcast/72</link><pubDate>Thu, 7 May 2020 20:45:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell72.mp3" type="audio/mpeg"/></audio><p>Tobias Due Munk joins John to talk about using SwiftUI to build prototypes, how third party developers can extend SwiftUI’s built-in APIs in various ways, and to discuss the challenges of writing highly dynamic systems in Swift.</p><h2>Sponsors</h2><ul><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li><li><strong><a href="https://bitrise.io/swift">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href="https://bitrise.io/swift">bitrise.io/swift</a>, and also check out their new podcast <a href="https://blog.bitrise.io/mobile-devops-is-a-thing-a-podcast-by-bitrise">“Mobile DevOps is a Thing!”</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/tobiasdm">Tobias on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.youtube.com/watch?v=SCOLRVVRDJk">Into the Deep</a></li><li><a href="https://www.dotconferences.com/2020/02/tobias-due-munk-prototyping-custom-ui-in-swiftui">Prototyping Custom UI in SwiftUI</a></li><li><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">A guide to the SwiftUI layout system</a></li><li><a href="https://rambo.codes/posts/2020-01-03-you-can-use-swiftui-today">Gui Rambo’s “You can use SwiftUI today” article</a></li><li><a href="https://www.swiftbysundell.com/tips/optional-swiftui-views">Unwrapping optional SwiftUI views</a></li><li><a href="https://www.swiftbysundell.com/podcast/59">Episode with Josh Shaffer from Apple</a></li><li><a href="https://developer.apple.com/documentation/swiftui/navigationview/view_modifiers">SwiftUI View Modifiers</a></li><li><a href="https://developer.apple.com/documentation/swiftui/anyview">AnyView</a></li><li><a href="https://storybook.js.org">Storybook for React</a></li><li><a href="https://duemunk.dk">Tobias’s website</a></li><li><a href="https://git.kabellmunk.dk/talks/into-the-deep">The source code for “Into the Deep”</a></li><li><a href="https://dias.app">Dias</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/three-years-of-swift-by-sundell</guid><title>Three years of Swift by Sundell</title><description></description><link>https://www.swiftbysundell.com/special/three-years-of-swift-by-sundell</link><pubDate>Tue, 5 May 2020 20:55:00 +0200</pubDate><content:encoded><![CDATA[<p>I very often get asked questions along the lines of <em>“How do you grow an audience?”</em> or <em>“How to make a website get a lot of traffic?”</em>. While I’m sure that there are a number of (more or less morally questionable) techniques that you can employ to accelerate the spread of a project — that’s never something that I’ve been particulary interested in or focused on.</p><p>Today marks exactly three years since I started Swift by Sundell, and while I’m incredibly happy with how this project has evolved and grown during those past three years, the incredible journey that this project has taken me on wasn’t something that I ever could have planned (or honestly even imagined).</p><p>When I first launched this website on the 5th of May 2017, I did it for a simple reason: <em>I wanted to write about Swift</em>. At that point, I had already been writing on Medium for a few months, and had realized just how much I enjoyed writing a short little post every week — about a technique I had grown fond of, or about a way that I had solved a commonly encountered problem. I really didn’t have any specific goals or plans for the site, other than to see for how long that I would be able to keep writing a new article every week.</p><p>Fast-forward three years, to today, the 5th of May 2020 — and I still don’t know for how many weeks that I’ll be able to keep writing, <em>because I never stopped</em>.</p><p>So if there’s one thing that I <em>can give</em> as an answer to those questions about growth and success, it’s really just that: <em>don’t stop</em>. If you want to work on something, work on it. If you want to ship an app, write the code for it. Keep doing the very best work that you possibly can, regardless of how many people that are reading, listening, or watching. Because if the work is good, people will eventually show up.</p><p>While this website is now read by over a million people each year, and serves around 50,000 page views <em>per day</em>, three years ago, it had an audience of zero — and that’s something that I will never forget.</p><p>I didn’t intend for this website to become my full-time job, but I’m really glad that it did. It’s such a pleasure to be able to share my work like this, in a way that anybody can access, anywhere around the world.</p><p>So whether this is the first time you ended up on this website, or you’re a regular reader — thank you. Thanks to all of you for reading my articles, for listening to my podcast, and for all of the amazing feedback that this wonderful community has given me over the past three years.</p><p>Happy birthday, Swift by Sundell! Let’s do another three years, shall we?</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/making-xcode-ui-tests-faster-and-more-stable</guid><title>Link: Making Xcode UI tests faster and more stable</title><description></description><link>https://blog.bitrise.io/making-xcode-ui-tests-faster-and-more-stable</link><pubDate>Tue, 5 May 2020 11:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Over the years, Xcode’s built-in UI testing system has developed somewhat of a reputation for being slow, unstable and generally hard to work with.</p><p>While it’s true that UI tests are inherently slower to run than something like unit tests (given that they actually have to run the app and interact with the UI as a user would), there are often ways to make the tests that we write much more stable — and in my latest guest post on the Bitrise blog, I share my favorite tips and techniques for doing just that.</p><p><strong><a href="https://blog.bitrise.io/making-xcode-ui-tests-faster-and-more-stable">Read the full article on the Bitrise blog</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/different-categories-of-swift-protocols</guid><title>The different categories of Swift protocols</title><description>Swift’s many protocols can, in general, be split up into four main categories. Let’s go through them, and how keeping them in mind can help us write well-formed protocols that are consistent with those found in the standard library.</description><link>https://www.swiftbysundell.com/articles/different-categories-of-swift-protocols</link><pubDate>Sun, 3 May 2020 20:25:00 +0200</pubDate><content:encoded><![CDATA[<p>In general, the primarily role of protocols (or <em>interfaces</em>) is to enable generic abstractions to be defined on top of concrete implementations — a technique which is commonly referred to as <em>polymorphism</em>, as it enables us to swap (or <em>morph</em>) our implementations without affecting their public API.</p><p>While Swift offers full support for that kind of interface-based polymorphism, protocols also play a much larger role in the overall design of the language and its standard library — as a major part of the functionality that Swift ships with is actually implemented directly on top of various protocols.</p><p>That <em>protocol-oriented design</em> also enables us to use protocols in many different ways within our own code as well — all of which can essentially be divided into four main categories. This week, let’s go through those categories, and both take a look at how Apple uses protocols within their frameworks, and how we can define our own protocols in a very similar fashion.</p><h2>Enabling unified actions</h2><p>Let’s start by taking a look at protocols that require the types that conform to them to be able to perform certain actions. For example, the standard library’s <code>Equatable</code> protocol is used to mark that a type can perform an equality check between two instances, while the <code>Hashable</code> protocol is adopted by types that can be hashed:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Equatable {
    <span class="s-keyword">static func</span> ==(lhs: <span class="s-type">Self</span>, rhs: <span class="s-type">Self</span>) -&gt; <span class="s-type">Bool</span>
}

<span class="s-keyword">protocol</span> Hashable: <span class="s-type">Equatable</span> {
    <span class="s-keyword">func</span> hash(into hasher: <span class="s-keyword">inout</span> <span class="s-type">Hasher</span>)
}</code></pre><p>A big benefit of the fact that those two capabilities are defined using the type system (rather than being hard-coded into the compiler) is that it lets us write generic code that’s <em><a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">constrained</a></em> to those protocols, which in turn enables us to make full use of those capabilities within such code.</p><p>For example, here’s how we could extend <code>Array</code> with a method that lets us count all occurrences of a value, given that the array’s <code>Element</code> type conforms to <code>Equatable</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Equatable</span> {
    <span class="s-keyword">func</span> numberOfOccurences(of value: <span class="s-type">Element</span>) -&gt; <span class="s-type">Int</span> {
        <span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { count, element <span class="s-keyword">in</span>
            <span class="s-comment">// We can check whether two values are equal here
            // since we have a guarantee that they both conform
            // to the Equatable protocol:</span>
            <span class="s-keyword">if</span> element == value {
                count += <span class="s-number">1</span>
            }
        }
    }
}</code></pre><p>In general, whenever we define action-based protocols, it’s usually a good idea to make those protocols as generic as possible (just like <code>Equatable</code> and <code>Hashable</code>), since that lets them remain focused on the actions themselves, rather than being too tied to any specific domain.</p><p>So for example, if we wanted to unify several types that load various objects or values, we could define a <code>Loadable</code> protocol with an <em>associated type</em> — which would let each conforming type declare what sort of <code>Result</code> that it loads:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Loadable {
    <span class="s-keyword">associatedtype</span> Result
    <span class="s-keyword">func</span> load() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Result</span>
}</code></pre><p>However, not every protocol defines actions (after all, this is just the first category out of four). For example, while the name of the following <code>Cachable</code> protocol might suggest that it contains actions for caching, it’s actually just used to enable various types to define their own caching keys:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Cachable: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> cacheKey: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Compare the above to the built-in <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a> protocol that <code>Cachable</code> <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift/%23inheritance">inherits from</a>, which <em>does</em> define actions for both encoding and decoding — and it starts to become clear that we’ve ended up with a bit of a naming mismatch.</p><p>After all, not all protocols need to use the <em>able</em> suffix. In fact, forcing that suffix onto any given noun just to define a protocol for it can lead to quite a lot of confusion — like in this case:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Titleable {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">What does <em>“Titleable”</em> even mean?</p><p>What’s perhaps even more confusing is when using the <em>”able”</em> suffix results in a name with a completely different meaning than what we intended. For example, here we’ve defined a protocol <em>with the intention</em> of having it act as an API for color containers, but its name suggests that it’s for types that themselves can be colored:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Colorable {
    <span class="s-keyword">var</span> foregroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> backgroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
}</code></pre><p>So how could we improve some of the these protocols — both in terms of their naming, as well as how they’re structured? Let’s start by stepping out of category number one, and explore a few different ways of defining protocols in Swift.</p><h2>Defining requirements</h2><p>Category number two is for protocols that are used to define formal requirements for a given kind of object or API. Within the standard library, such protocols are used to define what <em>it means to be</em> things like a <code>Collection</code>, a <code>Numeric</code>, or a <code>Sequence</code>:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Sequence {
    <span class="s-keyword">associatedtype</span> Iterator: <span class="s-type">IteratorProtocol</span>
    <span class="s-keyword">func</span> makeIterator() -&gt; <span class="s-type">Iterator</span>
}</code></pre><p class="info">Note that the above protocol is not called <code>Sequencable</code>, since that would indicate that it’s about <em>turning objects into</em> sequences, rather than defining the requirements for <em>being one</em>.</p><p>What the above definition of <code>Sequence</code> tells us is that the primary role of any Swift sequence (such as an <code>Array</code>, a <code>Dictionary</code>, or something like a <code>Range</code>) is to act as a <em><a href="https://www.swiftbysundell.com/articles/using-the-factory-pattern-to-avoid-shared-state-in-swift">factory</a></em> for creating iterators — which in turn are formalized through the following protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> IteratorProtocol {
    <span class="s-keyword">associatedtype</span> Element
    <span class="s-keyword">mutating func</span> next() -&gt; <span class="s-type">Element</span>?
}</code></pre><p class="info">The above protocol could arguably have been called <code>Iterable</code> instead, since iterators do actually perform each iteration action themselves. However, the name <code>IteratorProtocol</code> was likely picked to make it feel more consistent with <code>Sequence</code>, since simply naming it <code>Iterator</code> would’ve caused conflicts with the associated type of the same name.</p><p>With the above two protocols in mind, let’s now go back to the <code>Cachable</code> and <code>Colorable</code> protocols that we defined earlier, to see if they can be improved by transforming them into requirement definitions instead.</p><p>Let’s start by renaming <code>Colorable</code> into <code>ColorProvider</code>, which gives that protocol a whole new meaning — even if its requirements remain exactly the same. It no longer sounds like it’s used to define objects that can be colored, but rather that it’s about <em>providing</em> color information to some other part of our system — which is exactly what we intended:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ColorProvider {
    <span class="s-keyword">var</span> foregroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> backgroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Similarly, taking inspiration from the built-in <code>IteratorProtocol</code>, we could rename <code>Cachable</code> into something like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CachingProtocol: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> cacheKey: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>However, an arguably even better approach in this case would be to decouple the concept of generating caching keys from the types that are actually being cached — which would let us keep our model code free from caching-specific properties.</p><p>One way to do that would be to move our key generation code into separate types — which we could then formalize the requirements for using a <code>CacheKeyGenerator</code> protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CacheKeyGenerator {
    <span class="s-keyword">associatedtype</span> Value: <span class="s-type">Codable</span>
    <span class="s-keyword">func</span> cacheKey(for value: <span class="s-type">Value</span>) -&gt; <span class="s-type">String</span>
}</code></pre><p>Another option would be to model the above as <a href="https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift/%23single-requirements-using-closures">a closure instead</a>, which is often a great alternative to protocols that just contain a single requirement.</p><h2>Type conversions</h2><p>Next, let’s take a look at protocols that are used to declare that a type is <em>convertible</em> to and from other values. We’ll again start with an example from the standard library — <code>CustomStringConvertible</code>, which can be used to enable any type to be converted into a custom description string:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CustomStringConvertible {
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">Compare the above to what it could’ve looked like if it was called <code>Describable</code> instead. If so, the expectation would probably have been that it contains a <code>describe()</code> method, or something similar.</p><p>That kind of design is particularly useful when we want to be able to extract a single piece of data from multiple types — which perfectly matches the purpose of our (somewhat strangely named) <code>Titleable</code> protocol from earlier.</p><p>By renaming that protocol to <code>TitleConvertible</code> instead, we not only make it easier to understand what that protocol is for, we also make our code more consistent with the standard library — which is most often a good thing:</p><pre class="splash"><code><span class="s-keyword">protocol</span> TitleConvertible {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Type conversion protocols can also use methods, rather than properties, which is typically <a href="https://www.swiftbysundell.com/tips/computed-properties-vs-methods">a better fit</a> when we expect certain implementations to require a fair amount of computation — for example when working with image conversions:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ImageConvertible {
    <span class="s-comment">// Since rendering an image can be a somewhat expensive
    // operation (depending on the type being rendered), we're
    // defining our protocol requirement as a method, rather
    // than as a property:</span>
    <span class="s-keyword">func</span> makeImage() -&gt; <span class="s-type">UIImage</span>
}</code></pre><p>We can also use this category of protocols to enable certain types to be <em>expressed</em> in different ways — a technique which is, among other things, used to implement all of Swift’s built-in support for literals — such as string and array literals. Even <code>nil</code> assignments are implemented through a protocol, which is quite cool:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ExpressibleByArrayLiteral {
    <span class="s-keyword">associatedtype</span> ArrayLiteralElement
    <span class="s-keyword">init</span>(arrayLiteral elements: <span class="s-type">ArrayLiteralElement</span>...)
}

<span class="s-keyword">protocol</span> ExpressibleByNilLiteral {
    <span class="s-keyword">init</span>(nilLiteral: ())
}</code></pre><p class="info">Note that while we’re free to conform to most built-in literal protocols within our own code as well, conforming to <code>ExpressibleByNilLiteral</code> is discouraged — as <code>Optional</code> is expected to be the only type adopting that protocol.</p><p>While it’s perhaps not that common to define our own protocols for bridging literals into an instances of a type (since that does, in fact, require changes to the compiler), we can use that same design whenever we want to declare a protocol for <em>expressing</em> a type using a lower-level representation.</p><p>For example, here’s how we could define an <code>ExpressibleByUUID</code> protocol for identifier types that can be created using a raw <code>UUID</code>:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ExpressibleByUUID {
    <span class="s-keyword">init</span>(uuid: <span class="s-type">UUID</span>)
}</code></pre><p>Another option would be to use the <code>RawRepresentable</code> protocol, which is what powers <a href="https://www.swiftbysundell.com/basics/enums">enums</a> that have raw values. However, while that protocol is definitely also a type converting one, its initializer is <em>failable</em> — which means that it’s really only useful for conditional conversions that could potentially result in <code>nil</code>.</p><h2>Abstract interfaces</h2><p>Finally, let’s take a look at perhaps the most common way of using protocols within third party code — to define abstractions for interfacing with multiple underlying types.</p><p>An interesting example of this pattern can be found within Apple’s Metal framework, which is a low-level graphics programming API. Since GPUs tend to vary a lot between devices, and Metal aims to provide a unified API for programming against any type of hardware that it supports, it uses a protocol to define its API as an abstract interface — which looks like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> MTLDevice: <span class="s-type">NSObjectProtocol</span> {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> registryID: <span class="s-type">UInt64</span> { <span class="s-keyword">get</span> }
    ...
}</code></pre><p>When using Metal, we can then call the <code>MTLCreateSystemDefaultDevice</code> function, and the system will return an implementation of the above protocol that’s appropriate for the device that our program is currently running on:</p><pre class="splash"><code><span class="s-keyword">func</span> MTLCreateSystemDefaultDevice() -&gt; <span class="s-type">MTLDevice</span>?</code></pre><p>Within our own code, we can also use that exact same pattern whenever we want to support multiple implementations of the same interface. For example, we might define a <code>NetworkEngine</code> protocol in order to decouple the way we perform our network calls from any specific means of networking:</p><pre class="splash"><code><span class="s-keyword">protocol</span> NetworkEngine {
    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    )
}</code></pre><p>With the above in place, we’re now free to define as many underlying networking implementations as we need — for example a <code>URLSession</code>-based one for production, and a mocked version for testing:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">URLSession</span>: <span class="s-type">NetworkEngine</span> {
    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        ...
    }
}

<span class="s-keyword">struct</span> MockNetworkEngine: <span class="s-type">NetworkEngine</span> {
    <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;

    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-call">handler</span>(result)
    }
}</code></pre><p class="info">To learn more about mocking within unit tests, check out <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">“Mocking in Swift”</a>.</p><p>The above technique can also be a great way to <a href="https://www.swiftbysundell.com/articles/code-encapsulation-in-swift">encapsulate third party dependencies</a> in order to prevent them from spreading across our entire code base — which in turn makes it much easier to replace or remove those dependencies in the future.</p><h2>Conclusion</h2><p>Swift’s implementation of protocols is definitely one of the most interesting aspects of the language, and the sheer number of ways that they can be defined and used really shows just how powerful they are — especially once we start making full use of features like associated types and protocol extensions.</p><p>Because of that, it’s important to not treat every protocol the same way, but to rather design them according to which category that they belong to. To recap, these are the four categories that I like to split protocols up into:</p><ul><li><strong>Action enablers</strong>, which enable us to perform a given set of actions on each conforming type. They typically have names that end with <em>“able”</em>, such as <code>Equatable</code>.</li><li><strong>Requirement definitions</strong> enable us to formalize the requirements for being a certain kind of object, for example a <code>Sequence</code>, a <code>Numeric</code>, or a <code>ColorProvider</code>.</li><li><strong>Type conversion</strong> protocols are used to let various types declare that they can be convertible into another type, or expressible through a raw value or literal — like <code>CustomStringConvertible</code> or <code>ExpressibleByStringLiteral</code>.</li><li><strong>Abstract interfaces</strong> act as unified APIs that multiple types can implement, which in turn lets us swap out implementations as we wish, encapsulate third party code, or mock certain objects within our tests.</li></ul><p>What do you think? Do you agree with my way of splitting Swift’s various protocols up into those four categories, or do you organize your protocols some other way? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/inferred-generic-type-constraints</guid><title>Tip: Inferred generic type constraints</title><description></description><link>https://www.swiftbysundell.com/tips/inferred-generic-type-constraints</link><pubDate>Fri, 1 May 2020 18:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Generic type constraints can be used to impose a set of requirements on the concrete types that a given API will be used with, which in turn enables us make certain assumptions about those types within our generic code.</p><p>For example, let’s say that an app that we’re working on is using a <code>NetworkRequest</code> protocol to enable us to define our various requests as different types that each declare what kind of <code>Response</code> that they expect:</p><pre class="splash"><code><span class="s-keyword">protocol</span> NetworkRequest {
    <span class="s-keyword">associatedtype</span> Response: <span class="s-type">Codable</span>

    <span class="s-keyword">func</span> makeURLRequest() -&gt; <span class="s-type">URLRequest</span>
}</code></pre><p>If we now define an API for performing such a request, we might end up with something like the following — a function that uses a generic type constraint to ensure that its <code>T</code> type does in fact conform to our above protocol:</p><pre class="splash"><code><span class="s-keyword">func</span> perform<span class="highlight">&lt;T: <span class="s-type">NetworkRequest</span>&gt;</span>(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>Now let’s say that we also want to add support for enqueuing requests using a <code>NetworkRequestQueue</code> class — that also uses a generic type constrained to our <code>NetworkRequest</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> NetworkRequestQueue&lt;Request: <span class="s-type">NetworkRequest</span>&gt; {
    ...
}</code></pre><p>When it comes to adding a parameter for injecting an instance of the above class into our <code>perform</code> function, we might initially simply add it to our list of parameters — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform&lt;T: <span class="s-type">NetworkRequest</span>&gt;(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>However, since our <code>NetworkRequestQueue</code> class already requires its generic <code>Request</code> type to conform to our <code>NetworkRequest</code> protocol — and since the compiler knows that the type used to specialize that class will be the same as the one used for our <code>request</code> parameter — we can actually omit that type constraint from our <code>perform</code> function entirely, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform<span class="highlight">&lt;T&gt;</span>(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>The above might seem like a small detail, and perhaps it is in the grand scheme of things — but since generic code tends to become quite verbose, especially when using type constraints, anything we can do to reduce that sort of verbosity is arguably a good thing.</p><p>As an added bonus, let’s also make the above <code>handler</code> parameter’s closure type a bit simpler as well — by first turning it into a type alias within an extension on our <code>NetworkRequest</code> protocol:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkRequest</span> {
    <span class="s-keyword">typealias</span> ResponseHandler = (<span class="s-type">Result</span>&lt;<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
}</code></pre><p>With the above in place, we can now make our <code>perform</code> function’s signature even nicer to read — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform&lt;T&gt;(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> <span class="s-type">T</span>.<span class="s-type">ResponseHandler</span>
) {
    ...
}</code></pre><p>Swift’s syntax might initially seem quite verbose when it comes to defining generic types and functions, but there are often certain tricks and techniques that we can use to make such definitions much more compact — without sacrificing any readability.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/bitrise-april-2020</guid><title>Sponsor: Bitrise</title><description>Thanks a lot to Bitrise for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/bitrise-april-2020</link><pubDate>Thu, 30 Apr 2020 16:20:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://go.bitrise.io/swift">Bitrise</a> for supporting Swift by Sundell with another two-week sponsorship. I’ve been using Bitrise since long before they became a sponsor, and their continued support also plays a big part in helping me keep Swift by Sundell free and open to everyone.</p><p>Bitrise is Continuous Integration and Delivery that <em>just works</em>. It lets you automate all sorts of tasks — from building and distributing an app, to running tests, code style checks and other types of static analysis. It’s fast, stable, always updated with the latest versions of Swift and Xcode, and is super easy to use.</p><p>Before I was using Bitrise, adding continuous integration (or CI) to a project was always a bit of a chore — since it required fiddling around with poorly documented configuration files, manually updating things for every new Xcode release, and constantly debugging sources of flakiness and instability.</p><p>Now, whenever I start a new project, I simply log into my Bitrise account, click a few buttons in their web UI — and my new project has a fully capable CI pipeline up and running. It really is <em>that easy</em>, no matter whether I’m building an app, a framework, or just a simple Swift package — Bitrise builds my project and runs all of my tests on every single commit that I make, which helps me ensure that my projects remain fully working on all of the platforms that they support.</p><p>I really recommend that you try out Bitrise — it’s <em>completely free</em> to get started, and their free tier is now more capable than ever. Using <a href="https://go.bitrise.io/swift">this link</a> to check out Bitrise also helps support Swift by Sundell, which in turn helps me keep the site and the podcast up and running.</p><p><a href="https://go.bitrise.io/swift">Try Bitrise for free and support Swift by Sundell</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/clips/5</guid><title>Video: Controllers in MVC</title><description>Let’s take a look at the role that controllers play within the MVC design pattern, and how we can avoid some of the most common issues when working with them — particularly around how we can break up Massive View Controllers into smaller building blocks.</description><link>https://www.swiftbysundell.com/clips/5</link><pubDate>Tue, 28 Apr 2020 18:05:00 +0200</pubDate><content:encoded><![CDATA[<div class="video-player"><iframe frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="true" src="https://www.youtube-nocookie.com/embed/Ni70aTksJWg"></iframe></div><p>Let’s take a look at the role that controllers play within the MVC design pattern, and how we can avoid some of the most common issues when working with them — particularly around how we can break up <em>Massive View Controllers</em> into smaller building blocks.</p><h2>Links</h2><ul><li><a href="https://www.swiftbysundell.com/basics/child-view-controllers">Child view controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/logic-controllers-in-swift">Logic controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">Model controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">View models</a></li></ul><h2>Sample code</h2><p>An example of a view controller that constructs its header view inline within its <code>loadView</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerView = <span class="s-type">UIView</span>()
        ...
        view.<span class="s-call">addSubview</span>(headerView)
    }
}</code></pre><p>Moving that header view implementation to a new view controller instead:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        ...
    }
}</code></pre><p>Embedding our new <code>HeaderViewController</code> as a <a href="https://www.swiftbysundell.com/basics/child-view-controllers">child view controller</a>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerVC = <span class="s-type">HeaderViewController</span>()
        view.<span class="s-call">addSubview</span>(headerVC.<span class="s-property">view</span>)
        <span class="s-call">addChild</span>(headerVC)
        headerVC.<span class="s-call">didMove</span>(toParent: <span class="s-keyword">self</span>)
        ...
    }
}</code></pre><p>Extending <code>UIViewController</code> with an API to make it easier to add child view controllers:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">func</span> add(<span class="s-keyword">_</span> child: <span class="s-type">UIViewController</span>) {
        <span class="s-call">addChild</span>(child)
        view.<span class="s-call">addSubview</span>(child.<span class="s-property">view</span>)
        child.<span class="s-call">didMove</span>(toParent: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">You can also find a <code>remove</code> equivalent to the above API within the <a href="https://www.swiftbysundell.com/basics/child-view-controllers/">Basics article about child view controllers</a>.</p><p>An example of a view controller method that doesn’t really have much to do with controlling a view:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> userID: <span class="s-type">User</span>.<span class="s-type">ID</span>
    <span class="s-keyword">private let</span> networking: <span class="s-type">NetworkManager</span>
    ...

    <span class="s-keyword">private func</span> loadUser() {
        <span class="s-keyword">let</span> endpoint = <span class="s-type">Endpoint</span>.<span class="s-call">user</span>(id: userID)

        networking.<span class="s-call">request</span>(endpoint) { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(user)
            } <span class="s-keyword">catch</span> {
                <span class="s-keyword">self</span>?.<span class="s-call">showErrorView</span>(for: error)
            }
        }
    }

    ...
}</code></pre><p>Implementing a generic <code>ViewState</code> enum that we can use to model any view controller’s high-level rendering state:</p><pre class="splash"><code><span class="s-keyword">enum</span> ViewState&lt;Model&gt; {
    <span class="s-keyword">case</span> loading
    <span class="s-keyword">case</span> presenting(<span class="s-type">Model</span>)
    <span class="s-keyword">case</span> failed(<span class="s-type">Error</span>)
}</code></pre><p>Implementing a <a href="https://www.swiftbysundell.com/articles/logic-controllers-in-swift">logic controller</a> companion for our <code>ProfileViewController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileLogicController {
    <span class="s-keyword">private let</span> userID: <span class="s-type">User</span>.<span class="s-type">ID</span>
    <span class="s-keyword">private let</span> networking: <span class="s-type">NetworkManager</span>

    ...

    <span class="s-keyword">func</span> loadCurrentState(then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">ViewState</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">let</span> endpoint = <span class="s-type">Endpoint</span>.<span class="s-call">user</span>(id: userID)

        networking.<span class="s-call">request</span>(endpoint) { result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-call">handler</span>(.<span class="s-call">presenting</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failed</span>(error))
            }
        }
    }
}</code></pre><p>Using our new logic controller within our view controller:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> logic: <span class="s-type">ProfileLogicController</span>

    ...

    <span class="s-keyword">override func</span> viewWillAppear(<span class="s-keyword">_</span> animated: <span class="s-type">Bool</span>) {
        <span class="s-keyword">super</span>.<span class="s-call">viewWillAppear</span>(animated)

        logic.<span class="s-call">loadCurrentState</span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }
    
    <span class="s-keyword">private func</span> userDidPickNewProfileImage(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>) {
        logic.<span class="s-call">handleNewProfileImage</span>(image) { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }
}</code></pre><p>An example of a model that’s currently managed as a singleton:</p><pre class="splash"><code><span class="s-keyword">struct</span> Player {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> score: <span class="s-type">Int</span>
    <span class="s-keyword">var</span> challenges: [<span class="s-type">Challenge</span>]
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Player</span> {
    <span class="s-keyword">static var</span> current: <span class="s-type">Player</span>?
}</code></pre><p>Using a model controller to manage our model instead:</p><pre class="splash"><code><span class="s-keyword">class</span> PlayerModelController {
    <span class="s-keyword">private(set) var</span> model: <span class="s-type">Player</span>

    <span class="s-keyword">init</span>(model: <span class="s-type">Player</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">model</span> = model
    }
    
    <span class="s-keyword">func</span> levelCompleted(<span class="s-keyword">_</span> level: <span class="s-type">Level</span>) {
        <span class="s-keyword">var</span> levelScore = level.<span class="s-property">enemiesDefeated</span> * <span class="s-number">100</span>
        levelScore += level.<span class="s-property">obstaclesAvoided</span> * <span class="s-number">50</span>
        levelScore *= level.<span class="s-property">difficulty</span>.<span class="s-property">scoreMultiplier</span>

        model.<span class="s-property">score</span> += levelScore
    }
    
    <span class="s-keyword">func</span> observe(using closure: <span class="s-keyword">@escaping</span> (<span class="s-type">Player</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Cancellable</span> {
        ...
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/querying-collections-in-swift</guid><title>Querying collections in Swift</title><description>This week, let’s explore how we can make use of the standard library’s built-in algorithms when performing various types of queries against collections of values.</description><link>https://www.swiftbysundell.com/articles/querying-collections-in-swift</link><pubDate>Sun, 26 Apr 2020 19:40:00 +0200</pubDate><content:encoded><![CDATA[<p>When working with collections, such as arrays or dictionaries, it’s very common to want to query them for information about the values that they contain. We might need to find the first element that matches a given set of criteria, validate all values according to a set of requirements, and so on.</p><p>In situations like these, it might initially seem like we always need to write purpose-built algorithms that perform each query using a classic <code>for</code> or <code>while</code> loop, and while that’s certainly a fine approach in some cases, it often turns out that writing such manual iterations can be quite unnecessary.</p><p>This week, let’s explore why that is — by taking a look at some of the Swift standard library’s built-in algorithms for querying collections, and how we can compose and combine them to form a nearly infinite number of different queries.</p><h2>Searching for a match</h2><p>Let’s start by taking a look at a very common type of situation, in which we want to query a collection in order to find the first element that matches a given predicate.</p><p>As an example, let’s say that we’re working on a movie recommendation app, and that when the user taps a button for showing the next movie within a given genre, we search a <code>movieQueue</code> array and display the first match — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">var</span> match: <span class="s-type">Movie</span>?

    <span class="s-keyword">for</span> movie <span class="s-keyword">in</span> movieQueue {
        <span class="s-keyword">if</span> movie.<span class="s-property">genre</span> == genre {
            <span class="s-comment">// We've found our match, so we'll break the iteration</span>
            match = movie
            <span class="s-keyword">break</span>
        }
    }

    <span class="s-keyword">guard let</span> movie = match <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-call">showNoMovieFoundView</span>()
    }

    <span class="s-call">showMovieView</span>(for: movie)
}</code></pre><p>While the above code works, it could definitely be implemented in a more compact way, which in this case should also improve its readability.</p><p>For starters, let’s get rid of that local <code>match</code> variable, by moving our <code>for</code> loop into its own, dedicated function. Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/pure-functions-in-swift">“Pure functions in Swift”</a></em>, structuring logic as functions that simply operate on an input/output basis can often improve our code — both in terms of how easy it is to read, as well as how testable our overall system becomes.</p><p>While our new function won’t be entirely <em>“pure”</em> (since it’ll still rely on the state of our <code>movieQueue</code> array), it’ll now simply return the first matching <code>Movie</code> that was found, rather than assigning it to a local variable:</p><pre class="splash"><code><span class="s-keyword">func</span> nextMovie(inGenre genre: <span class="s-type">Genre</span>) -&gt; <span class="s-type">Movie</span>? {
    <span class="s-keyword">for</span> movie <span class="s-keyword">in</span> movieQueue {
        <span class="s-keyword">if</span> movie.<span class="s-property">genre</span> == genre {
            <span class="s-keyword">return</span> movie
        }
    }

    <span class="s-keyword">return nil</span>
}</code></pre><p>With the above in place, we can now heavily simplify our <code>showNextMovie</code> function from before — as it now only needs to contain the logic that determines which view that should be shown for the current state of the app:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">guard let</span> movie = <span class="s-call">nextMovie</span>(inGenre: genre) <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-call">showNoMovieFoundView</span>()
    }

    <span class="s-call">showMovieView</span>(for: movie)
}</code></pre><p>However, using the power of the Swift standard library, we can simplify our code even further. If we take a closer look at our <code>nextMovie</code> function and the <code>for</code> loop that it contains, there’s really nothing about it that’s specific to movies — it simply iterates over an array and returns the first element that matches a given predicate.</p><p>To slightly twist the classic App Store slogan: <em>“There’s a collection API for that”</em>. In this case, we can simply replace our custom <code>nextMovie</code> function with a call to the built-in <code>first(where:)</code> method, which lets us pass a predicate to match against. Combine that with the <a href="https://www.swiftbysundell.com/basics/optionals"><code>Optional</code></a> type’s <code>map</code> method — and we can implement our entire <code>showNextMovie</code> function like this instead:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">let</span> movie = movieQueue.<span class="s-call">first</span>(where: { $0.<span class="s-property">genre</span> == genre })
    movie.<span class="s-call">map</span>(showMovieView) ?? <span class="s-call">showNoMovieFoundView</span>()
}</code></pre><p>Just like that, we’ve essentially boiled down a 10+ line algorithm to just two lines of code, by leveraging the standard library’s built-in APIs and algorithms. Pretty nice!</p><p class="info">There’s also a <code>last(where:)</code> equivalent to the API used above, as well as <code>firstIndex(where:)</code> and <code>lastIndex(where:)</code> variants that return indexes rather than elements. However, the “last” variants are only available on collections that conform to the <code>BidirectionalCollection</code> protocol, such as <code>Array</code>.</p><h2>Verifying requirements</h2><p>Not all collection queries are about retrieving an element, though — sometimes we might just want to verify that a series of values meet a certain requirement.</p><p>For example, let’s now say that we’re working on an app for scheduling and managing events, and that the app includes a feature that lets each participant mark whether they’re ready for the event to begin. We’ve then extended our app’s <code>Event</code> model with a method that lets us easily check whether all participants have marked themselves as ready — which currently looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> isReadyToBegin() -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">for</span> participant <span class="s-keyword">in</span> participants {
            <span class="s-keyword">guard</span> participant.<span class="s-property">isReady</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
        }

        <span class="s-keyword">return true</span>
    }
}</code></pre><p class="info">The reason the above API was implemented as a method, and not a computed property, is because its <a href="https://www.swiftbysundell.com/basics/time-complexity">time complexity</a> isn’t <code>O(1)</code>. To learn more about that philosophy, check out <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">“Computed properties in Swift”</a>.</p><p>However, just like before, there’s a much easier way to implement the above — this time by leveraging the standard library’s <code>allSatisfy</code> API, which (like the name implies) enables us to check whether all of a collection’s element satisfy a given predicate. Combine that with the fact that <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> can now be <a href="https://www.swiftbysundell.com/tips/passing-key-paths-as-functions">passed as functions</a>, and we can replace our entire implementation with just a single line of code — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> isReadyToBegin() -&gt; <span class="s-type">Bool</span> {
        participants.<span class="s-call">allSatisfy</span>(\.<span class="s-property">isReady</span>)
    }
}</code></pre><p>With that change in place, the question is whether we still need to keep the above method at all, given that it now simply contains a call to another API. If we’re only looking to use it in a single place, we might as well just inline the call to <code>allSatisfy</code> directly at the call site — however, our above method does add some additional context, as its name makes it crystal clear that we’re checking whether an event is ready to begin, so it still might make sense to keep it.</p><h2>Minimum and maximum values</h2><p>Next, let’s take a look at another common type of query — computing minimum and maximum values from a series of elements. This time, let’s say that we’re building a game, and that we’d like to add a convenience API for computing the maximum score among an array of players for a given level. If we again start with a manually implemented algorithm, we might write something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Level</span> {
    <span class="s-keyword">func</span> maximumPlayerScore() -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">var</span> maximumScore = <span class="s-number">0</span>

        <span class="s-keyword">for</span> player <span class="s-keyword">in</span> players {
            maximumScore = <span class="s-call">max</span>(maximumScore, player.<span class="s-property">score</span>)
        }

        <span class="s-keyword">return</span> maximumScore
    }
}</code></pre><p>While the <code>max</code> function that we use above is (along with its <code>min</code> equivalent) incredibly common and can be found in a wide range of programming languages, Swift also includes a variant of it that can be called directly on a collection. All that we have to do to use it is to pass a closure that sorts the collection’s elements in <em>ascending order</em> — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Level</span> {
    <span class="s-keyword">func</span> maximumPlayerScore() -&gt; <span class="s-type">Int</span> {
        <span class="s-comment">// Note that we need to sort the collection in ascending
        // order, which is why we use &lt; to perform our comparsion:</span>
        <span class="s-keyword">let</span> winningPlayer = players.<span class="s-call">max</span> { $0.<span class="s-property">score</span> &lt; $1.<span class="s-property">score</span> }
        <span class="s-keyword">return</span> winningPlayer?.<span class="s-property">score</span> ?? <span class="s-number">0</span>
    }
}</code></pre><p>An alternative approach to the above would be to first sort the <code>players</code> array by each player’s <code>score</code> property, and then simply pick the first element. However, doing so would be worse in terms of time complexity, since <code>min</code> and <code>max</code> can both be executed in pure linear (<code>O(n)</code>) time, while <code>sort</code> has a time complexity of <code>O(n log n)</code>.</p><h2>Composing custom algorithms</h2><p>So far in this article, we’ve mainly focused on <em>replacing</em> custom collection algorithms with standard library API calls, and while it’s certainly beneficial to do so whenever possible, that’s not always the case.</p><p>Let’s go back to our <code>Event</code> model from before, and take a look at another API that’s also implemented as a collection query. This one checks whether a set of users are all present within an current event’s list of participants, and currently looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> participantsContain(<span class="s-keyword">_</span> users: <span class="s-type">Set</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">for</span> user <span class="s-keyword">in</span> users {
            <span class="s-keyword">guard</span> participants.<span class="s-call">contains</span>(where: { $0.<span class="s-property">userID</span> == user.<span class="s-property">id</span> }) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
        }

        <span class="s-keyword">return true</span>
    }
}</code></pre><p>While in this case there’s no equivalent standard library API that we can simply replace the above code with, there’s still a way in which we could improve it.</p><p>The beauty of the algorithms that come built-in as part of the standard library is that they’re all very focused and narrow — which in turn means that they can often be composed in order to form higher-level logic. So we don’t need to necessarily find a single API that matches an algorithm as a whole, we simply need to find one match for each of its components.</p><p>Looking at our above algorithm, we’re already using the <code>contains(where:)</code> API to form our inner loop, while our outer iteration still uses a classic <code>for</code> loop. However, if we take a closer look, it turns out that the outer loop has the exact same shape as the one that we initially used within our <code>isReadyToBegin</code> method from before — in that it checks that all elements within the passed set of users satisfy a given requirement.</p><p>While we could now go back to our <code>participantsContain</code> method and refactor our code right there, let’s in this case implement our logic as a generic algorithm instead — by composing <code>allSatsify</code> and <code>contains(where:)</code> into a new method for the <code>Sequence</code> protocol (which all collections and other sequences conform to):</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> contains&lt;T: <span class="s-type">Sequence</span>&gt;(
        <span class="s-keyword">_</span> values: <span class="s-type">T</span>,
        matchedBy matcher: (<span class="s-type">Element</span>, <span class="s-type">T</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Bool</span>
    ) -&gt; <span class="s-type">Bool</span> {
        values.<span class="s-call">allSatisfy</span> { value <span class="s-keyword">in</span>
            <span class="s-call">contains</span>(where: { <span class="s-call">matcher</span>($0, value) })
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>Event</code> type and simply make its <code>participantsContain</code> method call our new API by passing its predicate as a closure — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> participantsContain(<span class="s-keyword">_</span> users: <span class="s-type">Set</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Bool</span> {
        participants.<span class="s-call">contains</span>(users, matchedBy: {
            $0.<span class="s-property">userID</span> == $1.<span class="s-property">id</span>
        })
    }
}</code></pre><p>Choosing whether to implement a piece of logic as either a generic algorithm or something that’s specifically written for a given use case can occasionally be quite difficult. However, a rule of thumb to keep in mind is that whenever our logic is simply a composition of other generic algorithms — it probably makes sense for that new algorithm to be generic too.</p><h2>Conclusion</h2><p>The Swift standard library contains a number of incredibly useful algorithms, functions and other APIs — and making full use of them not only reduces the amount of code that we need to maintain ourselves, it also lets us build our logic on top of shared code that’s well-tested and deployed within every single Swift program on the planet.</p><p>There are of course many more Collection APIs than those that were highlighted in this article, so I both recommend checking out the articles covering <a href="https://www.swiftbysundell.com/articles/slicing-swift-collections">slicing</a> and <a href="https://www.swiftbysundell.com/articles/transforming-collections-in-swift">transformations</a> if you haven’t done so already, and to explore the <a href="https://developer.apple.com/documentation/swift/sequence"><code>Sequence</code></a> and <a href="https://developer.apple.com/documentation/swift/collection"><code>Collection</code></a> protocols yourself — chances are high that you’ll find at least one way that one of your algorithms could be simplified.</p><p>Got questions, comments or feedback? You’re always more than welcome to contact me, either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/71</guid><title>Podcast: “Polymorphic interfaces”, with special guest Dave Abrahams</title><description>Dave Abrahams joins John to talk about Protocol-Oriented Programming and how to make the most out of the Swift Standard Library. Also, discussions on Swift’s overall design, why it puts such a strong emphasis on value types and protocols, and how it’s been influenced by other languages.</description><link>https://www.swiftbysundell.com/podcast/71</link><pubDate>Thu, 23 Apr 2020 20:57:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell71.mp3" type="audio/mpeg"/></audio><p>Dave Abrahams joins John to talk about Protocol-Oriented Programming and how to make the most out of the Swift Standard Library. Also, discussions on Swift’s overall design, why it puts such a strong emphasis on value types and protocols, and how it’s been influenced by other languages.</p><h2>Sponsor</h2><p><strong><a href="https://nordvpn.com/sundell">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on. Get 50% off their one-year plan at <a href="https://nordvpn.com/sundell">nordvpn.com/sundell</a>, or when using offer code <em>SUNDELL</em>.</p><p><em>Interested in advertising on Swift by Sundell? Check out <a href="https://www.swiftbysundell.com/sponsor">this page</a>, or <a href="mailto:sponsor@swiftbysundell.com">get in touch</a> for more information.</em></p><h2>Links</h2><ul><li><a href="https://twitter.com/DaveAbrahams">Dave on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/408">Protocol-Oriented Programming in Swift</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/223">Embracing Algorithms</a></li><li><a href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a></li><li><a href="https://en.wikipedia.org/wiki/Standard_Template_Library">The C++ Standard Template Library</a></li><li><a href="https://www.boost.org">Boost</a></li><li><a href="https://www.swiftbysundell.com/tips/enums-with-custom-raw-types">Enums with custom raw types</a></li><li><a href="https://www.swiftbysundell.com/podcast/58">Previous Swift for TensorFlow episode with Paige Bailey and Brennan Saeta</a></li><li><a href="https://twitter.com/SeanParent">Sean Parent</a></li><li><a href="https://www.haskell.org/tutorial/classes.html">Haskell Type Classes</a></li><li><a href="https://developer.apple.com/documentation/swift/anycollection">AnyCollection</a></li><li><a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">Specializing protocols</a></li><li><a href="https://www.swiftbysundell.com/articles/type-erasure-using-closures-in-swift">Type erasure using closures</a></li><li><a href="https://www.swiftbysundell.com/basics/codable">Codable</a></li><li><a href="https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">“The Genuine Sieve of Eratosthenes” by Melissa E. O’Neill</a></li><li><a href="https://docs.google.com/document/d/1Fm56p5rV1t2Euh6WLtBFKGqI43ozC3EIjReyLk-LCLU">Swift for TensorFlow open design meetings</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/enums-with-custom-raw-types</guid><title>Tip: Enums with custom raw types</title><description></description><link>https://www.swiftbysundell.com/tips/enums-with-custom-raw-types</link><pubDate>Wed, 22 Apr 2020 17:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Swift enums are very commonly used to create exhaustive lists of raw values (such as strings or integers) that can then be worked with in a type-safe manner. For example, here’s how we could define a <code>VideoFormat</code> enum that contains a list of formats based on their file extensions:</p><pre class="splash"><code><span class="s-keyword">enum</span> VideoFormat: <span class="s-type">String</span> {
    <span class="s-keyword">case</span> mp4
    <span class="s-keyword">case</span> webM = <span class="s-string">"webm"</span>
    <span class="s-keyword">case</span> ogg
}</code></pre><p>When declaring a raw value-based enum like the one above, the compiler will automatically make it conform to the <code>RawRepresentable</code> protocol — which in turn gives us access to APIs like the <code>init?(rawValue:)</code> initializer, as well as the <code>rawValue</code> property — enabling us to easily convert raw values to and from instances of our enum.</p><p>While it might initially seem like that sort of functionality requires an enum’s raw type to be a built-in one (such as <code>String</code>), it actually works with completely custom ones too — as long as they both conform to <code>Equatable</code>, and can be expressed using either a string or numeric literal.</p><p>As an example, let’s say that we’re working on an app that uses the following <code>Path</code> type to model file system paths in a more strongly typed manner (compared to always passing raw strings around):</p><pre class="splash"><code><span class="s-keyword">struct</span> Path: <span class="s-type">Equatable</span> {
    <span class="s-keyword">var</span> string: <span class="s-type">String</span>
}</code></pre><p>Now wouldn’t it be cool if we would be able to define an enum with <code>Path</code>-based raw values? For example in order to specify an exhaustive list of targets for certain file system operations, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Target: <span class="s-type">Path</span> {
    <span class="s-keyword">case</span> content
    <span class="s-keyword">case</span> resources
    <span class="s-keyword">case</span> images = <span class="s-string">"resources/images"</span>
}</code></pre><p>The cool thing is that all we need to do to make the above possible is to make our <code>Path</code> type conform to <code>ExpressibleByStringLiteral</code> — and the compiler will take care of the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">init</span>(stringLiteral: <span class="s-type">String</span>) {
        string = stringLiteral
    }
}</code></pre><p>The fact that enums can have completely custom raw types is yet another example of how so much of Swift’s core functionality is implemented using its own type system — which in turn makes it possible for our custom types to behave exactly like the built-in ones do.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/mixing-enums-with-other-swift-types</guid><title>Mixing enums with other Swift types</title><description>Swift enums are really powerful, but they can often be made even more capable when mixed with other kinds of Swift types — such as protocols and structs. This week, let’s take a look at a few examples of doing just that.</description><link>https://www.swiftbysundell.com/articles/mixing-enums-with-other-swift-types</link><pubDate>Sun, 19 Apr 2020 21:07:00 +0200</pubDate><content:encoded><![CDATA[<p>One really interesting aspect of Swift is just how many different language features that it supports. While it could definitely be argued that having lots of features at our disposal perhaps makes the language more complex than it needs to be, it’s also a big part of what makes Swift so flexible when it comes to how we write and structure our code.</p><p>While using <em>all</em> of Swift’s language features as much as possible is hardly a good goal to have, building a truly great Swift program often comes down to making the best use of each feature that’s relevant to what we’re looking to build — which often means mixing them in order to best take advantage of what each feature has to offer.</p><p>This week, let’s take a look at a few examples of doing just that — specifically when it comes to how enums can be mixed with some of Swift’s other features in order to improve the predictability of our logic, while also reducing boilerplate.</p><h2>Eliminating multiple sources of truth</h2><p>One of the most common problems within software engineering in general is logic that relies on <em>multiple sources of truth</em> for a given piece of data — especially when those sources might end up contradicting each other, which tends to result in <em>undefined states</em>.</p><p>For example, let’s say that we’re working on an app for writing articles, and that we’d like to use the same data model to represent articles that have been published, as well as unpublished drafts.</p><p>To handle those two cases, we might give our data model an <code>isDraft</code> property that indicates whether it’s representing a draft, and we’d also need to turn any data that’s unique to published articles into optionals — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">Content</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? <span class="s-comment">// Only assigned to published articles</span>
    <span class="s-keyword">var</span> isDraft: <span class="s-type">Bool</span> <span class="s-comment">// Indicates whether this is a draft</span>
    ...
}</code></pre><p>At first, it might not seem like the above model has multiple sources of truth — but it actually does, since whether an article should be considered <em>published</em> could both be determined by looking at whether it has a <code>url</code> assigned to it, or whether its <code>isDraft</code> property is <code>true</code>.</p><p>That may not seem like a big deal, but it could quite quickly lead to inconsistencies across our code base, and it also requires unnecessary boilerplate — as each call site has to both check the <code>isDraft</code> flag, and unwrap the optional <code>url</code> property, in order to make sure that its logic is correct.</p><p>This is exactly the type of situation in which Swift’s enums really shine — since they let us model the above kind of variants as explicit states, each of which can carry its own set of data in a non-optional manner — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">enum</span> State {
        <span class="s-keyword">case</span> published(<span class="s-type">URL</span>)
        <span class="s-keyword">case</span> draft
    }
}</code></pre><p>What the above enum enables us to do is to replace our previous <code>url</code> and <code>isDraft</code> properties with a new <code>state</code> property — which will act as a single source of truth for determining the state of each article:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">Content</span>
    <span class="s-keyword">var</span> state: <span class="s-type">State</span>
}</code></pre><p>With the above in place we can now simply <code>switch</code> on our new <code>state</code> property whenever we need to check whether an article has been published — and the code paths for published articles no longer need to deal with any optional URLs. For example, here’s how we could now conditionally create a <code>UIActivityViewController</code> for sharing published articles:</p><pre class="splash"><code><span class="s-keyword">func</span> makeActivityViewController(
    for article: <span class="s-type">Article</span>
) -&gt; <span class="s-type">UIActivityViewController</span>? {
    <span class="s-keyword">switch</span> article.<span class="s-property">state</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">published</span>(<span class="s-keyword">let</span> url):
        <span class="s-keyword">return</span> <span class="s-type">UIActivityViewController</span>(
            activityItems: [url],
            applicationActivities: <span class="s-keyword">nil</span>
        )
    <span class="s-keyword">case</span> .<span class="s-dotAccess">draft</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p>However, when making the above kind of structural change to one of our core data models, chances are that we’ll also need to update quite a lot of code that uses that model — and we might not be able to perform all of those updates at once.</p><p>Thankfully, it’s often relatively easy to solve that type of problem through some form of temporary backward compatibility layer — which uses our new single source of truth under the hood, while still exposing the same API as we had before to the rest of our code base.</p><p>For example, here’s how we could let <code>Article</code> temporarily keep its <code>url</code> property until we’re done migrating all of our code to its new <code>state</code> API:</p><pre class="splash"><code><span class="s-preprocessing">#warning</span>(<span class="s-string">"Temporary backward compatibility. Remove ASAP."</span>)
<span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">@available</span>(*, deprecated, message: <span class="s-string">"Use state instead"</span>)
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? {
        <span class="s-keyword">get</span> {
            <span class="s-keyword">switch</span> state {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">draft</span>:
                <span class="s-keyword">return nil
            case</span> .<span class="s-dotAccess">published</span>(<span class="s-keyword">let</span> url):
                <span class="s-keyword">return</span> url
            }
        }
        <span class="s-keyword">set</span> {
            state = newValue.<span class="s-call">map</span>(<span class="s-type">State</span>.<span class="s-property">published</span>) ?? .<span class="s-dotAccess">draft</span>
        }
    }
}</code></pre><p class="info">Above we’re using both the <code>#warning</code> compiler directive, and the <code>@available</code> attribute, to have the compiler emit warnings both wherever our <code>url</code> property is still used, and to remind us that this extension should be removed as soon as possible.</p><p>So that’s an example of how we can mix structs and other types with enums in order to establish a single source of truth for our various states. Next, let’s take a look at how we can go the other way around, and <em>augment</em> some of our enums to make them much more powerful — while also reducing our overall number of <code>switch</code> statements in the process.</p><h2>Enums versus protocols</h2><p>Following the above idea of using enums to model distinct states — let’s now say that we’re working on a drawing app, and that we’ve currently implemented our tool selection code using an enum that contains all of the drawing tools that our app supports:</p><pre class="splash"><code><span class="s-keyword">enum</span> Tool: <span class="s-type">CaseIterable</span> {
    <span class="s-keyword">case</span> pen
    <span class="s-keyword">case</span> brush
    <span class="s-keyword">case</span> fill
    <span class="s-keyword">case</span> text
    ...
}</code></pre><p>Besides the state management aspects, one additional benefit of using an enum in this case is the <code>CaseIterable</code> protocol, which our <code>Tool</code> type conforms to. Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42">“Enum iterations in Swift”</a></em>, conforming to that protocol makes the compiler automatically generate a static <code>allCases</code> property, which we can then use to easily iterate through all of our cases — for example in order to build a toolbox view that contains buttons for each of our drawing tools:</p><pre class="splash"><code><span class="s-keyword">func</span> makeToolboxView() -&gt; <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> toolbox = <span class="s-type">UIView</span>()

    <span class="s-keyword">for</span> tool <span class="s-keyword">in</span> <span class="s-type">Tool</span>.<span class="s-property">allCases</span> {
        <span class="s-comment">// Add a button for selecting the tool</span>
        ...
    }

    <span class="s-keyword">return</span> toolbox
}</code></pre><p>However, as neat as it is to have all of our tools gathered within a single type, that setup does come with a quite major disadvantage in this case.</p><p>Since all of our tools are likely going to need a fair amount of logic, and using an enum requires us to implement all of that logic within a single place, we’ll probably end up with series of increasingly complex <code>switch</code> statements — looking something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Tool</span> {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">pen</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">brush</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">fill</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">text</span>:
            ...
        ...
        }
    }
    
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> {
        <span class="s-keyword">switch self</span> {
        ...
        }
    }

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        <span class="s-keyword">switch self</span> {
        ...
        }
    }
}</code></pre><p>Another issue with our current approach is that it makes it quite difficult to store tool-specific states — since enums that conform to <code>CaseIterable</code> can’t carry any associated values.</p><p>To address both of the above two problems, let’s instead try to implement each of our tools using a protocol — which would give us a shared interface, while still enabling each tool to be declared and implemented in isolation:</p><pre class="splash"><code><span class="s-comment">// A protocol that acts as a shared interface for each of our tools:</span>
<span class="s-keyword">protocol</span> Tool {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>)
}

<span class="s-comment">// Simpler tools can just implement the required properties, as well
// as the 'apply' method for performing their drawing:</span>
<span class="s-keyword">struct</span> PenTool: <span class="s-type">Tool</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">pen</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Draw using a pen"</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }
}

<span class="s-comment">// More complex tools are now free to declare their own state properties,
// which could then be used within their drawing code:</span>
<span class="s-keyword">struct</span> TextTool: <span class="s-type">Tool</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">letter</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Add text"</span>

    <span class="s-keyword">var</span> font = <span class="s-type">UIFont</span>.<span class="s-call">systemFont</span>(ofSize: <span class="s-type">UIFont</span>.<span class="s-property">systemFontSize</span>)
    <span class="s-keyword">var</span> characterSpacing: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }
}</code></pre><p>However, while the above change enables us to fully decouple our various <code>Tool</code> implementations, we’ve also lost one of the major benefits of our enum-based approach — that we could easily iterate over each tool by using <code>Tool.allCases</code>.</p><p>While we <em>could</em> sort of achieve the same thing using a manually implemented function (or use some form of code generation), that’s extra code that we’d have to maintain and keep in sync with our various <code>Tool</code> types — which isn’t ideal:</p><pre class="splash"><code><span class="s-keyword">func</span> allTools() -&gt; [<span class="s-type">Tool</span>] {
    <span class="s-keyword">return</span> [
        <span class="s-type">PenTool</span>(),
        <span class="s-type">BrushTool</span>(),
        <span class="s-type">FillTool</span>(),
        <span class="s-type">TextTool</span>()
        ...
    ]
}</code></pre><p>But what if we didn’t have to make a choice <em>between</em> protocols and enums, and instead could mix them to sort of achieve the best of both worlds?</p><h2>Enum on the outside, protocol on the inside</h2><p>Let’s revert our <code>Tool</code> type back to being an enum, but rather than again implementing all of our logic as methods and properties full of <code>switch</code> statements — let’s instead keep those implementations protocol-oriented, only this time we’ll make them <em>controllers for our tools</em>, rather than being model representations of the tools themselves.</p><p>Using our previous <code>Tool</code> protocol as a starting point, let’s define a new protocol called <code>ToolController</code>, which — along with our previous requirements — includes a method that lets each tool provide and manage its own options view. That way, we can end up with a truly decoupled architecture, in which each controller completely manages the logic and UI required for each given tool:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ToolController {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>)
    <span class="s-keyword">func</span> makeOptionsView() -&gt; <span class="s-type">UIView</span>?
}</code></pre><p>Going back to our <code>TextTool</code> implementation from before, here’s how we could modify it to instead become a <code>TextToolController</code> that conforms to our new protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> TextToolController: <span class="s-type">ToolController</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">letter</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Add text"</span>

    <span class="s-keyword">private var</span> font = <span class="s-type">UIFont</span>.<span class="s-call">systemFont</span>(ofSize: <span class="s-type">UIFont</span>.<span class="s-property">systemFontSize</span>)
    <span class="s-keyword">private var</span> characterSpacing: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }

    <span class="s-keyword">func</span> makeOptionsView() -&gt; <span class="s-type">UIView</span>? {
        <span class="s-keyword">let</span> view = <span class="s-type">UIView</span>()

        <span class="s-keyword">let</span> characterSpacingStepper = <span class="s-type">UIStepper</span>()
        view.<span class="s-call">addSubview</span>(characterSpacingStepper)

        <span class="s-comment">// When creating our tool-specific options view, our
        // controller can now reference its own instance methods
        // and properties, just like a view controller would:</span>
        characterSpacingStepper.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(handleCharacterSpacingStepper),
            for: .<span class="s-dotAccess">valueChanged</span>
        )
        
        ...

        <span class="s-keyword">return</span> view
    }
    
    ...
}</code></pre><p>Then, rather than having our <code>Tool</code> enum contain any actual logic, we’ll just give it a single method for creating a <code>ToolController</code> corresponding to its current state — saving us the trouble of having to write all those <code>switch</code> statements that we had before, while still enabling us to make full use of <code>CaseIterable</code>:</p><pre class="splash"><code><span class="s-keyword">enum</span> Tool: <span class="s-type">CaseIterable</span> {
    <span class="s-keyword">case</span> pen
    <span class="s-keyword">case</span> brush
    <span class="s-keyword">case</span> fill
    <span class="s-keyword">case</span> text
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Tool</span> {
    <span class="s-keyword">func</span> makeController() -&gt; <span class="s-type">ToolController</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">pen</span>:
            <span class="s-keyword">return</span> <span class="s-type">PenToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">brush</span>:
            <span class="s-keyword">return</span> <span class="s-type">BrushToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">fill</span>:
            <span class="s-keyword">return</span> <span class="s-type">FillToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">text</span>:
            <span class="s-keyword">return</span> <span class="s-type">TextToolController</span>()
        ...
        }
    }
}</code></pre><p class="info">An alternative to the above approach would be to create a dedicated <code>ToolControllerFactory</code>, rather than having <code>Tool</code> itself create our controllers. To learn more about that pattern, check out <a href="https://www.swiftbysundell.com/tags/the-factory-pattern">this page</a>.</p><p>Finally, putting all of the pieces together, we’ll now be able to both easily iterate over each tool in order to build our toolbox view, and trigger the current tool’s logic by communicating with its <code>ToolController</code> — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private var</span> tool = <span class="s-type">Tool</span>.<span class="s-call">pen</span> {
        <span class="s-keyword">didSet</span> { controller = tool.<span class="s-call">makeController</span>() }
    }
    <span class="s-keyword">private lazy var</span> controller = tool.<span class="s-call">makeController</span>()
    <span class="s-keyword">private let</span> canvas = <span class="s-type">Canvas</span>()
    
    ...
    
    <span class="s-keyword">private func</span> makeToolboxView() -&gt; <span class="s-type">UIView</span> {
        <span class="s-keyword">let</span> toolbox = <span class="s-type">UIView</span>()
    
        <span class="s-keyword">for</span> tool <span class="s-keyword">in</span> <span class="s-type">Tool</span>.<span class="s-property">allCases</span> {
            <span class="s-comment">// Add a button for selecting the tool</span>
            ...
        }
    
        <span class="s-keyword">return</span> toolbox
    }

    <span class="s-keyword">private func</span> handleTapRecognizer(<span class="s-keyword">_</span> recognizer: <span class="s-type">UITapGestureRecognizer</span>) {
        <span class="s-comment">// Handling taps on the canvas using the current tool's controller:</span>
        <span class="s-keyword">let</span> location = recognizer.<span class="s-call">location</span>(in: view)
        controller.<span class="s-call">apply</span>(at: location, on: canvas)
    }
    
    ...
}</code></pre><p>The beauty of the above approach is that it enables us to fully decouple our logic, while still establishing a single source of truth for all of our states and variants. We could’ve also chosen to split our code up a bit differently, for example to keep each tool’s <code>icon</code> and <code>name</code> within our enum, and only move our actual logic out to our <code>ToolController</code> implementations — but that’s always something we could tweak going forward.</p><h2>Conclusion</h2><p>While it sometimes might seem like we always need to pick just a single type of abstraction within each given situation, we can often achieve some really interesting results when combining and mixing several of Swift’s language features into a single solution — for example by combining the predictability of enums with the flexibility of protocols.</p><p>What do you think? Have you ever mixed enums with Swift’s other features and types in order to solve a specific problem? Let me know — along with your questions, feedback and comments — either <a href="https://www.swiftbysundell.com/contact">via email</a> or on <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/combine</guid><title>Basics: Combine</title><description>Combine is a really powerful reactive programming framework from Apple, but getting started with it can be quite difficult, so let’s go through the basics of its API and its core concepts.</description><link>https://www.swiftbysundell.com/basics/combine</link><pubDate>Thu, 16 Apr 2020 14:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Introduced during WWDC 2019, Apple’s Combine framework lets us model all sorts of asynchronous events and operations as <em>“values over time”</em>. While that’s a phrase that’s commonly used within the <em>reactive programming</em> world, as a concept and way of constructing logic, it can initially be quite difficult to fully grasp.</p><p>So in this article, let’s take a look at the basics of Combine, what some of the core principles of reactive programming are, and how they can become really useful in practice.</p><p>Let’s start with <em>Publishers</em>, which are observable objects that emit values whenever a given event occurred. Publishers can either be active indefinitely or eventually be completed, and can also optionally fail when an error was encountered.</p><p>When introducing Combine, Apple also went through some of their core libraries in order to retrofit them with Combine support. For example, here’s how we could use Foundation’s <code>URLSession</code> type to create a publisher for making a <a href="https://www.swiftbysundell.com/basics/networking">network request</a> to a given URL:</p><pre class="splash"><code><span class="s-keyword">let</span> url = <span class="s-type">URL</span>(string: <span class="s-string">"https://api.github.com/repos/johnsundell/publish"</span>)!
<span class="s-keyword">let</span> publisher = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTaskPublisher</span>(for: url)</code></pre><p>Once we’ve created a publisher, we can then attach <em>subscriptions</em> to it, for example by using the <code>sink</code> API — which lets us pass a closure to be called whenever a new value was received, as well as one that’ll be called once the publisher was completed:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in</span>
        <span class="s-comment">// Called once, when the publisher was completed.</span>
        <span class="s-call">print</span>(completion)
    },
    receiveValue: { value <span class="s-keyword">in</span>
        <span class="s-comment">// Can be called multiple times, each time that a
        // new value was emitted by the publisher.</span>
        <span class="s-call">print</span>(value)
    }
)</code></pre><p>Note how our above call to <code>sink</code> returns a value that we store as <code>cancellable</code>. When attaching a new subscriber, a Combine publisher always returns an object that conforms to the <code>Cancellable</code> <a href="https://www.swiftbysundell.com/basics/protocols">protocol</a>, which acts as a <em>token</em> for the new subscription. We then need to retain that token for as long as we want the subscription to remain active, since once it gets <a href="https://www.swiftbysundell.com/basics/memory-management">deallocated</a>, our subscription will automatically get cancelled (we can also cancel it manually by calling <code>cancel()</code> on the token).</p><p>Next, let’s fill in our above closures with a bit more logic, starting with the one for <code>receiveCompletion</code>, which will get passed an <a href="https://www.swiftbysundell.com/basics/enums">enum</a> containing two cases — one for any error that was encountered, and one for when the publisher successfully completed:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { value <span class="s-keyword">in</span>
        <span class="s-call">print</span>(value)
    }
)</code></pre><p>Before we start filling in our <code>receiveValue</code> closure, let’s define a simple data model that we’ll decode our downloaded data into. Since we’re using a URL that points to a GitHub API endpoint for a repository (<a href="https://github.com/johnsundell/publish">Publish</a>, to be exact), let’s declare our model as a <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a> struct that has two properties can be found in the JSON that we’ll download:</p><pre class="splash"><code><span class="s-keyword">struct</span> Repository: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
}</code></pre><p>With the above model in place, let’s now implement our <code>receiveValue</code> logic — in which we’ll create a <code>JSONDecoder</code> in order to decode the data that was downloaded into a <code>Repository</code> value, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { value <span class="s-keyword">in
        let</span> decoder = <span class="s-type">JSONDecoder</span>()

        <span class="s-keyword">do</span> {
            <span class="s-comment">// Since each value passed into our closure will be a tuple
            // containing the downloaded data, as well as the network
            // response itself, we're accessing the 'data' property here:</span>
            <span class="s-keyword">let</span> repo = <span class="s-keyword">try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Repository</span>.<span class="s-keyword">self</span>, from: value.<span class="s-property">data</span>)
            <span class="s-call">print</span>(repo)
        } <span class="s-keyword">catch</span> {
            <span class="s-call">print</span>(error)
        }
    }
)</code></pre><p>While the above works, we’ve sort of written our code the same way as we would when using a standard closure-based API — in that we’re nesting our logic within completion handlers. There’s nothing wrong with that, but the true power of Combine (and reactive programming in general) lies in constructing <em>chains of operations</em> that our data gets streamed through.</p><p>To get started, let’s take a look at the <code>map</code> operator, which works the same way as it <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">does on collections</a> — as it lets us transform each value that a publisher emits into a new form. Such a transform can be as simple as accessing a property on each value — for example, here we’re transforming each of our network result values by extracting their <code>data</code> property, which now gives us a publisher that emits <code>Data</code> values instead:</p><pre class="splash"><code><span class="s-keyword">let</span> dataPublisher = publisher.<span class="s-call">map</span>(\.<span class="s-property">data</span>)</code></pre><p class="info">Above we’re accessing the <code>data</code> property using a key path, which you can read more about in <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">“The power of key paths in Swift”</a>.</p><p>Besides <code>map</code>, Combine also ships with a number of other operators that we can use to transform our data in various ways. It even includes an operator that lets us decode our data directly within our chain — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> repoPublisher = publisher
    .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
    .<span class="s-call">decode</span>(
        type: <span class="s-type">Repository</span>.<span class="s-keyword">self</span>,
        decoder: <span class="s-type">JSONDecoder</span>()
    )</code></pre><p>While we started out with a publisher that was emitting <code>(Data, URLResponse)</code> values, through our above chain, we’ve now transformed that publisher into one that emits <code>Repository</code> values directly — which lets us heavily simplify our subscription code, as we no longer need to perform any form of data decoding within our closures:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = repoPublisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { repo <span class="s-keyword">in</span>
        <span class="s-call">print</span>(repo)
    }
)</code></pre><p class="info">A general rule of thumb is to try to keep all subscription closures as simple as possible — and to instead construct the above sort of reactive chains that our data can flow through in order to get transformed into its final form.</p><p>Since Combine is primarily used to handle asynchronous events and values, it’s quite common to run into threading issues when using it — especially when we want to use a received value within our UI code. Since Apple’s UI frameworks (UIKit, AppKit, SwiftUI, etc.) can — for the most part — only be updated from the <em><a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">main thread</a></em>, we’re going to run into issues when writing code like this:</p><pre class="splash"><code><span class="s-comment">// Two labels that we want to render our data using:</span>
<span class="s-keyword">let</span> nameLabel = <span class="s-type">UILabel</span>()
<span class="s-keyword">let</span> errorLabel = <span class="s-type">UILabel</span>()

<span class="s-keyword">let</span> cancellable = repoPublisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-comment">// Rendering a description of the error that was encountered:</span>
            errorLabel.<span class="s-property">text</span> = error.<span class="s-property">localizedDescription</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-keyword">break</span>
        }
    },
    receiveValue: { repo <span class="s-keyword">in</span>
        <span class="s-comment">// Rendering the downloaded repository's name:</span>
        nameLabel.<span class="s-property">text</span> = repo.<span class="s-property">name</span>
    }
)</code></pre><p>The problem is that, since <code>URLSession</code> performs its work on a background thread, our subscriptions will also be triggered on that same background thread by default — which in turn makes us violate the rule of only performing UI updates on the main thread.</p><p>The good news is that it’s really easy to fix the above sort of issues when using Combine, as it also includes an operator that lets us switch which thread (or <a href="https://www.swiftbysundell.com/clips/2"><code>DispatchQueue</code></a>) that a publisher will emit its events on — which we in this case can use to jump over to the <code>main</code> queue, and thus, the main thread:</p><pre class="splash"><code><span class="s-keyword">let</span> repoPublisher = publisher
    .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
    .<span class="s-call">decode</span>(
        type: <span class="s-type">Repository</span>.<span class="s-keyword">self</span>,
        decoder: <span class="s-type">JSONDecoder</span>()
    )
    .<span class="s-call">receive</span>(on: <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>)</code></pre><p>So that’s the basics of using Combine to subscribe to a publisher, and using operators to transform its values. Next, let’s take a look at how we can create our very own publishers as well, and a few things that can be good to keep in mind when doing that.</p><p>Let’s say that we’re working on a simple <code>Counter</code> class that keeps track of a value that can be incremented by calling an <code>increment()</code> method — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-comment">// Using 'private(set)', we ensure that our value can only
    // be modified within the Counter class itself, while still
    // enabling external code to read it:</span>
    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span>

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p>Now let’s make it possible to use Combine to subscribe to changes in our counter’s value. To get started, we could use Combine’s built-in <code>PassthroughSubject</code> type, which both acts as a publisher, and as a <em>subject</em> — an object that new values can be <em>sent</em> using:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-keyword">let</span> publisher = <span class="s-type">PassthroughSubject</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt;()

    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span> {
        <span class="s-comment">// Whenever our property was set, we send its new value
        // to our subject/publisher:</span>
        <span class="s-keyword">didSet</span> { publisher.<span class="s-call">send</span>(value) }
    }

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p class="info">We’re using <code>Never</code> as our publisher’s error type, which means that it’ll never be able to throw any errors — which is perfect in this case, since we’re only sending new <code>Int</code> values to it.</p><p>With the above in place, we can now subscribe to our new publisher just like we did earlier when performing network requests using <code>URLSession</code> — for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> counter = <span class="s-type">Counter</span>()

<span class="s-keyword">let</span> cancellable = counter.<span class="s-property">publisher</span>
    .<span class="s-call">filter</span> { $0 &gt; <span class="s-number">2</span> }
    .<span class="s-call">sink</span> { value <span class="s-keyword">in</span>
        <span class="s-call">print</span>(value)
    }

<span class="s-comment">// Since we're filtering out all values below 3, only our final
// increment call will result in a value being printed:</span>
counter.<span class="s-call">increment</span>()
counter.<span class="s-call">increment</span>()
counter.<span class="s-call">increment</span>()</code></pre><p class="info">Note how we’re able to just pass a single closure into our above call to <code>sink</code>, since our publisher can’t throw any errors, which means that we don’t need to handle its completion event (if we don’t want to).</p><p>However, while the above approach works, it does come with a quite major downside. Since our <code>PassthroughSubject</code> is both a publisher and a subject, any code can send new values to it, even if that code lives outside of our <code>Counter</code> class — simply by calling <code>send()</code>:</p><pre class="splash"><code>counter.<span class="s-property">publisher</span>.<span class="s-call">send</span>(<span class="s-number">17</span>)</code></pre><p>That isn’t great, as ideally we’d like to enforce that only <code>Counter</code> can send new values — to avoid <em>multiple sources of truth</em>. Thankfully, that can quite easily be done, by creating two separate properties — one that only exposes the <em>publisher part</em> of our <code>PassthroughSubject</code>, and a private one that lets us access it as a <em>subject</em> as well:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-keyword">var</span> publisher: <span class="s-type">AnyPublisher</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt; {
        <span class="s-comment">// Here we're "erasing" the information of which type
        // that our subject actually is, only letting our outside
        // code know that it's a read-only publisher:</span>
        subject.<span class="s-call">eraseToAnyPublisher</span>()
    }

    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> { subject.<span class="s-call">send</span>(value) }
    }

    <span class="s-comment">// By storing our subject in a private property, we'll only
    // be able to send new values to it from within this class:</span>
    <span class="s-keyword">private let</span> subject = <span class="s-type">PassthroughSubject</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt;()

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p>Much better. We now have a strong guarantee that the values that our publisher will emit will always be completely in-sync with the actual state of our <code>Counter</code> class.</p><p>Another option that would let us achieve the same thing would be to use the <code>@Published</code> property wrapper — check out <em><a href="https://www.swiftbysundell.com/articles/published-properties-in-swift">“Published properties in Swift”</a></em> for more info on that approach.</p><p>To recap, these are five of the key pieces of Combine’s overall terminology:</p><ul><li>A <em>publisher</em> is an observable object that emits values over time, and that can also optionally complete either when no more values are available, or when it encountered an error.</li><li>Objects or closures that are used to observe a publisher are referred to as <em>subscribers</em>.</li><li>A <em>subject</em> is a <em>mutable</em> object that can be used to send new values through a publisher. Types like <code>PassthroughSubject</code> act as both publishers and subjects.</li><li><em>Operators</em> are used to build reactive chains or pipelines that our data can flow through, where each operator applies some form of transform to the data that was sent to it.</li><li>A <em>cancellable</em> is used to keep track of a subscription to a given publisher, and needs to be retained for as long as we want that subscription to remain active.</li></ul><p>Combine is an exciting framework that lets us use the power of reactive programming without having to bring in any third-party dependencies — which in turn enables us to construct logic that automatically <em>reacts</em> to changes in values over time.</p><p>While this article only covered the very basics of Combine, I hope that you found it useful, and we’ll dive into much more advanced ways of using Combine within the <a href="https://www.swiftbysundell.com/articles">main weekly article series</a> over the coming months and years.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/instabug-april-2020</guid><title>Sponsor: Instabug</title><description>Thanks a lot to Instabug for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/instabug-april-2020</link><pubDate>Wed, 15 Apr 2020 14:20:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">Instabug</a> for sponsoring Swift by Sundell for another two weeks, helping me keep the site free and open to everyone.</p><p>People often ask me for recommendations as to which crash reporter to use for an iOS app — and for me that’s an easy decision — Instabug is not only an incredibly powerful crash reporter, it also has a ton of other useful features, and a strong focus on both privacy and security.</p><p>With Instabug, you can let your testers and users easily report bugs and issues, and ask you questions, right from within the app itself. And, when those reports instantly appear within your Instabug dashboard, they’ll also contain all sorts of useful debugging information and reproduction steps — so that you can fix those issues in record time.</p><p>You’ll also get performance monitoring, in-app surveys, intelligent grouping for all crash and bug reports, detailed stack traces, network request logs, and so much more — all in a single, easy to use SDK. It’s <a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">free to try</a>, and only takes a minute to integrate.</p><p><a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">Try Instabug for free and support Swift by Sundell</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/published-properties-in-swift</guid><title>Published properties in Swift</title><description>This week, let’s explore the topic of published properties, by reimplementing Combine’s @Published property wrapper with support for earlier versions of Apple’s operating systems.</description><link>https://www.swiftbysundell.com/articles/published-properties-in-swift</link><pubDate>Sun, 12 Apr 2020 21:50:00 +0200</pubDate><content:encoded><![CDATA[<p>Reactive programming has become increasingly popular within the Apple developer community over the last few years, and the introduction of Apple’s own Combine framework during WWDC 2019 is likely going to further accelerate that growth in popularity for years to come.</p><p>Part of the magic of Combine is that it isn’t <em>just</em> another reactive programming framework. While it does use patterns and APIs that are very similar to other reactive frameworks, such as RxSwift and ReactiveSwift, it also makes heavy use of several new Swift features (as well as a dash of compiler magic) to make reactive programming more approachable in a few key ways.</p><p>However, using Combine requires us to drop support for Apple’s previous OS versions, which is many cases might be somewhat of a “deal breaker”. So this week, let’s take a look at one of Combine’s more interesting aspects — published properties — and how it’s definitely possible to adopt that pattern even without access to Combine itself.</p><h2>The magic of observable objects</h2><p>Apart from being a stand-alone framework, Combine also plays a very important role in the declarative machinery that powers SwiftUI — especially when it comes to how the system can automatically re-render parts of our UI when its underlying data changes.</p><p>A key part of that system is the <code>ObservableObject</code> protocol, which enables us to mark any class as being <em>observable</em>. That, along with the <code>@Published</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a>, lets us easily construct types that emit signals whenever some of their properties were changed.</p><p>For example, here’s how we could use those two tools to define a <code>ProfileViewModel</code> which notifies its observers whenever its <code>state</code> was modified:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">enum</span> State {
        <span class="s-keyword">case</span> isLoading
        <span class="s-keyword">case</span> failed(<span class="s-type">Error</span>)
        <span class="s-keyword">case</span> loaded(<span class="s-type">User</span>)
    }

    <span class="s-comment">// Simply marking a property with the @Published property wrapper
    // is enough to make the system emit observable events whenever
    // a new value was assigned to it.</span>
    <span class="s-keyword">@Published private(set) var</span> state = <span class="s-type">State</span>.<span class="s-property">isLoading</span>
    
    ...
}</code></pre><p>The above is really all that it takes to make an object observable through Combine — which is quite remarkable — as the compiler will automatically synthesize an <code>objectWillChange</code> publisher (a Combine object which can be observed), and all of the code needed to bind our <code>@Published</code>-marked properties to that publisher.</p><p>When using SwiftUI, we can then use another property wrapper, <code>@ObservedObject</code>, to in turn bind any <code>ObservableObject</code> to our UI — which will make SwiftUI update our view on every change to that object’s published properties:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProfileView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ProfileViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Construct our UI based on the current state</span>
        ...
    }
}</code></pre><p>However, since Combine isn’t <em>just</em> a part of SwiftUI, but also a completely stand-alone framework, we can also use it within other contexts as well — for example when using UIKit or AppKit to build our UI.</p><p>While we won’t get those nice declarative data bindings for free outside of SwiftUI, we can still use the power of Combine itself by subscribing to any observable object’s <code>objectWillChange</code> publisher directly — and then update our UI accordingly, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">objectWillChange</span>.<span class="s-call">sink</span> { [<span class="s-keyword">weak self</span>] <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>()
        }
    }

    <span class="s-keyword">private func</span> render() {
        <span class="s-keyword">switch</span> viewModel.<span class="s-property">state</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">isLoading</span>:
            <span class="s-comment">// Show loading spinner</span>
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failed</span>(<span class="s-keyword">let</span> error):
            <span class="s-comment">// Show error view</span>
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">loaded</span>(<span class="s-keyword">let</span> user):
            <span class="s-comment">// Show user's profile</span>
            ...
        }
    }
}</code></pre><p class="info">Note that we need to keep track of the cancellable object that Combine returns when we start our subscription using <code>sink</code>, since that subscription will only remain valid for as long as the returned <code>AnyCancellable</code> instance is retained.</p><p>However, there is one major issue with our above implementation — and that’s that our observation will be triggered <em>before</em> our view model is updated, given that we’re subscribing to its <code>objectWillChange</code> publisher. That means that we’ll always render our view model’s <em>previous</em> state, rather than the new one, which isn’t great.</p><p>Thankfully, there is one more built-in way that we can observe our view model, without having to write any custom observation code — and that’s by attaching our subscription to the <code>state</code> property itself.</p><p>To do that, we’re going to access the <code>@Published</code> property wrapper’s <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/%23projected-values">projected value</a></em> (by prefixing its name with <code>$</code>), which gives us access to a Combine publisher just for that property. We can then subscribe to that publisher using the same <code>sink</code> API as before — only this time our closure will get passed the property’s <em>new value</em>, which makes our rendering code work as we’d expect:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">$state</span>.<span class="s-call">sink</span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }

    <span class="s-keyword">private func</span> render(<span class="s-keyword">_</span> state: <span class="s-type">ProfileViewModel</span>.<span class="s-type">State</span>) {
        ...
    }
}</code></pre><p>So Combine can be an incredibly useful tool even outside the realm of SwiftUI — as it enables us to set up custom data flows and bindings, while still taking advantage of <code>ObservableObject</code> and the very lightweight way in which it enables us to make our models (and other types) observable.</p><h2>Just a backport away</h2><p>However, the issue remains that Combine is only available on the (at the time of writing) latest major versions of Apple’s various operating systems. On one hand, that’s definitely to be expected, as that’s always the case for frameworks that ship as part of the operating systems themselves. But on the other hand, it’s a bit of a shame that we’ll potentially have to wait years until we can start adopting Combine’s various patterns. <em>Or do we?</em></p><p>After all, Combine is just Swift code (at least on the surface level), the property wrappers feature that <code>@Published</code> is implemented with is a standard Swift language feature that any code can use — and since we’ve established that <code>ObservableObject</code> (and the slight bit of magic that it employs to automatically bind our properties to its <code>objectWillChange</code> publisher) is mostly useful within the context of SwiftUI — is there really anything stopping us from reimplementing part of that system ourselves?</p><p>Let’s give it a try! We’ll start with a quite bare-bones <code>@propertyWrapper</code> implementation, which projects itself as its <code>projectedValue</code>, and keeps track of a list of observation closures using a <code>MutableReference</code> (which will later enable us to insert and remove observations using <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference semantics</a>), like this:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> Published&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Published</span> { <span class="s-keyword">self</span> }
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> { <span class="s-keyword">didSet</span> { <span class="s-call">valueDidChange</span>() } }
    
    <span class="s-keyword">private var</span> observations = <span class="s-type">MutableReference</span>(
        value: <span class="s-type">List</span>&lt;(<span class="s-type">Value</span>) -&gt; <span class="s-type">Void</span>&gt;()
    )

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue
    }
}</code></pre><p class="info">The above <code>List</code> type was borrowed from <a href="https://www.swiftbysundell.com/articles/picking-the-right-data-structure-in-swift">“Picking the right data structure in Swift”</a>, and the <code>MutableReference</code> type comes from <a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">“Combining value and reference types in Swift”</a>.</p><p>While we could’ve used a built-in data structure (such as <code>Array</code>) to store our observations, using a linked list gives us simple <code>O(1)</code> insertions and removals (while preserving the order of our elements), which in turn should prevent our new property wrapper from becoming a bottleneck when dealing with a large number of observations.</p><p>Next, let’s implement the <code>valueDidChange</code> method that’s being called whenever our property wrapper’s <code>wrappedValue</code> was modified — by simply iterating over all of our observation closures and calling them with our new value:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">Published</span> {
    <span class="s-keyword">func</span> valueDidChange() {
        <span class="s-keyword">for</span> closure <span class="s-keyword">in</span> observations.<span class="s-property">value</span> {
            <span class="s-call">closure</span>(wrappedValue)
        }
    }
}</code></pre><p>Now, before we implement our actual observation code, we’ll need to decide how we want to invalidate each observation (so that they get deallocated along with the objects that triggered them). While there are a <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-2">number of different approaches</a> that we can take here, let’s mimmic Combine’s approach and use <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-2/%23tokens">cancellation tokens</a> which automatically cancel their observation when deallocated.</p><p>Here’s how such a token type could be implemented:</p><pre class="splash"><code><span class="s-keyword">class</span> Cancellable {
    <span class="s-keyword">private var</span> closure: (() -&gt; <span class="s-type">Void</span>)?

    <span class="s-keyword">init</span>(closure: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">closure</span> = closure
    }

    <span class="s-keyword">deinit</span> {
        <span class="s-call">cancel</span>()
    }

    <span class="s-keyword">func</span> cancel() {
        closure?()
        closure = <span class="s-keyword">nil</span>
    }
}</code></pre><p>Finally, let’s give our new implementation of <code>@Published</code> a closure-based observation API, which will use the above <code>Cancellable</code> type to invalidate observations once cancelled:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Published</span> {
    <span class="s-keyword">func</span> observe(with closure: <span class="s-keyword">@escaping</span> (<span class="s-type">Value</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Cancellable</span> {
        <span class="s-comment">// To further mimmic Combine's behaviors, we'll call
        // each observation closure as soon as it's attached to
        // our property:</span>
        <span class="s-call">closure</span>(wrappedValue)

        <span class="s-keyword">let</span> node = observations.<span class="s-property">value</span>.<span class="s-call">append</span>(closure)

        <span class="s-keyword">return</span> <span class="s-type">Cancellable</span> { [<span class="s-keyword">weak</span> observations] <span class="s-keyword">in</span>
            observations?.<span class="s-property">value</span>.<span class="s-call">remove</span>(node)
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>ProfileViewController</code> and (with a few minor tweaks) achieve the exact same reactive UI implementation as we had before — only this time it’s fully compatible with iOS 12 and below:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type"><span class="highlight">Cancellable</span></span>? 

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">$state</span>.<span class="s-call"><span class="highlight">observe</span></span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in</span> 
            <span class="s-keyword">self</span>?.<span class="s-call">render</span>(state)
        }
    }

    <span class="s-keyword">private func</span> render(<span class="s-keyword">_</span> state: <span class="s-type">ProfileViewModel</span>.<span class="s-type">State</span>) {
        ...
    }
}</code></pre><p>Now all that we need to do is to make <code>ProfileViewModel</code> backward compatible as well, which can simply be done by removing its conformance to <code>ObseravableObject</code> (or at least making it conditional using the <code>@available</code> attribute), and everything else will keep working the exact same way as before.</p><h2>Remaining reactive with RxSwift</h2><p>While our above <code>@Published</code> implementation can act as a great starting point if we wish to adopt <em>some</em> of Combine’s patterns in a backward compatible way, it doesn’t really enable us to fully embrace reactive programming (unless we keep extending it with new capabilities). On the other hand, reactive programming is not universally adopted, and perhaps our current closure-based API is more than enough to cover our needs.</p><p>But let’s also explore what a fully reactive version of our new property wrapper might look like. To do that we’re going to enlist the help of the popular <a href="https://github.com/ReactiveX/RxSwift">RxSwift framework</a>, and implement our observations using its <code>PublishSubject</code> type. We’ll also return that subject (as a read-only <code>Observable&lt;Value&gt;</code>) as our property wrapper’s <code>projectedValue</code> — like this:</p><pre class="splash"><code><span class="s-keyword">import</span> RxSwift

<span class="s-keyword">@propertyWrapper
struct</span> Published&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Observable</span>&lt;<span class="s-type">Value</span>&gt; { subject }
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> { <span class="s-keyword">didSet</span> { <span class="s-call">valueDidChange</span>() } }

    <span class="s-keyword">private let</span> subject = <span class="s-type">PublishSubject</span>&lt;<span class="s-type">Value</span>&gt;()

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue
    }

    <span class="s-keyword">private func</span> valueDidChange() {
        subject.<span class="s-call">on</span>(.<span class="s-call">next</span>(wrappedValue))
    }
}</code></pre><p>With the above implementation in place, we can now use RxSwift’s many different APIs and reactive operators to transform and subscribe to our <code>@Published</code> values, for example like this:</p><pre class="splash"><code><span class="s-keyword">import</span> RxSwift

<span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> disposeBag = <span class="s-type">DisposeBag</span>()

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        viewModel.<span class="s-property">$state</span>
            .<span class="s-call">subscribe</span>(onNext: { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
                self</span>?.<span class="s-call">render</span>(state)
            })
            .<span class="s-call">disposed</span>(by: disposeBag)
    }
    
    ...
}</code></pre><p class="info">Note that RxSwift ships with its own cancellation token system, called “disposables”, which means that we no longer need our own <code>Cancellable</code> type when going this route.</p><p>There’s of course no right or wrong option when it comes to whether we should opt for the closure-based version or the one using RxSwift — both approaches have their own set of tradeoffs. Like with all technology decisions, it all comes down to what our requirements are, and whether either of the above two approaches will give us more benefits than what we’re paying to build and maintain them.</p><h2>Conclusion</h2><p>While Combine is a complex and powerful framework with a ton of different APIs and capabilities, the <code>@Published</code> property wrapper is one of its core aspects when it comes to UI development specifically — as it lets us easily set up reactive data bindings between our models and our UI.</p><p>Combine might be limited to the latest versions of Apple’s operating systems, but we could still implement our own version of the <code>@Published</code> property wrapper with support for either closure-based observations, frameworks like RxSwift, or something else. At the end of the day, even Apple’s own frameworks are implemented using the same kind of code that both you and I write on a daily basis — it’s just a matter of whether that’s code that we’re willing to maintain ourselves until we’re able to adopt the first party solution.</p><p>What do you think? Does the pattern of published properties appeal to you, and what do you think about the <code>@Published</code> implementations presented in this article? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths</guid><title>Tip: Combining dynamic member lookup with key paths</title><description></description><link>https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths</link><pubDate>Fri, 10 Apr 2020 16:20:00 +0200</pubDate><content:encoded><![CDATA[<p>At first, Swift’s <code>@dynamicMemberLookup</code> attribute might seem like an odd feature, given that it can be used to circumvent much of the type safety that Swift otherwise puts such a strong emphasis on.</p><p>Essentially, adding that attribute to a class or struct enables us to add support for accessing <em>any property</em> on that type — regardless of whether that property actually exists or not. For example, here’s a <code>Settings</code> type that currently implements <code>@dynamicMemberLookup</code> like this:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
struct</span> Settings {
    <span class="s-keyword">var</span> colorTheme = <span class="s-type">ColorTheme</span>.<span class="s-property">modern</span>
    <span class="s-keyword">var</span> itemPageSize = <span class="s-number">25</span>
    <span class="s-keyword">var</span> keepUserLoggedIn = <span class="s-keyword">true

    subscript</span>(dynamicMember member: <span class="s-type">String</span>) -&gt; <span class="s-type">Any</span>? {
        <span class="s-keyword">switch</span> member {
        <span class="s-keyword">case</span> <span class="s-string">"colorTheme"</span>:
            <span class="s-keyword">return</span> colorTheme
        <span class="s-keyword">case</span> <span class="s-string">"itemPageSize"</span>:
            <span class="s-keyword">return</span> itemPageSize
        <span class="s-keyword">case</span> <span class="s-string">"keepUserLoggedIn"</span>:
            <span class="s-keyword">return</span> keepUserLoggedIn
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return nil</span>
        }
    }
}</code></pre><p class="info">To learn more about subscripts in general, check out <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">“The power of subscripts in Swift”</a>.</p><p>Since the above type supports dynamic member lookup, we can use any arbitrary name when accessing one of its properties, and the compiler won’t give us any kind of warning or error when there’s no declared property matching that name:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-type">Settings</span>()
<span class="s-keyword">let</span> theme = settings.<span class="s-property">colorTheme</span>
<span class="s-keyword">let</span> somethingUnknown = settings.<span class="s-property">somePropertyName</span></code></pre><p>Again, that might seem like an odd feature for Swift to support, but it’s incredibly useful when writing <em>bridging code</em> between Swift and more dynamic languages — such as Ruby, Python, or JavaScript — or when writing other kinds of proxy-based code.</p><p>However, there is <em>one more way</em> to use <code>@dynamicMemberLookup</code> that can also be incredibly useful even within completely static Swift code — and that’s to combine it with <em><a href="https://www.swiftbysundell.com/tags/key-paths">key paths</a></em>.</p><p>As an example, let’s revisit the <code>Reference</code> type from <em><a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">“Combining value and reference types in Swift”</a></em> (which enables a value type to be passed as a reference), and add support for dynamically looking up one of its wrapped <code>Value</code> type’s members — but this time using a <code>KeyPath</code>, rather than a <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">private(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}</code></pre><p>Now this is <em>really cool</em>, because what the above enables us to do is to access any of our <code>Value</code> type’s properties directly as if they were properties of our <code>Reference</code> type itself — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> reference = <span class="s-type">Reference</span>(value: <span class="s-type">Settings</span>())
<span class="s-keyword">let</span> theme = reference.<span class="s-property">colorTheme</span></code></pre><p class="info">Since we implemented our <code>Reference</code> type’s <code>dynamicMember</code> subscript using a key path, we won’t be able to look up any arbitrary property name when using it, like we could when using strings.</p><p>We can even add a mutable version too, by creating a subscript overload that accepts a <code>WritableKeyPath</code>, and by then implementing both a getter and a setter for it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Reference</span> {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">WritableKeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">get</span> { value[keyPath: keyPath] }
        <span class="s-keyword">set</span> { value[keyPath: keyPath] = newValue }
    }
}</code></pre><p>With the above in place, we can now directly mutate any <code>Value</code> that’s wrapped using our <code>Reference</code> type — just as if we were mutating the reference instance itself:</p><pre class="splash"><code><span class="s-keyword">let</span> reference = <span class="s-type">Reference</span>(value: <span class="s-type">Settings</span>())
reference.<span class="s-property">theme</span> = .<span class="s-dotAccess">oldSchool</span></code></pre><p>Finally, just like how we in the <a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">original article</a> extracted all of the mutating APIs from <code>Reference</code> into a new <code>MutableReference</code> type — let’s do that here as well, to be able to limit in which parts of our code base that mutations can occur:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">fileprivate(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}

<span class="s-keyword">class</span> MutableReference&lt;Value&gt;: <span class="s-type">Reference</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">WritableKeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">get</span> { value[keyPath: keyPath] }
        <span class="s-keyword">set</span> { value[keyPath: keyPath] = newValue }
    }
}</code></pre><p>Using the above, we can now easily pass a value type as a reference, and both read and mutate its properties as if we were accessing the wrapped value directly — for example like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel {
    <span class="s-keyword">private let</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> settings: <span class="s-type">MutableReference</span>&lt;<span class="s-type">Settings</span>&gt;

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, settings: <span class="s-type">MutableReference</span>&lt;<span class="s-type">Settings</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }

    <span class="s-keyword">func</span> makeEmailAddressIcon() -&gt; <span class="s-type">Icon</span> {
        <span class="s-comment">// Reading Setting's 'colorTheme' property:</span>
        <span class="s-keyword">var</span> icon = <span class="s-type">Icon</span>.<span class="s-property">email</span>
        icon.<span class="s-property">useLightVersion</span> = settings.<span class="s-property">colorTheme</span>.<span class="s-property">isDark</span>
        <span class="s-keyword">return</span> icon
    }

    <span class="s-keyword">func</span> rememberMeSwitchToggled(to newValue: <span class="s-type">Bool</span>) {
        <span class="s-comment">// Mutating Setting's 'keepUserLoggedIn' property:</span>
        settings.<span class="s-property">keepUserLoggedIn</span> = newValue
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/handling-keyup-and-keydown-events</guid><title>Tip: Handling keyUp and keyDown events on iOS 13.4 and later</title><description>How to observe iOS 13.4’s new granular keyboard events.</description><link>https://www.swiftbysundell.com/tips/handling-keyup-and-keydown-events</link><pubDate>Mon, 6 Apr 2020 19:45:00 +0200</pubDate><content:encoded><![CDATA[<p>In iOS 13.4 Apple (<em>finally</em>) added support for detecting when an external keyboard key is either pressed or released, which can be incredibly useful in a number of different situations. While it was previously possible to <a href="https://www.swiftbysundell.com/articles/building-ipad-pro-features-in-swift/%23keyboard-shortcuts">register keyboard shortcuts</a> using the <code>UIKeyCommand</code> API, we now get direct access to what’s commonly referred to as <code>keyUp</code> and <code>keyDown</code> events.</p><p>As an example, let’s say that we’re working on an app that includes some form of editor, and that we want to add richer support for controlling that editor using an external keyboard. The first thing that we’ll need to do in order to make that happen is to override three methods that’ll let us handle <code>UIPress</code> events — since that class has now been upgraded with a new <code>key</code> property, which gives us information about pressed (and released) keys.</p><p>We can override those three methods on any <code>UIResponder</code>, for example our <code>EditorViewController</code>, and within each implementation we’ll unwrap the new <code>key</code> property in order to pass its <code>UIKey</code> value to one of two private methods — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> EditorViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> pressesBegan(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                               with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesBegan</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyPressed)
    }

    <span class="s-keyword">override func</span> pressesEnded(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                               with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesEnded</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyReleased)
    }

    <span class="s-keyword">override func</span> pressesCancelled(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                                   with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesCancelled</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyReleased)
    }
}</code></pre><p class="info">Another option would be to implement the above within a dedicated “keyboard handling” <a href="https://www.swiftbysundell.com/basics/child-view-controllers">child view controller</a>, which we could then <a href="https://www.swiftbysundell.com/articles/using-child-view-controllers-as-plugins-in-swift">plug into</a> our main <code>EditorViewController</code>.</p><p>Next, let’s implement those private methods, starting with <code>keyPressed</code>. The cool thing about <code>UIKey</code> is that it isn’t just a numeric key code (which is how these things have often worked historically), it’s a class that contains all sorts of useful information about a key’s state — for example whether a modifier key is also currently pressed. It also provides a completely type-safe API for identifying keys, which enables us to implement our handling logic using a single <code>switch</code> statement:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EditorViewController</span> {
    <span class="s-keyword">func</span> keyPressed(<span class="s-keyword">_</span> key: <span class="s-type">UIKey</span>) {
        <span class="s-keyword">switch</span> key.<span class="s-property">keyCode</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardP</span>:
            <span class="s-call">selectTool</span>(.<span class="s-dotAccess">pen</span>)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardB</span>:
            <span class="s-call">selectTool</span>(.<span class="s-dotAccess">brush</span>)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardE</span> <span class="s-keyword">where</span> key.<span class="s-property">modifierFlags</span>.<span class="s-call">contains</span>(.<span class="s-dotAccess">command</span>):
            <span class="s-call">eraseSelection</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardLeftShift</span>, .<span class="s-dotAccess">keyboardRightShift</span>:
            <span class="s-call">activateBoxedSelectionMode</span>()
        <span class="s-keyword">default</span>:
            <span class="s-keyword">break</span>
        }
    }
}</code></pre><p>Finally, let’s also implement our <code>keyReleased</code> method using the exact same technique:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EditorViewController</span> {
    <span class="s-keyword">func</span> keyReleased(<span class="s-keyword">_</span> key: <span class="s-type">UIKey</span>) {
        <span class="s-keyword">switch</span> key.<span class="s-property">keyCode</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardLeftShift</span>, .<span class="s-dotAccess">keyboardRightShift</span>:
            <span class="s-call">deactivateBoxedSelectionMode</span>()
        <span class="s-keyword">default</span>:
            <span class="s-keyword">break</span>
        }
    }
}</code></pre><p>Apple might’ve taken quite a long time to add full keyboard event support to iOS, but now that it’s finally here, its API is incredibly nice.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3</guid><title>A guide to the SwiftUI layout system - Part 3</title><description>This week, we’ll wrap up the SwiftUI layout system series by taking a look at how we can customize the layout behaviors of our views, using tools like layout priorities and alignment guides.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3</link><pubDate>Sun, 5 Apr 2020 17:45:00 +0200</pubDate><content:encoded><![CDATA[<p>Initially, SwiftUI’s layout system might seem a bit inflexible, as its default suite of concepts and APIs doesn’t give us a lot of pixel-level control, and instead focuses on leveraging a strong set of platform-defined defaults — which in turn enables the system to make many common layout decisions on our behalf.</p><p>However, once we look beneath the surface, there’s a ton of different customization options and overrides that we can apply to tweak the SwiftUI layout system and its default set of behaviors. So, in this third and final part of this series of articles, let’s explore some of those customization options, and how they can let us resolve common conflicts and remove sources of ambiguity when defining SwiftUI layouts.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was (just like <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a> and <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a>) written to enable you to easily code along within a SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted, except for the views that were built during the previous parts.</p><h2>Encountering conflicts</h2><p>Picking up where we left off at the end of <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a> — after adding both a header and a footer to our event view, let’s now add some actual content to it. Just like previously, we’ll stick to placeholder content within this article, to be able to fully focus on exploring the SwiftUI layout system itself.</p><p>Let’s start by creating a new view that’ll let us render a placeholder for an image using a <code>RoundedRectangle</code> shape, that’s placed within a <code>ZStack</code> along with a <code>Text</code>:</p><pre data-preview="image-placeholder"><code><span class="s-keyword">struct</span> ImagePlaceholder: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">RoundedRectangle</span>(cornerRadius: <span class="s-number">10</span>).<span class="s-call">stroke</span>()
            <span class="s-type">Text</span>(<span class="s-string">"Image placeholder"</span>)
        }
    }
}</code></pre><p>Next, let’s add an instance of the above <code>ImagePlaceholder</code>, as well as a description text, to our main <code>ContentView</code> — which will now contain the final set of views that we’ll display as part of our event screen:</p><pre data-preview="short-description"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-string">"This is a description"</span>)
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>The result of the above code (which you can show a preview of using the <code>PREVIEW</code> button) shows us one really interesting aspect of SwiftUI’s various shapes — just like spacers, they always occupy as much space as they can. So, given that our description text is currently very short, our image placeholder ends up stretching itself to take up a quite substantial part of the screen.</p><p>Now let’s see what would happen if we were to change that by making our description much longer — for example by repeating the same text that we used above 50 times, like this:</p><pre data-preview="long-description"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}

<span class="s-keyword">private extension</span> <span class="s-type">ContentView</span> {
    <span class="s-keyword">func</span> makeDescription() -&gt; <span class="s-type">String</span> {
        <span class="s-type">String</span>(repeating: <span class="s-string">"This is a description "</span>, count: <span class="s-number">50</span>)
    }
}</code></pre><p>This is where things are starting to get <em>really interesting</em>. Not only does the SwiftUI layout system truncate our now much longer text, it also truncates the text of our trailing <code>EventInfoBadge</code> at the bottom of the screen — all while still giving a substantial part of the available space to our <code>ImagePlaceholder</code> (which, ironically, is the view that is arguably best suited to be resized in this scenario).</p><p><em>So what’s going on here?</em> It all comes down to how SwiftUI’s fundamental layout rules (which we took a look at in <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a>) work — in that each view is responsible for determining its own size, and only <em>after that</em> is each parent deciding how to position and fit its children within its own frame.</p><p>As a result, since our <code>ImagePlaceholder</code> and our description text are now both requesting frames that are much larger than what could simultaneously fit within our <code>VStack</code> — the layout system is forced to compromise, by first compressing each view as much as possible (which is what causes our <code>EventInfoBadge</code> to get truncated), and then splitting the available space evenly among its children.</p><p>Thankfully, SwiftUI ships with a number of tools that we can use to resolve the above sort of layout conflicts — without having to resort to things like manually drawing each of our views ourselves, or by <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match/">escaping</a> into UIKit or AppKit land.</p><h2>Layout priorities</h2><p>Let’s start by taking a look at <em>layout priorities</em>, which enable us to tell the SwiftUI layout system which views that are the most (or least) important in terms of respecting their preferred sizes. Each view starts out with a layout priority of zero, which can then either be reduced or increased by applying the <code>layoutPriority()</code> modifier. Here’s how we could do just that to give our description a slightly higher priority:</p><pre data-preview="description-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())<span class="highlight">.<span class="s-call">layoutPriority</span>(<span class="s-number">1</span>)</span>
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p class="info">Note that there’s no need to go to extremes and use layout priority values like <code>999</code> or <code>.infinity</code> — any value larger than zero will have an impact on our layout.</p><p>The above tweak definitely makes our view look nicer (again, you can use the <code>PREVIEW</code> button to see what it currently looks like) — with our description now getting a much larger portion of the available space. However, our trailing <code>EventInfoBadge</code> still remains squashed, and our image placeholder now has a much smaller height.</p><p>One way to fix that <code>EventInfoBadge</code> problem would be to do the inverse of what we did above, and <em>lower</em> our image placeholder’s layout priority, rather than <em>increasing</em> the one for our description — like this:</p><pre data-preview="image-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()<span class="highlight">.<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)</span>
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>That’s once again better, but our image placeholder still gets shrunken down to its absolutely smallest height (equal to the line height of its text), which doesn’t look great. To resolve that issue, let’s also give our placeholder a minimum height using the <code>.frame()</code> modifier:</p><pre data-preview="image-min-height"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                <span class="highlight">.<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)</span>
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Our image placeholder now looks great, and so does our description text — however, our <code>EventInfoBadge</code> text once again gets truncated. To solve that final issue, let’s raise the layout priority of our <code>EventInfoList</code>, to tell the layout system to prioritize its height above all else:</p><pre data-preview="info-list-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()<span class="highlight">.<span class="s-call">layoutPriority</span>(<span class="s-number">1</span>)</span>
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>SwiftUI’s layout priorities system is a simple yet powerful tool that enables us to specify an explicit order in which our views get laid out — which can help us resolve conflicts in terms of how our views get resized to fit within the space that’s available.</p><h2>Fixed dimensions</h2><p>One issue with layout priorities, however, is that applying them can occasionally feel like playing a game of <em>“Whack-a-mole”</em> — in that for every tweak and fix that we apply, a new issue pops up. We already saw that starting to happen above, when we had to both raise and lower layout priorities in response to various issues.</p><p>So while adjusting a view’s layout priority can be a great way to apply one-off fixes, it’s thankfully not the <em>only</em> tool that lets us tweak SwiftUI’s layout behaviors. Another of those tools is the <code>fixedSize()</code> modifier, which (like the name implies) enables us to <em>fix</em> a view’s size at either its preferred width or height (or both).</p><p>Using that modifier, we can achieve the exact same result as in the previous example, only this time without having to introduce additional layout priorities (except the image placeholder one) — by giving our <code>EventInfoList</code> a fixed vertical size, which prevents it from being compressed:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()<span class="highlight">.<span class="s-call">fixedSize</span>(horizontal: <span class="s-keyword">false</span>, vertical: <span class="s-keyword">true</span>)</span>
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>To further illustrate how the <code>fixedSize()</code> modifier works, let’s see w<span class="highlight">hat would happen if we were to also give our <code>EventInfoList</code> a fixed <em>horizontal</em> size as well:</p><pre data-preview="info-list-fixed-width"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>().<span class="s-call">fixedSize</span>(horizontal: <span class="s-keyword">true</span>,</span> vertical: <span class="s-keyword">true</span>)
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>As the preview of the above example shows us, fixing our info list’s width causes the entire <code>ContentView</code> to get stretched beyond the bounds of the screen, which might initially seem quite odd.</p><p>The reason for that is, since we’re now preventing the layout system from adjusting the width of our <code>EventInfoList</code>, our root <code>VStack</code> will be forced to stretch itself to occupy that same large width (since a stack always resizes itself to fit all of its children within it) — which in turn gives the rest of our subviews more horizontal space, even though that space is partly out of bounds.</p><h2>Custom alignment guides</h2><p>Finally, let’s take a look at using custom alignment guides, and how they can be a great alternative to using other forms of alignment tools — such as <em>padding</em> and <em>offset</em>. For that, we’re going to go back to our <em>verified badge</em> from <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1/%23zstacks-and-offset">part one</a>, which — as a quick reminder — we ended up implementing as a <code>View</code> extension using a <code>ZStack</code> and the <code>.offset()</code> modifier:</p><pre data-preview="calendar-initial"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">offset</span>(x: <span class="s-number">3</span>, y: -<span class="s-number">3</span>)
            }
        }
    }
}</code></pre><p>While the above code definitely works, it does make certain assumptions about the size of the badge that we’ll end up displaying — as our offset is currently hard-coded to 3x3 points, irrespective of the size of the image that the system will render.</p><p>To address that issue, let’s replace our use of the <code>.offset()</code> modifier with two custom alignment guides. By applying the <code>.alignmentGuide()</code> modifier to a view, we can tweak how it gets positioned when a given horizontal or vertical alignment is used, using a custom computation closure.</p><p>Since our <code>ZStack</code> currently uses the <code>.topTrailing</code> alignment, let’s use that set of alignments to tweak our badge’s position, by placing its center according to those two guides — like this:</p><pre data-preview="calendar-alignment-guides"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">HorizontalAlignment</span>.<span class="s-property">trailing</span>) {
                        $0[<span class="s-type">HorizontalAlignment</span>.<span class="s-property">center</span>]
                    }
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">VerticalAlignment</span>.<span class="s-property">top</span>) {
                        $0[<span class="s-type">VerticalAlignment</span>.<span class="s-property">center</span>]
                    }
            }
        }
    }
}</code></pre><p>The result of the above looks fine, but not as nice as our view previously looked when it was using a hard-coded set of metrics. Essentially, we want to slightly offset our badge image towards the center of the calendar icon itself, to make it feel more <em>attached</em> to its host view.</p><p>To make that happen in a way that doesn’t involve any fixed offset values, let’s perform our alignment using a percentage of our badge image’s width and height, rather than using its center. That’s quite easily done, since the <code>ViewDimensions</code> context that is passed into each custom alignment guide’s closure also contains the width and height of the view that is being aligned:</p><pre data-preview="calendar-final"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">HorizontalAlignment</span>.<span class="s-property">trailing</span>) {
                        $0.<span class="s-property">width</span> * <span class="s-number">0.8</span>
                    }
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">VerticalAlignment</span>.<span class="s-property">top</span>) {
                        <span class="s-comment">// Here we first align our view's bottom edge
                        // according to its host view's top edge,
                        // and we then subtract 80% of its height.</span>
                        $0[.<span class="s-dotAccess">bottom</span>] - $0.<span class="s-property">height</span> * <span class="s-number">0.8</span>
                    }
            }
        }
    }
}</code></pre><p class="info">One small difference between this approach and our previous offset-based one is that the badge will now be included when computing its host view’s overall frame, which doesn’t make much of a difference in this case, and can be avoided by giving the badge a negative layout priority.</p><p>While custom alignment guides are really powerful, they’re quite <em>“heavy”</em> in terms of syntax — so rather than keeping the above modifiers inline, let’s move them to a new <code>View</code> extension that can be applied to any view that we wish to align as a badge:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> alignAsBadge(withRatio ratio: <span class="s-type">CGFloat</span> = <span class="s-number">0.8</span>,
                      alignment: <span class="s-type">Alignment</span> = .<span class="s-dotAccess">topTrailing</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">alignmentGuide</span>(alignment.<span class="s-property">horizontal</span>) {
            $0.<span class="s-property">width</span> * ratio
        }
        .<span class="s-call">alignmentGuide</span>(alignment.<span class="s-property">vertical</span>) {
            $0[.<span class="s-dotAccess">bottom</span>] - $0.<span class="s-property">height</span> * ratio
        }
    }
}</code></pre><p>With the above extension in place, we can now heavily simplify our verified badge implementation to instead look like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignAsBadge</span>()
            }
        }
    }
}</code></pre><p>So the <code>.alignmentGuide()</code> modifier enables us to override and adjust how a view gets aligned given either a horizontal or vertical alignment — which can be really useful when either building completely custom layouts, or when tweaking how a single view gets positioned. There’s also an API that enables us to define <em>completely custom</em> alignments (by implementing an <code>AlignmentID</code>), which we might take a closer look at in a future article.</p><h2>Conclusion</h2><p>We’ve now reached the end of this three-part guide to the SwiftUI layout system. I hope that you enjoyed it, and that it has given you new insights into how the SwiftUI layout system works, and the various APIs and tools that can be used to customize its behaviors.</p><p>While my goal was definitely to make this guide as thorough as possible, there are of course many different aspects of the SwiftUI layout system that it didn’t cover — so I’m sure that we’ll revisit this topic again, perhaps sooner rather than later.</p><p>But for now, let’s again recap what was covered in this third and final part of this series:</p><ul><li>Adjusting <em>layout priorities</em> can be a great way to tweak how each view gets prioritized in terms of its preferred size.</li><li>Applying a <em>fixed frame size</em> to a view prevents it from being resized either horizontally or vertically (or both).</li><li>Custom alignment guides let us adjust how a view gets positioned when a given alignment is used, which can be really useful when we want to position one view in relation to another.</li></ul><p>Although I’ve written <a href="https://www.swiftbysundell.com/tags">hundreds of articles</a> for this site, this was the first code-along guide that I’ve ever made, so I’d love to hear your feedback on it — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>. You’re also more than welcome to ask me any questions that you might have, and if you enjoyed this series, feel free to share it with others — I’d <em>really</em> appreciate that.</p><p>You can also find a ton of other freely available SwiftUI content on <a href="https://www.swiftbysundell.com/tags/swiftui">this category page</a>. Next Sunday, we’ll explore a brand new topic — which won’t be related to SwiftUI, I promise.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/protocols</guid><title>Basics: Protocols</title><description>What makes Swift a protocol-oriented language, and how can protocols be used to create abstractions and to enable code reuse? That’s what we’ll take a look at in this Basics article.</description><link>https://www.swiftbysundell.com/basics/protocols</link><pubDate>Fri, 3 Apr 2020 19:10:00 +0200</pubDate><content:encoded><![CDATA[<p>While many languages support the concept of protocols (or <em>“Interfaces”</em> as they’re also often called), Swift treats protocols as a true cornerstone of its overall design — with Apple even going so far as to call Swift a <em>“protocol-oriented programming language”</em>.</p><p>Essentially, protocols enable us to define APIs and requirements without tying them to one specific type or implementation. For example, let’s say that we’re working on some form of music player, and that we’ve currently implemented our playback code as two separate methods within a <code>Player</code> class — one for playing songs, and one for playing albums:</p><pre class="splash"><code><span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: song.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> album: <span class="s-type">Album</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: album.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }
}</code></pre><p>Looking at the above implementation, we definitely have a fair amount of code duplication, since both of our <code>play</code> methods need to do more or less the exact same thing — convert the resource that is being played into an <code>AVPlayerItem</code> and then play it using an <code>AVPlayer</code> instance.</p><p>That’s one of the kinds of problems that protocols can help us solve in a much more elegant manner. To get started, let’s define a new protocol called <code>Playable</code>, which will <em>require each type that’s conforming to it</em> to implement an <code>audioURL</code> property:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Playable {
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">The above <code>get</code> keyword is used to specify that in order to conform to our new protocol, a type only needs to declare a read-only <code>audioURL</code> property — it doesn’t have to be writable.</p><p>We can then make different types <em>conform</em> to our new protocol in two ways. One way is to declare the conformance as part of the type declaration itself — for example like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Song: <span class="s-type"><span class="highlight">Playable</span></span> { 
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> album: <span class="s-type">Album</span>
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span>
}</code></pre><p>The other way is to declare conformance through an extension — which can simply be done using an empty extension in case a type already meets all of the protocol’s requirements (which is the case for our <code>Album</code> model below):</p><pre class="splash"><code><span class="s-keyword">struct</span> Album {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type"><span class="highlight">Playable</span></span> {} </code></pre><p>With the above changes in place we can now simplify our <code>Player</code> class quite a lot — by merging our two previous <code>play</code> methods into one that, rather than accepting a <em>concrete type</em> (such as <code>Song</code> or <code>Album</code>), now accepts <em>any type</em> that conforms to our new <code>Playable</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">Playable</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: resource.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }
}</code></pre><p>That’s much nicer! However, there is one tiny issue with our above protocol, and that’s its name. While <code>Playable</code> might’ve initially seemed like an appropriate name, it sort of indicates that the types conforming to it can actually <em>perform playback</em>, which isn’t the case. Instead, since our protocol is all about <em>converting an instance into an audio URL</em>, let’s rename it to <code>AudioURLConvertible</code> — to make things crystal clear:</p><pre class="splash"><code><span class="s-comment">// Renaming our declaration:</span>
<span class="s-keyword">protocol</span> AudioURLConvertible {
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}

<span class="s-comment">// Song's conformance to it:</span>
<span class="s-keyword">struct</span> Song: <span class="s-type">AudioURLConvertible</span> {
    ...
}

<span class="s-comment">// The Album extension:</span>
<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type">AudioURLConvertible</span> {}

<span class="s-comment">// And finally how we use it within our Player class:</span>
<span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>) {
        ...
    }
}</code></pre><p>On the flip side of the coin, let’s now take a look at a protocol that <em>does</em> require an action (or in other words, a method), which makes it a nice fit for the typical <em>“-able”</em> naming suffix. In this case we’ll require a <em>mutating</em> method, since we want to enable any types conforming to our protocol to <em>mutate their own state</em> (that is, change property values) within their implementations:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Likeable {
    <span class="s-keyword">mutating func</span> markAsLiked()
}

<span class="s-keyword">extension</span> <span class="s-type">Song</span>: <span class="s-type">Likeable</span> {
    <span class="s-keyword">mutating func</span> markAsLiked() {
        isLiked = <span class="s-keyword">true</span>
    }
}</code></pre><p>Since most types that will conform to our new <code>Likeable</code> are likely (no pun intended) to implement our <code>markAsLiked</code> method requirement the exact same way as <code>Song</code> does, we might also choose to make that <code>isLiked</code> property our requirement instead (and also require it to be mutable by adding the <code>set</code> keyword).</p><pre class="splash"><code><span class="s-keyword">protocol</span> Likeable {
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span> { <span class="s-keyword">get set</span> }
}</code></pre><p>The cool thing is that, if we still want our API to be <code>something.markAsLiked()</code>, then we can easily make that happen using a <em>protocol extension</em> — which enable us to add new methods and computed properties to all types that conforms to a given protocol:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Likeable</span> {
    <span class="s-keyword">mutating func</span> markAsLiked() {
        isLiked = <span class="s-keyword">true</span>
    }
}</code></pre><p class="info">For more information about the <code>mutating</code> keyword, and a broader discussion around value and reference types, check out <a href="https://www.swiftbysundell.com/basics/value-and-reference-types/">this Basics article</a>.</p><p>With the above in place, we can now make both <code>Song</code> and <code>Album</code> conform to <code>Likeable</code> without having to write any additional code — since they both already declare an <code>isLiked</code> property that’s mutable:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Song</span>: <span class="s-type">Likeable</span> {}
<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type">Likeable</span> {}</code></pre><p>Besides enabling code reuse and unifying similar implementations, protocols can also be really useful when refactoring, or when we want to conditionally replace one implementation with another.</p><p>As an example, let’s say that we wanted to test a new implementation of our <code>Player</code> class from before — that enqueues songs and other playback items, rather than immediately starting to play them. One way to do that would of course be to add that logic to our original <code>Player</code> implementation, but that could quickly get messy — especially if we want to perform multiple tests and try out more kinds of variations.</p><p>Instead, let’s <em>create an abstraction</em> for our core playback API by implementing a protocol for it. In this case, we’ll simply name it <code>PlayerProtocol</code>, and make it require our single <code>play</code> method from before:</p><pre class="splash"><code><span class="s-keyword">protocol</span> PlayerProtocol {
    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>)
}</code></pre><p>Using our new protocol, we’re now free to implement as many different variants of our player as we wish — each of which can have their own private implementation details, while still being compatible with the exact same public API:</p><pre class="splash"><code><span class="s-keyword">class</span> EnqueueingPlayer: <span class="s-type">PlayerProtocol</span> {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVQueuePlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: resource.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">insert</span>(item, after: <span class="s-keyword">nil</span>)
        avPlayer.<span class="s-call">play</span>()
    }
}

<span class="s-keyword">extension</span> <span class="s-type">Player</span>: <span class="s-type">PlayerProtocol</span> {}</code></pre><p>With the above in place, we can now conditionally use either of our player implementations by making whichever code that creates the app’s player return a <code>PlayerProtocol</code> conforming-instance, rather than a concrete type:</p><pre class="splash"><code><span class="s-keyword">func</span> makePlayer() -&gt; <span class="s-type">PlayerProtocol</span> {
    <span class="s-keyword">if</span> <span class="s-type">Settings</span>.<span class="s-property">useEnqueueingPlayer</span> {
        <span class="s-keyword">return</span> <span class="s-type">EnqueueingPlayer</span>()
    } <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-type">Player</span>()
    }
}</code></pre><p>Finally, let’s go back to that initial statement of Swift being a <em>“protocol-oriented language”</em>. So far in this article, we’ve seen that Swift does indeed support many powerful protocol-based features — but what actually makes the language itself <em>protocol-oriented</em>?</p><p>In many ways, it comes down to how the standard library is designed — which leverages features like protocol extensions to both optimize its own internal implementation, and to enable us to write our own functionality on top of its many protocols using those same extensions.</p><p>As an example, here’s how we could take the standard library’s <code>Collection</code> protocol (which all collections, such as <code>Array</code> and <code>Set</code>, conform to) and give it a <code>sum</code> method whenever the elements that are being stored conform to <code>Numeric</code> — which is yet another standard library protocol that numeric types, such as <code>Int</code> and <code>Double</code>, conform to:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Collection</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Numeric</span> {
    <span class="s-keyword">func</span> sum() -&gt; <span class="s-type">Element</span> {
        <span class="s-comment">// The reduce method is implemented using a protocol extension
        // within the standard library, which in turn enables us
        // to use it within our own extensions as well:</span>
        <span class="s-call">reduce</span>(<span class="s-number">0</span>, +)
    }
}</code></pre><p class="info">To learn more about why we’re able to pass the <code>+</code> operator directly to <code>reduce</code>, check out the <a href="https://www.swiftbysundell.com/clips/1">Swift Clips episode about first class functions</a>.</p><p>With the above in place, we can now easily sum up any collection of numbers, for example an array of <code>Int</code> values:</p><pre class="splash"><code><span class="s-keyword">let</span> numbers = [<span class="s-number">1</span>, <span class="s-number">2</span>, <span class="s-number">3</span>, <span class="s-number">4</span>]
numbers.<span class="s-call">sum</span>() <span class="s-comment">// 10</span></code></pre><p>So what makes protocols so incredibly useful is both that they enable us to create abstractions that let us hide implementation details behind shared interfaces — which in turn makes it easier to share code that uses those interfaces — and also that they enable us to customize and extend the standard library’s various APIs.</p><p>Protocols also have many more aspects and features that this Basics article didn’t cover (such as how they relate to testing and architecture). For a brief look at generic protocols, check out the <a href="https://www.swiftbysundell.com/basics/generics">Basics article about generics</a> — and for other kinds of protocol-focused content, check out <a href="https://www.swiftbysundell.com/tags/protocols">this list</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/indie-support-weeks</guid><title>Indie Support Weeks</title><description>A two-week effort to help support indie developers shipping apps on Apple’s platforms who have been financially impacted by the COVID-19 pandemic.</description><link>https://www.swiftbysundell.com/special/indie-support-weeks</link><pubDate>Mon, 30 Mar 2020 11:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Independent app development has been an incredibly important part of the Apple developer community for decades. Not only do indie apps provide a ton of utility and delight for countless users around the world, they’re also often a major source of innovation on Apple’s platforms and beyond.</p><p>However, while working on your own projects can be greatly rewarding, being an indie developer can at times also be really difficult. Working alone or with a small team on increasingly sophisticated products can occasionally feel overwhelming, and without the financial security that a major company often provides — every new project, feature, and release always comes with a certain amount of personal risk.</p><p>Right now, there’s no doubt that the global COVID-19 pandemic is causing tremendous amounts of uncertainty, hardship and suffering all around the world. There’s an enormous number of people who need help and support, and although many tech workers have been fortunate enough to be able to keep working remotely with (in the grand scheme of things) relative ease — it’s times like these that can prove to be extra challenging for those who run their own independent business.</p><p>As people are self-isolating around the world, businesses are closing, and many of our normal day-to-day activities are put on hold, many indie developers have seen their sales numbers take a big hit. For some developers, who rely on the income from their apps as the main way to support themselves and their families, this loss of revenue can lead to tricky and difficult situations, to say the least.</p><p>When it comes to providing support and helping others in situations like this, it’s quite common to feel a bit <em>overwhelmed</em>. No single person can stop the current pandemic by themselves, or solve all of the world’s problems. No one can do everything. But everyone can do <em>something</em>.</p><p>So I decided that I wanted to do something for our community’s indies.</p><p>Normally, this site (and all of my other work) is funded by <a href="https://www.swiftbysundell.com/sponsor">sponsorships</a> — through non-tracking, privacy-focused (and JavaScript-free) ads that I run on a weekly basis. But for the next two weeks there will be no ads on this site. Instead, each day, I’ll promote a new indie app whose developer has been financially impacted by the current pandemic. For free, with no strings attached.</p><p>I hope that, with your support, these indie developers will regain some of that lost revenue through this effort, and that we will all get to discover a few great new apps as well.</p><p>Now, I was originally only planning to do this by myself — just on this site, and for one week only. However, when I <a href="https://twitter.com/johnsundell/status/1240642670688698368">announced this project on Twitter</a>, I was met with an absolutely wonderful amount of support from all over the community. Thousands of people reached out offering their support in various ways, so I decided to make this an <a href="https://github.com/JohnSundell/indiesupportweeks">open effort</a> that anyone can now join.</p><p>Among the people who reached out to offer their support was <a href="https://twitter.com/_sa_s">Sven A. Schmidt</a>, creator of the indie app <a href="https://finestructure.co/hummingbird">Hummingbird</a>, who made an incredibly generous offer — to help me pay for the weekly expenses of running this site so that I could extend this effort to two weeks instead of just one. So, thanks to Sven, I’ll be able to help promote twice the amount of indie apps than I originally thought — which I’m incredibly grateful for.</p><p><em>Now, Sven didn’t tell me to do this, but I also want to give a special shoutout to his fantastic app <a href="https://finestructure.co/hummingbird">Hummingbird</a>, which I personally use to make managing my Mac’s windows so much easier when working on a laptop. I highly recommend it.</em></p><p>So welcome to <em>Indie Support Weeks</em> — two weeks during which you’ll see indie apps being promoted by various channels all around the Apple developer community. Feel free to return to this site each day during these two weeks to find a new fantastic indie app, and if you see an app that you find interesting, please check it out to support its developer.</p><p>Also, I’d love to see you share your own <a href="https://github.com/JohnSundell/indiesupportweeks#apps">favorite indie apps</a> on Twitter and other social networks — and if you do, feel free to use the hashtag <a href="https://twitter.com/hashtag/indiesupportweeks"><code>#IndieSupportWeeks</code></a> to make those tweets and posts easier to find for everyone who’s following this effort.</p><p>Thanks for reading, and I hope that you’ll enjoy Indie Support Weeks! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2</guid><title>A guide to the SwiftUI layout system - Part 2</title><description>Let’s continue exploring the SwiftUI layout system by taking a look at a couple of more advanced techniques, such as how we can align views with dynamic dimensions and how to read a view’s geometry in order to build custom layouts.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2</link><pubDate>Sun, 29 Mar 2020 18:57:00 +0200</pubDate><content:encoded><![CDATA[<p>Let’s pick up where we left off <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">last week</a>, and continue to explore the SwiftUI layout system and how its various APIs and concepts work. This week, we’ll take a look at a couple of more advanced techniques — such as how we can align views with dynamic dimensions and how to read a view’s surrounding geometry in order to build completely custom layouts.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was (just like <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a>) written to enable you to easily code along within a SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted, except for the views that were built during part one.</p><h2>Handling dynamic content</h2><p>While certain parts of an app’s UI might be relatively static and predictable in terms of their content, chances are high that the majority of the views that we’ll display within any given app are going to be highly dynamic.</p><p>Not only do we often have to account for content that’s not known at compile-time (for example text and images downloaded from a server), we also have to make sure that our views scale well according to localized strings and other resources that might differ depending on the environment that our app is run in.</p><p>Thankfully, SwiftUI was designed around the fact that most modern apps are indeed very dynamic — and will automatically adapt the views that we declare according to their content, their environment (taking things like the current device size and color scheme into account), and other factors. However, sometimes we might need to make a few tweaks and adjustments to enable SwiftUI to scale and position our views exactly the way we want.</p><p>As an example, let’s continue working on our event view from <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">last week</a>, by adding a row of <em>“info badges”</em> at the bottom of the screen — which will display certain information about the current event to the user. To get started, we’ll write a simple <code>EventInfoBadge</code> view using some of the layout techniques that were covered in part one — such as using a <code>VStack</code> to group two views vertically, as well as rendering a system icon with a fixed size:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p>In isolation, the above implementation looks perfectly fine. However, if we now try to render a horizontal row consisting of three <code>EventInfoBadge</code> instances at the bottom of our <code>ContentView</code>, things won’t look as nice as we might’ve expected:</p><pre data-preview="info-badge-row-first-iteration"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
            <span class="s-type">HStack</span> {
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"video.circle.fill"</span>,
                    text: <span class="s-string">"Video call available"</span>
                )
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"doc.text.fill"</span>,
                    text: <span class="s-string">"Files are attached"</span>
                )
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                    text: <span class="s-string">"Invites allowed"</span>
                )
            }
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p class="info">We’re again hard-coding all of our view’s strings and images, since this article is entirely focused on the SwiftUI layout system, and won’t cover data binding.</p><p>We have two main problems (which you can see by using the <em>Preview</em> button above) — first, our icons are scaled using an incorrect aspect ratio, making them look stretched. Second, since each of our info badges are rendering different strings, they’ll end up getting different widths — which makes our UI look quite uneven.</p><p>Let’s first fix our icon stretching problem by applying the <code>.aspectRatio()</code> modifier to our <code>Image</code> — telling it to fit its content into its bounds when resized, like this:</p><pre data-preview="aspect-ratio-fix"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                <span class="highlight">.<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)</span>
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p>Next, to make our three info badges occupy the same amount of horizontal space within our <code>ContentView</code>, we need to make each badge take up as much space as it possibly can within its container. That’ll force the parent view (our bottom <code>HStack</code> in this case) to evenly divide the available space among each of its children, rather than giving the most space to the child with the longest text.</p><p>To make that happen, let’s give the <code>Text</code> within our <code>EventInfoBadge</code> an infinite max width — which will make the layout system scale it as much as possible on the horizontal axis before splitting it up into multiple lines:</p><pre data-preview="text-fix"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                <span class="highlight">.<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)</span>
        }
    }
}</code></pre><p>With the above two fixes in place, our view now looks a lot nicer — so let’s wrap our <code>EventInfoBadge</code> implementation up by center-aligning its text and by giving it some padding, a background color, and rounded corners:</p><pre data-preview="improved-visuals"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                .<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)
                .<span class="s-call">multilineTextAlignment</span>(.<span class="s-dotAccess">center</span>)
        }
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">vertical</span>, <span class="s-number">10</span>)
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">horizontal</span>, <span class="s-number">5</span>)
        .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
        .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
    }
}</code></pre><p>Finally, let’s again follow the same practice as we did during part one, and move our list of info badges out from our <code>ContentView</code> and into a new stand-alone component — to prevent our content view from <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">becoming massive</a>:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled"</span>
            )
        }
    }
}</code></pre><p>Rather than creating the above <code>HStack</code> inline within our <code>ContentView</code>, we can now simply initialize an instance of <code>EventInfoList</code> and we’re good to go:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Plus, if we ever want to render the same type of list elsewhere within our app, we’ll now be able to easily do that.</p><h2>Geometry, preferences, and layout dependencies</h2><p>However, it turns out that our <code>EventInfoBadge</code> still has one remaining issue. While our current implementation handles dynamic text lengths in terms of <em>width</em>, we still have to address the fact that our badges might end up with different <em>heights</em> — for example if we make one of our texts slightly longer:</p><pre data-preview="vertical-issue"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string"><span class="highlight">"Invites enabled, 5 people maximum"</span></span>
            )
        }
    }
}</code></pre><p>The above result might not be a deal-breaker, but our UI would arguably look a lot nicer if we instead were able to give each of our badges the exact same height. To make that happen, we’ll have to come up with a way to notify our <code>EventInfoList</code> of the maximum height among its children, so that it then can resize the remaining child views to also occupy that same vertical space.</p><p>Since this is a piece of functionality that we’ll likely want to reuse in different parts of our app (or even between projects), let’s implement it as a new stand-alone view called <code>HeightSyncedRow</code>. We’ll start by using the <code>@ViewBuilder</code> <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builder</a> attribute to enable our new view to be used with the same <a href="https://www.swiftbysundell.com/articles/building-dsls-in-swift">DSL</a>-like syntax that SwiftUI’s built-in containers and stacks are using. We’ll then assign a <code>childHeight</code> to the result of that DSL expression, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">frame</span>(height: childHeight)
        }
    }
}</code></pre><p>The great thing about using the same <code>@ViewBuilder</code> attribute as SwiftUI’s built-in views is that we can now go back to our <code>EventInfoList</code> and simply replace its <code>HStack</code> with our new <code>HeightSyncedRow</code> — without having to make any additional changes:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type"><span class="highlight">HeightSyncedRow</span></span> { 
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled, 5 people maximum"</span>
            )
        }
    }
}</code></pre><p>Next, let’s compute the <code>childHeight</code> value that our <code>HeightSyncedRow</code> will assign to each of its children. To do that, we’re going to make each child report its current height upwards through the view hierarchy, by using SwiftUI’s <em>Preferences system</em> — that enables us to associate a given value with a preference key within a child view, which can then later be read within one of its parents.</p><p>Doing so first requires us to implement a <code>PreferenceKey</code>, which both includes the preference’s <code>defaultValue</code>, as well as a method for reducing two values (the previous and next) into one — like this:</p><pre class="splash"><code><span class="s-keyword">private struct</span> HeightPreferenceKey: <span class="s-type">PreferenceKey</span> {
    <span class="s-keyword">static let</span> defaultValue: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">static func</span> reduce(value: <span class="s-keyword">inout</span> <span class="s-type">CGFloat</span>,
                       nextValue: () -&gt; <span class="s-type">CGFloat</span>) {
        value = <span class="s-call">nextValue</span>()
    }
}</code></pre><p>Next, we’re going to use SwiftUI’s <code>GeometryReader</code> type — which is a view that, among other things, enables us to read the size of the current view’s container. By embedding a <code>GeometryReader</code> as a given view’s <code>background</code>, we can perform that sort of reading without affecting that view’s layout in any way — as a background view will always just occupy the same frame as the view that it’s attached to.</p><p>Finally, we’ll wrap all of that functionality into a <code>View</code> extension that enables us to sync any view’s height into a given <code>Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> — which gives us this implementation:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> syncingHeightIfLarger(than height: <span class="s-type">Binding</span>&lt;<span class="s-type">CGFloat</span>?&gt;) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">background</span>(<span class="s-type">GeometryReader</span> { proxy <span class="s-keyword">in</span>
            <span class="s-comment">// We have to attach our preference assignment to
            // some form of view, so we just use a clear color
            // here to make that view completely transparent:</span>
            <span class="s-type">Color</span>.<span class="s-property">clear</span>.<span class="s-call">preference</span>(
                key: <span class="s-type">HeightPreferenceKey</span>.<span class="s-keyword">self</span>,
                value: proxy.<span class="s-property">size</span>.<span class="s-property">height</span>
            )
        })
        .<span class="s-call">onPreferenceChange</span>(<span class="s-type">HeightPreferenceKey</span>.<span class="s-keyword">self</span>) {
            height.<span class="s-property">wrappedValue</span> = <span class="s-call">max</span>(height.<span class="s-property">wrappedValue</span> ?? <span class="s-number">0</span>, $0)
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>HeightSyncedRow</code> and simply make it apply our new <code>syncingHeightIfLarger</code> modifier to its <code>content</code> view — which in turn will make each of its children adopt the exact same height:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content<span class="highlight">.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)</span>
                   .<span class="s-call">frame</span>(height: childHeight)
        }
    }
}</code></pre><p>However, if we now render our main <code>ContentView</code> again, we won’t actually be able to tell that all of our info badges have the same height — since we’re applying the <code>.frame()</code> modifier <em>after</em> we’ve given each of our info badges their background color. To illustrate that problem we can again use the classic <em>“red background color trick”</em>, just like we did in part one:</p><pre data-preview="vertical-sync"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)
                   .<span class="s-call">frame</span>(height: childHeight)
                   <span class="highlight">.<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)</span>
        }
    }
}</code></pre><p>Now, to fix the problem, let’s move our background assignment out from <code>EventInfoBadge</code> and into our <code>HeightSyncedRow</code> instead. That way, we’ll be able to first assign each view’s frame, and then add its background — which will give all of our background views the correct size. To still let <code>HeightSyncedRow</code> remain a reusable component, let’s add support for injecting a <code>Background</code> view as part of its initializer, which we’ll then assign to each child — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Background: <span class="s-type">View</span>, Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> background: <span class="s-type">Background</span>
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(background: <span class="s-type">Background</span>,
         <span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">background</span> = background
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)
                   .<span class="s-call">frame</span>(height: childHeight)
                   .<span class="s-call">background</span>(background)
        }
    }
}</code></pre><p>With the above in place, let’s now go back to <code>EventInfoList</code> and update it to pass the background view from <code>EventInfoBadge</code> when creating its <code>HeightSyncedRow</code> — like this:</p><pre data-preview="streched-backgrounds"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HeightSyncedRow</span>(background: <span class="s-type">Color</span>.<span class="s-property">secondary</span>.<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)) {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled, 5 people maximum"</span>
            )
        }
    }
}</code></pre><p>Now all that remains is to remove the background assignment from our <code>EventInfoBadge</code> and our implementation will be complete:</p><pre data-preview="finished"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                .<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)
                .<span class="s-call">multilineTextAlignment</span>(.<span class="s-dotAccess">center</span>)
        }
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">vertical</span>, <span class="s-number">10</span>)
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">horizontal</span>, <span class="s-number">5</span>)
    }
}</code></pre><p>What we essentially had to deal with during this whole exercise is <em>layout dependencies</em> — when one view’s layout depends on another view somehow. In our case, we couldn’t determine the final frame of each <code>EventInfoBadge</code> before first knowing the maximum height among them.</p><p>While layout dependencies should arguably be avoided whenever possible (as they tend to make our views quite tightly coupled), sometimes it’s necessary to establish a chain of communication between a set of child views and their parent — and if we can do that through generic abstractions (such as the <code>HeightSyncedRow</code> that we built), then we can often find a way to manage our layout dependencies in a way that still makes our code modular and easy to change.</p><h2>Conclusion</h2><p>That concludes part two of this guide to the SwiftUI layout system. Next week, we’ll wrap up this series by taking a look at how we can make our views scale even better across multiple screen sizes, and how to define layout priorities and even more custom layouts. But for now, let’s summarize what we covered in this part:</p><ul><li>The <code>.aspectRatio()</code> modifier lets us adjust how a view’s content gets scaled as the view is resized. It’s particularly useful for images.</li><li>Using <code>.frame(maxWidth: .infinity)</code> (or its height equivalent) can be a great way to tell a view to occupy as much space as it can within a given dimension — which in turn can be used to “force” its parent to divide all available space evenly among its children.</li><li><code>GeometryReader</code> is a special view that reads its surrounding geometry, and lets us build custom layouts accordingly.</li><li>Using SwiftUI’s Preferences system, we can communicate upwards through a view hierarchy, for example in order to notify a parent of a child view’s computed size.</li></ul><p>I hope you enjoyed the second part of this series. If you did, feel free to share this article with a friend or on social media (that really helps support my work). Also, let me know if you have any questions, comments or feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p><strong><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3">You can find the third and final part of this article series here</a></strong>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/inline-wrapping-of-uikit-or-appkit-views-within-swiftui</guid><title>Tip: Inline wrapping of UIKit or AppKit views within SwiftUI</title><description></description><link>https://www.swiftbysundell.com/tips/inline-wrapping-of-uikit-or-appkit-views-within-swiftui</link><pubDate>Sat, 28 Mar 2020 19:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The fact that any UIKit or AppKit view can be wrapped in order to become SwiftUI-compatible is incredibly useful, as that sort of provides an <em>“escape hatch”</em> for whenever SwiftUI does not yet natively support a given type of control or UI element.</p><p>However, if we need to rely on a lot of (for the lack of a better term) <em>“legacy”</em> views, having to constantly write wrappers for each of them can start to become a bit tedious — especially for simpler views that don’t require any sophisticated logic, or views that we only want to use in a single place.</p><p>For example, let’s say we wanted to use <code>UIActivityIndicatorView</code> to display a loading spinner within a SwiftUI-based iOS app. In order to do that, we’d have to write a wrapper that’ll look something like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ActivityIndicator: <span class="s-type">UIViewRepresentable</span> {
    <span class="s-keyword">func</span> makeUIView(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">UIActivityIndicatorView</span> {
        <span class="s-type">UIActivityIndicatorView</span>(style: .<span class="s-dotAccess">medium</span>)
    }

    <span class="s-keyword">func</span> updateUIView(<span class="s-keyword">_</span> view: <span class="s-type">UIActivityIndicatorView</span>, context: <span class="s-type">Context</span>) {
        view.<span class="s-call">startAnimating</span>()
    }
}</code></pre><p>While writing a wrapper that conforms to <code>UIViewRepresentable</code> (or <code>NSViewRepresentable</code> on the Mac) isn’t a huge task — wouldn’t it be nice if we instead could just wrap any legacy view inline, right where we need to use it?</p><p>Let’s make that happen by writing a generic type that can be used to wrap any <code>UIView</code>. Let’s call it <code>Wrap</code>, and have it take two closures, each corresponding to one of the method requirements of <code>UIViewRepresentable</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Wrap&lt;Wrapped: <span class="s-type">UIView</span>&gt;: <span class="s-type">UIViewRepresentable</span> {
    <span class="s-keyword">typealias</span> Updater = (<span class="s-type">Wrapped</span>, <span class="s-type">Context</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> makeView: () -&gt; <span class="s-type">Wrapped</span>
    <span class="s-keyword">var</span> update: (<span class="s-type">Wrapped</span>, <span class="s-type">Context</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>,
         updater update: <span class="s-keyword">@escaping</span> <span class="s-type">Updater</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = update
    }

    <span class="s-keyword">func</span> makeUIView(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">Wrapped</span> {
        <span class="s-call">makeView</span>()
    }

    <span class="s-keyword">func</span> updateUIView(<span class="s-keyword">_</span> view: <span class="s-type">Wrapped</span>, context: <span class="s-type">Context</span>) {
        <span class="s-call">update</span>(view, context)
    }
}</code></pre><p class="info">To make an equivalent generic wrapper for macOS, simply replace all instances of “UI” with “NS”.</p><p>Note the usage of <a href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis"><code>@autoclosure</code></a> above, which will enable us to keep following the conventions of <code>UIViewRepresentable</code> and create our views lazily, without requiring any additional syntax at the call sites.</p><p>However, when updating our view, our new <code>Wrap</code> type currently requires us to always handle both the view itself, and the current <code>Context</code>. While having access to the <code>Context</code> argument might be important for some use cases, let’s make it optional — by also introducing two convenience APIs that’ll let us either accept just our view as a single argument, or to opt out of updates entirely in case our view is completely static:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Wrap</span> {
    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>,
         updater update: <span class="s-keyword">@escaping</span> (<span class="s-type">Wrapped</span>) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = { view, <span class="s-keyword">_ in</span> <span class="s-call">update</span>(view) }
    }

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = { <span class="s-keyword">_</span>, <span class="s-keyword">_ in</span> }
    }
}</code></pre><p>With the above in place, we can now easily wrap any <code>UIView</code> completely inline, while also being able to update it whenever our underlying state changes — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            ...
            <span class="s-type">Wrap</span>(<span class="s-type">UIActivityIndicatorView</span>()) {
                <span class="s-keyword">if self</span>.<span class="s-property">viewModel</span>.<span class="s-property">isLoading</span> {
                    $0.<span class="s-call">startAnimating</span>()
                } <span class="s-keyword">else</span> {
                    $0.<span class="s-call">stopAnimating</span>()
                }
            }
        }
    }
}</code></pre><p>Very nice! This of course doesn’t mean that we should completely abandon building proper wrappers for certain views, but for simpler ones the above <code>Wrap</code> type is incredibly convenient.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/explicit-type-annotations</guid><title>Tip: Explicit type annotations</title><description></description><link>https://www.swiftbysundell.com/tips/explicit-type-annotations</link><pubDate>Thu, 26 Mar 2020 18:15:00 +0100</pubDate><content:encoded><![CDATA[<p>One of Swift’s most important features is, without a doubt, its type inference engine. Without it, we’d have to always explicitly specify the type of each of our variables, closure arguments, and other expressions — which would dramatically increase the verbosity of our code.</p><p>However, even though Swift’s type inference engine is incredibly powerful, sometimes it does need a bit of a helping hand — and in those situations, being able to add explicit type annotations can be really useful.</p><p>As an example, let’s take a look at a <code>Task</code> type, which enables us to run closures in the background using the <a href="https://www.swiftbysundell.com/clips/2"><code>DispatchQueue</code></a> API:</p><pre class="splash"><code><span class="s-keyword">struct</span> Task&lt;Input, Output&gt; {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Output</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> body: (<span class="s-type">Input</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Output</span>

    <span class="s-keyword">func</span> perform(with input: <span class="s-type">Input</span>,
                 on queue: <span class="s-type">DispatchQueue</span> = .<span class="s-call">global</span>(),
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        queue.<span class="s-call">async</span> {
            <span class="s-call">handler</span>(<span class="s-type">Result</span> { <span class="s-keyword">try self</span>.<span class="s-call">body</span>(input) })
        }
    }
}</code></pre><p class="info">The above type is just an example. For a much more thorough implementation of a task-based concurrency system, see <a href="https://www.swiftbysundell.com/articles/task-based-concurrency-in-swift">this article</a>.</p><p>Since the above <code>Task</code> type is a <a href="https://www.swiftbysundell.com/basics/generics">generic</a> (which is great in terms of type safety), the compiler will need to <em>specialize</em> each instance of it according to which <code>Input</code> and <code>Output</code> types are used at each given call site. While that’s exactly what the type inference engine can often take care of, completely automatically — sometimes our code might not contain enough type information for that to be possible.</p><p>For example, here we’re constructing a <code>Task</code> for loading a <code>Config</code> model over the network, by taking a <code>URL</code> as input and then returning a decoded instance of our model as output:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { url <span class="s-keyword">in
    let</span> data = <span class="s-keyword">try</span> <span class="s-type">Data</span>(contentsOf: url)
    <span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()
    <span class="s-keyword">return try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Config</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>If we try to compile the above code, the compiler will throw an error for both <code>Input</code> and <code>Output</code>, saying that neither of those two types could be inferred. So how can we fix this problem? One way is to explicitly type the <code>Task</code> instance itself, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span><span class="highlight">&lt;<span class="s-type">URL</span>, <span class="s-type">Config</span>&gt;</span> { url <span class="s-keyword">in</span>
    ...
}</code></pre><p>With the above change in place, no additional type information will be needed within our closure — since the compiler will be able to connect the <code>Input</code> and <code>Output</code> types to our closure’s parameter and return type. However, if we wanted to, we could’ve also opted to specify those closure types instead — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { <span class="highlight">(url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Config</span></span> <span class="s-keyword">in</span>
    ...
}</code></pre><p>Above we’re specifying <em>both</em> the input and output type of our closure, however, if we’re able to reduce its body to something that the compiler can more easily type-check (for example a single expression) — then we only have to specify the input type, and Swift’s type inference engine will take care of the rest:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { <span class="highlight">(url: <span class="s-type">URL</span>)</span> <span class="s-keyword">in</span>
    <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(
        <span class="s-type">Config</span>.<span class="s-keyword">self</span>,
        from: <span class="s-type">Data</span>(contentsOf: url)
    )
}</code></pre><p>The above techniques can be great to keep in mind when dealing with generic code, since they often enable us to resolve many different kinds of ambiguous type information.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1</guid><title>A guide to the SwiftUI layout system - Part 1</title><description>Let’s take a look at the SwiftUI layout system by starting to build a full-screen view from scratch. Along the way, we’ll use many different techniques and APIs, which lets us explore the underlying rules of the SwiftUI layout system.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1</link><pubDate>Sun, 22 Mar 2020 20:55:00 +0100</pubDate><content:encoded><![CDATA[<p>Along with its declarative DSL and powerful data bindings, SwiftUI also features a brand new layout system, which in many ways combines the explicitness of manual frame calculations with the adaptiveness of Auto Layout. The result is a system that may appear simple at first glance, but that offers a huge amount of flexibility and power once we start combining its various building blocks into increasingly sophisticated layouts.</p><p>This week, let’s explore the SwiftUI layout system by starting to build a full-screen view from scratch. Along the way, we’ll use many different kinds of layout techniques and APIs — which together will demonstrate what the underlying rules of the SwiftUI layout system are, and how each of those rules relate to each other.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was written to enable you to easily code along within a new SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted.</p><h2>Setting a view’s frame</h2><p>Let’s get started with a simple <code>ContentView</code> that renders a calendar image as its <code>body</code>, by referencing one of Apple’s built-in <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols</a>:</p><pre data-preview="centered-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
    }
}</code></pre><p>By default, SwiftUI lets each view pick its own size based on the container that it’s rendered in, and will then center it within its parent. So the result of the above code is a small icon rendered at the center of the screen — not at the top-left or bottom-left as we might’ve expected based on how UIKit and AppKit work.</p><p>Next, let’s make our icon a bit larger, let’s say 50x50 points. An initial idea on how to achieve that might be to use the <code>.frame()</code> <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier</a> to tell our view to adopt that size, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
    }
}</code></pre><p>However, while the above code <em>will</em> result in <em>a view</em> that’s 50x50 points, the size of our icon will remain exactly the same as it was before — which might at first seem a bit strange. To explore the reason why that is, let’s give our view a background color so that we can easily see its on-screen frame:</p><pre data-preview="framed-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>With the above in place, we can see that our view is indeed the right size — it’s just that our icon seems to be completely unaffected by our <code>.frame()</code> modifier, which is actually true. When applying a modifier to a view, we’re often not <em>modifying</em> the view at all, but rather encapsulating it in a new, transparent view. So when calling <code>.background()</code> above, we’re actually applying that background modifier to a new view that <em>wraps</em> our image, rather than to the image itself.</p><p>So, from a layout perspective, our image remains exactly the same — it’s still centered within its parent — only this time its parent is a new 50x50 transparent wrapper view instead of the main hosting view, but the rendered result is still the same.</p><p>Since SwiftUI views are responsible for determining their own size, we need to tell our image to resize itself to occupy all available space, rather than sticking to its default size. To make that happen, we simply have to apply the <code>.resizable()</code> modifier to it — like this:</p><pre data-preview="resized-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>We now have a 50x50 calendar icon rendered at the center of the screen — perfect!</p><h2>Applying padding</h2><p>Next, let’s take a look at how <em>padding</em> works in SwiftUI. Just like in other layout systems, like CSS, padding enables us to offset the contents of a view within its own frame. However, depending on where in our chain of view modifiers we apply our padding, we can get quite different results. For example, let’s start by applying a default set of padding by appending the <code>.padding()</code> modifier at the end of our chain:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">padding</span>()
    }
}</code></pre><p>Again, the result of the above might not be what we were expecting, as we’ve essentially given our calendar icon <em>outer padding</em> — additional whitespace that doesn’t include its background color. If we think about it, this is the exact same behavior as we encountered before when applying our <code>.frame()</code> modifier — calling <code>.padding()</code> doesn’t actually mutate our earlier views and modifiers, it simply adds whitespace around the result of the preceding expressions.</p><p>In fact, if we add a second <code>.background()</code> modifier after the call to <code>.padding()</code>, this behavior becomes a lot more clear — as the second background color will be rendered within the padding itself:</p><pre data-preview="padded-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">blue</span>)
    }
}</code></pre><p>So if we’re looking to add <em>inner padding</em> that takes a view’s background into account, we need to apply that padding <em>before</em> adding the background — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>To further illustrate that each modifier essentially wraps the view that it’s called on within yet another view — if we were to instead call <code>.padding()</code> <em>before</em> applying our <code>.frame()</code> modifier, our icon would shrink, since that padding would be applied within our fixed 50x50 container — forcing our resizable image to adopt a smaller size:</p><pre data-preview="smaller-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">padding</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>To finish our calendar icon view, let’s also a apply a bit of corner radius to it and make its foreground color white — and finally extract all of that code into a new view called <code>CalendarView</code>, like this:</p><pre data-preview="finished-calendar"><code><span class="s-keyword">struct</span> CalendarView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
    }
}</code></pre><p>In general, whenever we’ve finished defining a UI piece that could act as its own self-contained building block, it’s often a good idea to extract that code into a new <code>View</code> implementation — in order to <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">avoid building massive views</a>.</p><h2>Stacks and spacers</h2><p>Like we took a look at in the <a href="https://www.swiftbysundell.com/clips/3">third episode of Swift Clips</a>, SwiftUI’s various stacks and spacers may at first seem quite simple and limited, but can actually be used to express a nearly infinite combination of layouts. To get started exploring how they work, let’s replace the <code>body</code> of our <code>ContentView</code> with our new <code>CalendarView</code> wrapped within a vertical stack:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">CalendarView</span>()
        }
    }
}</code></pre><p>What’s interesting is that the above <code>VStack</code> doesn’t actually affect our layout at all, since SwiftUI stacks don’t stretch themselves to occupy their parent — instead they simply resize themselves according to the total size of their children, which in this case is just our <code>CalendarView</code> from before.</p><p>To actually move our <code>CalendarView</code>, we also have to add a <code>Spacer</code> to our stack. When placed within an <code>HStack</code> or <code>VStack</code>, spacers always occupy as much space that they can, which in this case will cause our <code>CalendarView</code> to be pushed to the top of the screen:</p><pre data-preview="calendar-at-top"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">CalendarView</span>()
            <span class="s-type">Spacer</span>()
        }
    }
}</code></pre><p>The cool thing about stacks is that they can be nested in order to express increasingly complex layouts without any form of manual frame calculations. For example, here’s how we could push our <code>CalendarView</code> to the top-leading corner of the screen, by nesting our above <code>VStack</code> within an <code>HStack</code> that also contains a <code>Spacer</code> (we’ll also apply some outer padding to our view hierarchy as well, to inset our content a bit):</p><pre data-preview="calendar-at-leading-top"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Next, let’s add a <code>Text</code> to our view, in order to start turning it into a screen that can be used to view a set of details about a calendar event. Since we’ll stick to only exploring SwiftUI’s layout system within this article, we’ll hard-code the content of our <code>Text</code> for now:</p><pre data-preview="calendar-with-text"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Looking at the above code, we might expect our new <code>Text</code> to be rendered right next to our <code>CalendarView</code> — and while that’s true on the horizontal axis, on the vertical axis it gets centered according to the full height of the screen. The reason for that is that our <code>Spacer</code> only affects the <code>VStack</code> in which our <code>CalendarView</code> is placed, so in order to get the same layout behavior for our <code>Text</code> as well, we’d either have to also wrap it within a <code>VStack</code> containing a spacer — or we can simply tell our root <code>HStack</code> to align all of its children towards the top, like this:</p><pre data-preview="calendar-with-top-text"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(alignment: .<span class="s-dotAccess">top</span>) {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Similarly, we can also adjust how a <code>VStack</code> positions its children horizontally, for example in order to render a <code>Text</code> showing the location of our imagined calendar event below the event’s title — while keeping both of those labels aligned according to the leading edge of our root view:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(alignment: .<span class="s-dotAccess">top</span>) {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
                <span class="s-type">Text</span>(<span class="s-string">"Location"</span>)
            }
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>However, while the above layout works, it could arguably be simplified in order to be easier to mentally visualize. It’s not very intuitive that all of our view’s content is being pushed to the top by a <code>Spacer</code> that’s nested within two stacks, and in order to keep iterating on our view vertically, we would also ideally like our root stack to be a <code>VStack</code>.</p><p>So let’s again extract the body of our <code>ContentView</code> into a dedicated component while refactoring it. This time, let’s call our new view <code>EventHeader</code>, and make it a vertically centered <code>HStack</code> that adds a bit of spacing between its children — which’ll let us achieve an improved version of our earlier layout, all while simplifying our code as well:</p><pre data-preview="event-header"><code><span class="s-keyword">struct</span> EventHeader: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(spacing: <span class="s-number">15</span>) {
            <span class="s-type">CalendarView</span>()
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
                <span class="s-type">Text</span>(<span class="s-string">"Location"</span>)
            }
            <span class="s-type">Spacer</span>()
        }
    }
}</code></pre><p>Going back to our <code>ContentView</code>, we can now turn its body into a single <code>VStack</code> containing our new <code>EventHeader</code> component, as well as our vertical spacer from before — which is now placed in a much better location in terms of making our layout code easier to understand:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Again, we’re following the same principle of continuously extracting the body of our <code>ContentView</code> into dedicated components whenever possible. Working that way can often enable us to naturally separate our UI into atomic parts, without requiring us to do a ton of architectural design work up-front.</p><h2>ZStacks and offset</h2><p>Finally, let’s take a quicker look at SwiftUI’s <code>ZStack</code> type, which enables us to stack a series of views in terms of depth, using a back-to-front order.</p><p>As an example, let’s say that we wanted to add support for displaying a small <em>“verified badge”</em> on top of our calendar view from before — by placing a checkmark icon at its top-trailing corner. To implement that in a slightly more generic way, let’s extend <code>View</code> with an API that lets us wrap any view within a <code>ZStack</code> (which in of itself won’t affect the view’s layout), that’ll also optionally contain our checkmark icon — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">offset</span>(x: <span class="s-number">3</span>, y: -<span class="s-number">3</span>)
            }
        }
    }
}</code></pre><p>Note how a <code>ZStack</code> gives us full two-dimensional control over its <code>alignment</code>, which we can use to position our icon in the parent view’s top-trailing corner. We then also apply the <code>.offset()</code> modifier to our badge, which’ll move it slightly outside of the bounds of its parent view.</p><p>With the above in place, we can now conditionally add our new badge to our <code>CalendarView</code> in case an <code>eventIsVerified</code> property was set to <code>true</code> (which we’ll currently default to, for simplicity):</p><pre data-preview="verified-event"><code><span class="s-keyword">struct</span> CalendarView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> eventIsVerified = <span class="s-keyword">true

    var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
            .<span class="s-call">addVerifiedBadge</span>(eventIsVerified)
    }
}</code></pre><p>Using a <code>ZStack</code> along with the <code>.offset()</code> modifier can be a great way to add various kinds of overlays to a view, without impacting that view’s own layout at all. We can use that technique to implement loading spinners, in-app notifications, and many other kinds of views that we wish to render on top of an existing view hierarchy.</p><h2>Conclusion</h2><p>That concludes part one of this guide to the SwiftUI layout system. In <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a>, we’ll continue by taking a look at slightly more powerful ways to build completely custom layouts, but for now — let’s summarize what we’ve covered so far:</p><ul><li>SwiftUI’s core layout engine works by asking each child view to determine its own size based on the bounds of its parent, and then asks each parent to position its children within its own bounds.</li><li>View modifiers often wrap the current view within yet another view, which is why we can get completely different layout results depending on which order that we call our modifiers in.</li><li>Using the <code>.frame()</code> and <code>.padding()</code> modifiers lets us adjust a view’s size and internal margin, as long as that view is configured to resize itself accordingly.</li><li>Using <code>HStack</code>, <code>VStack</code> and <code>ZStack</code> we can stack views together either horizontally, vertically, or depth-wise.</li><li>Using <code>offset()</code> we can move a view without affecting its surroundings, which is very useful when implementing overlays and other kinds of overlapping views.</li></ul><p>I hope you enjoyed this first part. If you did, feel free to share this article with a friend or on social media, or check out this week’s sponsor (that really helps support my work). Also, let me know if you have any questions, comments or feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p><strong><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">You can find part two of this article series here</a></strong>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds</guid><title>Tip: Making properties overridable only in debug builds</title><description>Implementing a property wrapper to enable certain properties to be overridden only in debug mode.</description><link>https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds</link><pubDate>Fri, 20 Mar 2020 19:50:00 +0100</pubDate><content:encoded><![CDATA[<p>Occasionally, we might want to override certain properties in order to facilitate testing, to be able to work on a new feature, or to debug a problem. That’s particularly common when using Storyboard-based view controllers, and other objects that the system initializes for us, as that typically prevents us from using <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift/%23initializer-based">initializer-based dependency injection</a>.</p><p>In those situations, opening up properties to be mutated can be a pragmatic way to give us the flexibility that we need. For example, here we’re enabling a view controller’s <code>UserDefaults</code> and <code>Cache</code> instances to be overridden by making them mutable properties:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> userDefaults = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
    <span class="s-keyword">var</span> cache = <span class="s-type">Cache</span>()
    ...
}</code></pre><p>However, while the above approach opens up doors in terms of flexibility, making a type contain additional <em>mutable state</em> can also end up causing new problems — as we might now accidentally mutate our object in ways we didn’t expect within our production code.</p><p>Here’s a way to mitigate that problem, using Swift’s new <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrappers</a></em> feature in combination with the <code>DEBUG</code> compiler flag. By creating a <code>DebugOverridable</code> property wrapper, we can enforce that the properties that we wish to override during testing and development are not actually overridden within any of our code that we’re shipping to production:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> DebugOverridable&lt;Value&gt; {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">let</span> wrappedValue: <span class="s-type">Value</span>
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">Note that we could’ve also used a custom compiler flag above, for example if we also needed to run our tests in release mode.</p><p>With the above property wrapper in place, we can now go back to the properties that we only wish to be mutable within <code>DEBUG</code>, and simply mark them with <code>@DebugOverridable</code> to make that happen — no matter which form of abstraction that we use for our dependencies:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">@DebugOverridable
    var</span> userDefaults = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
    <span class="s-keyword">@DebugOverridable
    var</span> fileManager: <span class="s-type">FileManagerProtocol</span> = <span class="s-type">FileManager</span>.<span class="s-property">default</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cache = <span class="s-type">Cache</span>()
    <span class="s-keyword">@DebugOverridable
    var</span> dateProvider: () -&gt; <span class="s-type">Date</span> = <span class="s-type">Date</span>.<span class="s-property">init</span>
    ...
}</code></pre><p>Of course, in an ideal world, we would always be able to do initializer-based dependency injection, and then keep our objects as immutable as possible — but when working with various frameworks and SDKs (including UIKit and AppKit), that’s not always possible — even if there is now a <a href="https://developer.apple.com/documentation/uikit/uistoryboard/3213989-instantiateviewcontroller">dependency injection-friendly API</a> when using Storyboards, introduced in iOS 13.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/result</guid><title>Basics: The Result Type</title><description>A look at the standard library’s Result type, what kind of situations that it might be useful in, and tips and tricks that can be good to keep in mind when working with it.</description><link>https://www.swiftbysundell.com/basics/result</link><pubDate>Thu, 19 Mar 2020 12:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The Swift standard library’s <code>Result</code> type enables us to express the outcome of a given operation — whether it succeeded or failed — using a single, unified type. Let’s take a look at what kind of situations that <code>Result</code> might be useful in, and a few tips and tricks that can be good to keep in mind when starting to work with that type.</p><p>While there are many different ways to model a <code>Result</code> type, the one that comes built into the Swift standard library is declared as a <a href="https://www.swiftbysundell.com/basics/generics">generic</a> <a href="https://www.swiftbysundell.com/basics/enums">enum</a> that’s <em>strongly typed</em> for both the successful value that the result might contain, as well as for any error that was encountered. It looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Result&lt;Success, Failure&gt; <span class="s-keyword">where</span> <span class="s-type">Failure</span>: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> success(<span class="s-type">Success</span>)
    <span class="s-keyword">case</span> failure(<span class="s-type">Failure</span>)
}</code></pre><p>Like the above declaration shows, we can use <code>Result</code> to represent any success/failure combination, as long as the <code>Failure</code> type conforms to Swift’s <a href="https://www.swiftbysundell.com/basics/error-handling"><code>Error</code></a> protocol. So how can we use the above type in practice, and what are the advantages of doing so?</p><p>As an example, let’s take a look at <code>URLSession</code>, and one of its most commonly used APIs — which uses a <a href="https://www.swiftbysundell.com/basics/closures">closure</a>-based design to return a <a href="https://www.swiftbysundell.com/basics/networking">network request’s</a> various results in an asynchronous fashion:</p><pre class="splash"><code><span class="s-keyword">let</span> url = <span class="s-type">URL</span>(string: <span class="s-string">"https://www.swiftbysundell.com"</span>)!

<span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) {
    data, response, error <span class="s-keyword">in
    
    if let</span> error = error {
        <span class="s-comment">// Handle error</span>
        ...
    } <span class="s-keyword">else if let</span> data = data {
        <span class="s-comment">// Handle successful response data</span>
        ...
    }
}

task.<span class="s-call">resume</span>()</code></pre><p>While <code>URLSession</code> has evolved a lot over the years, and has an incredibly capable suite of APIs, deciding exactly how to handle the result of a network call can at times be a bit tricky — since, like the above example shows, both the <code>data</code> and potential <code>error</code> results are passed into our closure as optionals — which in turn requires us to unwrap each of those values every time we make a network call.</p><p>Let’s take a look at how using <code>Result</code> could help us solve that problem. We’ll start by extending <code>URLSession</code> with a new API that passes a <code>Result&lt;Data, Error&gt;</code> value into its completion handler, rather than a group of optionals. To make that happen, we’ll unwrap the optionals that the standard API gives us (similar to what we do above) in order to construct our <code>Result</code> — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">URLSession</span> {
    <span class="s-keyword">func</span> dataTask(
        with url: <span class="s-type">URL</span>,
        handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">URLSessionDataTask</span> {
        <span class="s-call">dataTask</span>(with: url) { data, <span class="s-keyword">_</span>, error <span class="s-keyword">in
            if let</span> error = error {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            } <span class="s-keyword">else</span> {
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(data ?? <span class="s-type">Data</span>()))
            }
        }
    }
}</code></pre><p class="info">Note how we’ve simplified things a bit above, by ignoring the default API’s <code>URLResponse</code> value (using an underscore instead of its parameter name within our closure). That’s not something that we might always want to do, although for simpler networking tasks, there might not be a need to inspect that response value.</p><p>If we now go back to our earlier call site and update it to use our new API, we can see that our code becomes a lot more clear — as we can now write completely separate code paths for both the <code>success</code> and <code>failure</code> case, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
        <span class="s-comment">// Handle successful response data</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
        <span class="s-comment">// Handle error</span>
        ...
    }
}</code></pre><p>One interesting detail about the way we use <code>Result</code> above is that we’ve specified its <code>Failure</code> type simply as <code>Error</code>. That means that any error can be passed into our result, which in turn limits our options for more specific error handling at the call site (since we don’t have any exhaustive list of potential errors to handle). While that’s tricky to change when working directly with a system API that, in turn, can throw any error — when we’re building a more specific form of abstraction we can often design a more <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">unified error API</a> for it.</p><p>For example, let’s say that we’re building a very simple image loader that’ll let us load an image over the network, again using <code>URLSession</code>. But before we start actually implementing our loader itself, let’s first define an enum that lists all potential errors that it could encounter. For now, we’ll only have two cases — either a network error occurred, or the data that we downloaded turned out to be invalid:</p><pre class="splash"><code><span class="s-keyword">enum</span> ImageLoadingError: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> networkFailure(<span class="s-type">Error</span>)
    <span class="s-keyword">case</span> invalidData
}</code></pre><p>Then, when building our image loader, we can now specialize <code>Result</code> with the above error type — which in turn enables us to send much more rich error information to our call sites:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">ImageLoadingError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> session = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>

    <span class="s-keyword">func</span> loadImage(at url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> task = session.<span class="s-call">dataTask</span>(with: url) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">if let</span> image = <span class="s-type">UIImage</span>(data: data) {
                    <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
                } <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(.<span class="s-dotAccess">invalidData</span>))
                }
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(.<span class="s-call">networkFailure</span>(error)))
            }
        }

        task.<span class="s-call">resume</span>()
    }
}</code></pre><p>The above design then enables us to handle each potential error in a much more granular fashion when using our image loader, for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> imageURL = <span class="s-type">URL</span>(string: <span class="s-string">"https://www.swiftbysundell.com/images/logo.png"</span>)!
<span class="s-keyword">let</span> imageLoader = <span class="s-type">ImageLoader</span>()

imageLoader.<span class="s-call">loadImage</span>(at: imageURL) { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> image):
        <span class="s-comment">// Handle image</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(.<span class="s-dotAccess">invalidData</span>):
        <span class="s-comment">// Handle an invalid data failure</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(.<span class="s-call">networkFailure</span>(<span class="s-keyword">let</span> error)):
        <span class="s-comment">// Handle any network error</span>
        ...
    }
}</code></pre><p>Swift’s built-in <code>Result</code> type might just take a handful of lines of code to declare, but the patterns that it enables us to adopt are really powerful, and can lead to much simpler code — especially when performing asynchronous operations, such as network calls.</p><p>To learn a lot more about result types in general, and some of the built-in type’s more powerful APIs, check out <em><a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift">“The power of Result types in Swift”</a></em>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used</guid><title>Tip: When can a struct’s memberwise initializer be used?</title><description>How Swift’s memberwise initializers work, and when those initializers can be used.</description><link>https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used</link><pubDate>Tue, 17 Mar 2020 17:50:00 +0100</pubDate><content:encoded><![CDATA[<p>In Swift, types defined as structs automatically get a default initializer synthesized by the compiler — a so-called <em>“memberwise initializer”</em>, as the compiler will generate it based on the given struct’s <em>members</em> (that is, its stored properties).</p><p>For example, if we’ve defined a <code>User</code> struct that has a <code>name</code> and a <code>preferences</code> property, we can use its memberwise initialize to create instances simply by passing values for those two properties:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences: <span class="s-type">Preferences</span>
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>, preferences: <span class="s-type">Preferences</span>())</code></pre><p>Computed properties, on the other hand, are completely ignored when the compiler synthesizes a memberwise initializer — so even if we add one, we can still keep using the above initializer just like before:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences: <span class="s-type">Preferences</span>
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { .<span class="s-dotAccess">user</span> }
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>, preferences: <span class="s-type">Preferences</span>())</code></pre><p>As of Swift 5.1, memberwise initializers also take default property values into account — meaning that if we give our <code>preferences</code> property a default value, we’ll be able to create a <code>User</code> instance by just passing a <code>name</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences = <span class="s-type">Preferences</span>()
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>)</code></pre><p>One cool thing is that we can keep using a type’s memberwise initializer even if that type has <em>private</em> properties — as long as those properties have a default value, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> preferences = <span class="s-type">Preferences</span>()
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>)</code></pre><p>However, if a private property doesn’t have a default value, we’ll have to write that type’s initializer manually — in order to be able to inject a value for that property from the outside:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> preferences: <span class="s-type">Preferences</span>

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>, preferences: <span class="s-type">Preferences</span> = .<span class="s-keyword">init</span>()) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
        <span class="s-keyword">self</span>.<span class="s-property">preferences</span> = preferences
    }
}</code></pre><p>One thing to keep in mind, though, is that memberwise initializers will never have an <a href="https://www.swiftbysundell.com/basics/access-control">access level</a> higher than <code>internal</code>, which means that we can only use them internally within the module in which their type is defined.</p><p>That might initially seem like a strange restriction, but it does have merits, as we should arguably always design explicit APIs for public consumption — without making them tied to the internal structure of our data.</p><p>So, to sum up, we can use a struct’s memberwise initializer when:</p><ul><li>All of its members are either visible, or have a default value.</li><li>We are creating an instance within the same module that the struct is defined in.</li></ul><p>All other cases require us to manually implement an initializer, at least for now.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/writing-small-utility-functions-in-swift</guid><title>Writing small utility functions in Swift</title><description>Let’s take a look at how even the smallest utility functions can have quite a big impact on the way we write code on a day-to-day basis, by making common tasks easier and preferred patterns simpler.</description><link>https://www.swiftbysundell.com/articles/writing-small-utility-functions-in-swift</link><pubDate>Sun, 15 Mar 2020 21:15:00 +0100</pubDate><content:encoded><![CDATA[<p>Sometimes, it might seem like the only way to truly impact the overall state of a code base is to make big, sweeping changes — such as changing its architecture, modifying the way data and actions flow through the system, or by adopting new frameworks.</p><p>However, while such bigger changes can sometimes be important to make, there’s also often a ton of value to be found in simply addressing more minor pain points, and by making it slightly smoother to iterate on our code during our day-to-day work.</p><p>This week, let’s take a look at one way of doing just that — by writing small utility functions that make common tasks easier to perform, and preferred patterns simpler to adopt.</p><h2>Configuration closures</h2><p>A fair amount of the code within any given project is likely going to be dedicated to configuring certain objects for use — especially when constructing views using object-oriented UI frameworks, such as UIKit. Like we took a look at in <a href="https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift">“Encapsulating configuration code in Swift”</a>, finding neat ways to isolate such code can really improve the overall clarity of our actual logic, and this is an area in which utility functions can become especially useful.</p><p>As an example, let’s say that we’re currently using the quite popular pattern of structuring the setup of each view’s various subviews using <em><a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift/%23using-a-self-executing-closure">self-executing closures</a></em> — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderView: <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> imageView: <span class="s-type">UIImageView</span> = {
        <span class="s-keyword">let</span> view = <span class="s-type">UIImageView</span>()
        view.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        view.<span class="s-property">contentMode</span> = .<span class="s-dotAccess">scaleAspectFit</span>
        view.<span class="s-property">image</span> = .<span class="s-dotAccess">placeholder</span>
        <span class="s-keyword">return</span> view
    }()

    <span class="s-keyword">let</span> label: <span class="s-type">UILabel</span> = {
        <span class="s-keyword">let</span> view = <span class="s-type">UILabel</span>()
        view.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        view.<span class="s-property">numberOfLines</span> = <span class="s-number">2</span>
        view.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">headline</span>)
        <span class="s-keyword">return</span> view
    }()
    
    ...
}</code></pre><p>There’s nothing really wrong with the above implementation, but it would be great if we could reduce the amount of code associated with each property — as each line that we add <em>“pushes”</em> our type’s actual implementation and logic further down. While there are a number of different approaches we could take here, such as <a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift/%23using-a-factory-method">using factory methods</a> instead of self-executing closures — let’s see if we could write a simple utility function to help us make the above code a bit more compact, while still using the same basic pattern.</p><p>Let’s start by introducing a function called <code>configure</code>, which will take a value that we wish to configure, and a closure in which we can encapsulate all of our configuration code. We’ll also mark that closure’s parameter with the <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift/%23simplifying-repeated-mutations"><code>inout</code></a> keyword to enable our new function to easily be used with value types:</p><pre class="splash"><code><span class="s-keyword">func</span> configure&lt;T&gt;(
    <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
    using closure: (<span class="s-keyword">inout</span> <span class="s-type">T</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Void</span>
) <span class="s-keyword">rethrows</span> -&gt; <span class="s-type">T</span> {
    <span class="s-keyword">var</span> value = value
    <span class="s-keyword">try</span> <span class="s-call">closure</span>(&amp;value)
    <span class="s-keyword">return</span> value
}</code></pre><p>With the above in place, we can now go back to our <code>HeaderView</code>, and make its subview configuration code read a lot nicer:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderView: <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> imageView = <span class="s-call">configure</span>(<span class="s-type">UIImageView</span>()) {
        $0.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        $0.<span class="s-property">contentMode</span> = .<span class="s-dotAccess">scaleAspectFit</span>
        $0.<span class="s-property">image</span> = .<span class="s-dotAccess">placeholder</span>
    }

    <span class="s-keyword">let</span> label = <span class="s-call">configure</span>(<span class="s-type">UILabel</span>()) {
        $0.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        $0.<span class="s-property">numberOfLines</span> = <span class="s-number">2</span>
        $0.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">headline</span>)
    }
    
    ...
}</code></pre><p>Gone are the local variables and the need to <code>return</code> each view after it’s been configured — leading to more compact code that’s not any harder to read. In fact, it could even be argued that the above code is <em>easier</em> to read, since we’re now calling a function that’s explicitly named <em>“configure”</em> — rather than relying on a convention, like we did before when using self-executing closures.</p><p>While there are a number of other approaches that we could’ve taken in order to achieve a similar result, one advantage of our new <code>configure</code> function is that it’s completely generic, and can be used with any type — whether it’s a <code>UIView</code> subclass, any other type of object, or even value types.</p><p>For example, here we’re using the exact same pattern as above when setting up a <code>URLRequest</code> value to be used to sync data when the user is on a WiFi-based connection:</p><pre class="splash"><code><span class="s-keyword">struct</span> SyncNetworkTask {
    <span class="s-keyword">var</span> request = <span class="s-call">configure</span>(<span class="s-type">URLRequest</span>(url: .<span class="s-dotAccess">syncEndpoint</span>)) {
        $0.<span class="s-property">httpMethod</span> = <span class="s-string">"PATCH"</span>
        $0.<span class="s-call">addValue</span>(<span class="s-string">"application/json"</span>,
            forHTTPHeaderField: <span class="s-string">"Content-Type"</span>
        )
        $0.<span class="s-property">allowsCellularAccess</span> = <span class="s-keyword">false</span>
    }
    
    ...
}</code></pre><p>The beauty of utility functions in general is that they in many cases enable us to unify various code patterns and styles across each code base — by making the <em>right way</em> to perform a certain task (or at least the way that’s preferred within the project) also become the <em>easiest way</em>.</p><h2>The power of rethrowing functions</h2><p>One detail of the above <code>configure</code> function that can be easy to miss is the fact that it’s marked with the <code>rethrows</code> keyword. What that keyword does is that it tells the Swift compiler to only treat that function as <em>throwing</em> if the closure passed to it <em>also throws</em>.</p><p>That’s incredibly useful, as it both enables non-throwing use cases like the ones above (without having to use the <code>try</code> keyword in those cases), while also giving us the freedom to throw errors within our configuration closures if needed:</p><pre class="splash"><code><span class="s-keyword">let</span> webView = <span class="s-keyword">try</span> <span class="s-call">configure</span>(<span class="s-type">WKWebView</span>()) {
    <span class="s-keyword">let</span> html = <span class="s-keyword">try</span> <span class="s-call">loadBundledHTML</span>()
    <span class="s-keyword">try</span> $0.<span class="s-call">loadHTMLString</span>(html, baseURL: <span class="s-keyword">nil</span>)
    ...
}</code></pre><p>Whenever we’re designing any API that accepts synchronous closures, it’s definitely worth considering marking our functions with <code>rethrows</code> — as doing so enables us to throw errors when needed, without making our non-throwing call sites any more complicated.</p><h2>Reducing boilerplate</h2><p>Besides letting us codify conventions, utility functions can also often help us avoid common mistakes, and enable us to reduce boilerplate — even when it comes to more specific tasks, such as defining layouts and computing colors.</p><p>Especially when using Auto Layout in code, there’s a number of things that we always have to keep in mind — such as remembering to tell each view not to translate its auto resizing mask into constraints (at least in most cases), and to activate each layout constraint that we define — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
label.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
view.<span class="s-call">addSubview</span>(label)

<span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>([
    label.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
    label.<span class="s-property">leadingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">leadingAnchor</span>),
    ...
])</code></pre><p>Whenever we have to manually remember to write certain kinds of setup code over and over again, that’s typically a great candidate for a utility function. When it comes to the above example in particular, we’re not looking to introduce a brand new UI abstraction, or to completely change the way we write layout code — our only goal is to make defining constraints <em>slightly</em> easier and more robust.</p><p>For example, we might opt for something as simple as a <code>UIView</code> extension that automatically prepares a given view to be used with Auto Layout, and then activates an array of constraints:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">func</span> layout(using constraints: [<span class="s-type">NSLayoutConstraint</span>]) {
        translatesAutoresizingMaskIntoConstraints = <span class="s-keyword">false</span>
        <span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>(constraints)
    }
}</code></pre><p>With just that tiny extension in place, we can actually make our original code read quite a bit nicer — now looking like this:</p><pre class="splash"><code><span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
view.<span class="s-call">addSubview</span>(label)

label.<span class="s-call">layout</span>(using: [
    label.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
    label.<span class="s-property">leadingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">leadingAnchor</span>),
    ...
])</code></pre><p>That may seem like quite a minor change, but the nice thing about utility functions is that they don’t need to make an enormous impact on our code to be useful — simply removing a few sources of boilerplate and potential mistakes is typically enough for them to be worth the effort.</p><p>Along those same lines, let’s take a look at another example in which we aim to make it as easy as possible to define dynamic colors that automatically adapt to whether the user’s device is currently running in either light mode or dark mode. The official iOS API for doing just that (apart from defining colors within asset catalogs) looks like this:</p><pre class="splash"><code><span class="s-keyword">let</span> backgroundColor = <span class="s-type">UIColor</span> { traitCollection <span class="s-keyword">in
    switch</span> traitCollection.<span class="s-property">userInterfaceStyle</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">dark</span>:
        <span class="s-keyword">return</span> <span class="s-type">UIColor</span>(white: <span class="s-number">0.15</span>, alpha: <span class="s-number">1</span>)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">unspecified</span>:
        <span class="s-keyword">return</span> <span class="s-type">UIColor</span>(white: <span class="s-number">0.85</span>, alpha: <span class="s-number">1</span>)
    }
}</code></pre><p>That’s a quite nice API, but always having to write a closure containing a <code>switch</code> statement every time we want to define a dynamic color can quickly get tiresome — so let’s again see if we can reduce some of the above verbosity using a utility function.</p><p>Since we’re essentially looking to define pairs of colors to use in either light or dark mode, let’s name our new function <code>colorPair</code>, and have it accept one <code>UIColor</code> to use for light mode, and another one for dark mode. We’ll then call the official <code>UIColor</code> API and return the appropriate color for each <code>UIUserInterfaceStyle</code> — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> colorPair(light: <span class="s-type">UIColor</span>, dark: <span class="s-type">UIColor</span>) -&gt; <span class="s-type">UIColor</span> {
    <span class="s-type">UIColor</span> { traitCollection -&gt; <span class="s-type">UIColor</span> <span class="s-keyword">in
        switch</span> traitCollection.<span class="s-property">userInterfaceStyle</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">dark</span>:
            <span class="s-keyword">return</span> dark
        <span class="s-keyword">case</span> .<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">unspecified</span>:
            <span class="s-keyword">return</span> light
        }
    }
}</code></pre><p class="info">Worth noting is that the above function requires us to always create both of our colors at once, rather than only creating the one that’s needed for the current mode. However, that’s something that we could address using <a href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis"><code>@autoclosure</code></a> if needed.</p><p>With the above in place, we can reduce the amount of code needed to define each color pair quite drastically — making our above <code>backgroundColor</code> declaration now look like this:</p><pre class="splash"><code><span class="s-keyword">let</span> backgroundColor = <span class="s-call">colorPair</span>(
    light: <span class="s-type">UIColor</span>(white: <span class="s-number">0.85</span>, alpha: <span class="s-number">1</span>),
    dark: <span class="s-type">UIColor</span>(white: <span class="s-number">0.15</span>, alpha: <span class="s-number">1</span>)
)</code></pre><p>Combine the above with another quick utility function that lets us define any gray scale <code>UIColor</code> using dot-syntax, and we’ve got ourselves a really neat way of defining dynamic colors — again without any huge abstraction or reinvention of the way colors work on iOS:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIColor</span> {
    <span class="s-keyword">static func</span> grayScale(<span class="s-keyword">_</span> white: <span class="s-type">CGFloat</span>,
                          alpha: <span class="s-type">CGFloat</span> = <span class="s-number">1</span>) -&gt; <span class="s-type">UIColor</span> {
        <span class="s-type">UIColor</span>(white: white, alpha: alpha)
    }
}

<span class="s-keyword">let</span> backgroundColor = <span class="s-call">colorPair</span>(
    light: .<span class="s-call">grayScale</span>(<span class="s-number">0.85</span>),
    dark: .<span class="s-call">grayScale</span>(<span class="s-number">0.15</span>)
)</code></pre><p>While writing utility functions such as the ones above, we might start to ask ourselves questions like <em>“Why aren’t the default APIs designed this way?”</em>. Like with most things in programming, designing great APIs is often about balancing a certain set of trade-offs.</p><p>While the standard APIs need to optimize both for flexibility, and for a certain degree of consistency with the rest of the platform’s SDK — our own utility functions are free to use a more lightweight, specific design — while still <em>complementing</em> the platforms’s native APIs, rather than aiming to replace them.</p><p>That way, we can use our new utility functions whenever possible, while easily be able to fall back to the standard platform APIs whenever we need more power or customization options.</p><h2>Conclusion</h2><p>Utility functions can help us codify our conventions, reduce boilerplate, and make common tasks easier to perform. By constantly looking for small ways that we can make writing code smoother and more enjoyable, we’ll keep making our work gradually easier over time — even though each change might seem relatively minor in isolation.</p><p>Of course, we shouldn’t go <em>too far</em>, and wrap every single task within some form of convenience API. The process of writing truly great utility functions is, in my opinion, really about identifying common bottlenecks and pain points, and then addressing those — through lightweight APIs that complement the system frameworks, rather than aiming to replace them or completely hide them behind an abstraction.</p><p>What do you think? What are some of your favorite utility functions, and have you tried using some variant of the examples shown in this article already? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/meta/working-remotely</guid><title>Working remotely</title><description>My top five tips and learnings from years of working remotely.</description><link>https://www.swiftbysundell.com/meta/working-remotely</link><pubDate>Tue, 10 Mar 2020 19:15:00 +0100</pubDate><content:encoded><![CDATA[<p>Having the freedom to work remotely — either from home, from a co-working space, or from anywhere else — can be incredibly liberating, fun, and actually lead to a quite substantial boost in productivity and overall focus. However, working remotely can also be really challenging, especially in the beginning — as it typically requires a much greater degree of personal accountability and organization than working on-site.</p><p>I’ve personally been working remotely for many years, and I still am. So, in this article, I thought I’d share my top five tips and learnings as to how I try to get the very most out of my day-to-day work as a remote developer, writer, and podcaster.</p><p class="info">Like always with articles that are of a more personal nature, I just want to point out that the content of this article is based purely on my <strong>personal experiences</strong>, not on any form of wider research.</p><h2>Office hours</h2><p>One of the most challenging aspects of remote work, especially when working from home, is to clearly separate work time from free time. Doing so might not seem like a big deal in the beginning, especially for people who have flexible working hours — but for me, it’s truly essential.</p><p>I love my job, and will often choose to code not only for work, but also as a hobby, and for fun. There’s of course nothing wrong with that, but when your home is also your place of work, there’s a risk that work simply becomes a bit <em>too accessible</em>.</p><p>A very common fallacy about remote work in general is that people who work remotely will often slack off or get distracted with non-work tasks — but I’ve found that I need to worry a lot more about <em>over-working</em> than <em>under-working</em>. Left unchecked, I could easily work for 10, 12 hours per day — which isn’t very healthy in the long run.</p><p>To address this issue, I typically set up office hours that I try my very best to follow, and to have days on which I don’t work at all. If you’re only working from home temporarily, or if you’re part of a team that already has office hours in place, I’d recommend following those times as much as possible. Because regardless if you’re passionate about code or not, we all still need to rest.</p><h2>Setting up a dedicated workspace</h2><p>Continuing on the topic of work/free time separation, one of the easiest ways that I’ve found to achieve a clear distinction between when I’m at work versus when I’m simply at home, is to set up a dedicated workspace within my home.</p><p>While I personally have a dedicated room within my apartment that’s essentially my office and podcast recording studio, that might not be possible for everyone. However, even you live in a small place or don’t have any spare rooms, there’s still often a way to set up a somewhat separate place for working.</p><p>For example, you might be able to put a small table or desk somewhere, or to mark a certain part of an existing table as your “desk”, at least during office hours. You might also be able to buy a cheap desk second-hand, or from a low-cost furniture store (I personally used the 15 Euro <em>“Linnmon”</em> IKEA desk for my first few years of working remotely).</p><p>Not only does having a dedicated workspace have ergonomic advantages (working from a couch or bed can be cozy for a while, but often isn’t very comfortable or healthy in the long run), for me, it also lets me literally walk away from work when I’m done for the day — which in turn enables me to truly relax when I’m not working.</p><h2>Maintaining routines</h2><p>When commuting and going to a specific place to work, we often tend to form our routines around going back and forth between our home and our workplace. From getting ready to leave in the morning, to perhaps picking up groceries on the way home from work — there are many kinds of routines that can easily start to break down when working from home.</p><p>I think actively maintaining those kinds of routines is crucial in order for each day to have a certain degree of structure. Call me old fashioned, but I still get ready in the morning <em>as if</em> I was going to an office. I still have breakfast away from my computer, and I still take breaks for lunch and run my errands after I’m done with work for the day. I’ve found that whenever I compromise those routines (for example by having lunch at my desk, or by starting to work immediately after I wake up), my stress levels rise significantly over time.</p><p>At the end of the day, these first three tips all come down to maintaining a solid work/life balance — which may seem like basic stuff, but once you bring your work into your home, I think actively working on that balance and maintaining a robust set of routines becomes increasingly important — at least for me.</p><h2>Daily and weekly planning</h2><p>Depending on whether you work as an independent developer or freelancer, or whether you’re part of a team, working remotely might also require you to take a lot more responsibility for organizing your own work.</p><p>While the way each person prefers to organize their tasks might differ quite a lot, one thing that I’ve found particularly useful when it comes to staying focused and productive while working remotely is to make daily and weekly lists of tasks that I’m aiming to complete. Not only does that give me a more concrete plan for each day of work, it also gives me a sense of accomplishment whenever I can mark one of those tasks as done.</p><p>Like I wrote about in my <a href="https://www.swiftbysundell.com/meta/productivity"><em>“Productivity”</em> article</a> back in 2017, apart from my main lists of tasks and goals, I also like to maintain a separate list of <em>”Quick wins”</em> — smaller tasks that I can pick up whenever I’m between two of my main tasks, or when I’m waiting for someone to complete a set of work that I depend on. By starting each day by completing a small task (like replying to an email, or making a small UI tweak, or doing a code review), I feel like I’m getting started on the right track.</p><h2>The wonder of video</h2><p>Whether its via Slack, GitHub or any other channel — I think it’s fair to say that many developers are very used to communicating via text (and sometimes GIFs), so it’s quite easy for that to become the <em>only</em> means of communication and collaboration when working remotely. While text does has a certain efficiency to it, I also think that the value of having face-to-face meetings and discussions shouldn’t be under-estimated.</p><p>Thankfully, in this day and age, we have access to so many tools that let us run all sorts of meetings and collaboration sessions over audio, video, and beyond (VR meetings, anyone?). While many teams already do things like agile standups and daily planning sessions over video services like Skype, Slack and Google Hangouts — there are a ton of other ways to incorporate audio and video calls into our daily work.</p><p>For example, if I feel like a few other developers and I are getting stuck in a text-based discussion on Slack or GitHub, I typically suggest that we jump on a quick call to discuss the problem face-to-face instead. That way we can resolve misunderstandings, show examples, and come up with a solution much quicker than if we kept going in circles via text.</p><p>Pair programming, designing architectures, workshops, and even having agile meetings like retrospectives are all tasks that are 100% possible (and can even be great!) to do over video call. All it takes is to try to foster a culture within the team that having a video call is not necessarily like having a <em>“serious meeting”</em> — it can sort of be the remote working equivalent of a <em>“water cooler discussion”</em>.</p><h2>Conclusion</h2><p>How much each individual person will enjoy working remotely will of course vary a lot from person to person. Some people will love the freedom and independence it brings, while others might find themselves missing the presence of coworkers, or struggling with maintaining a solid work/life balance over time.</p><p>Regardless, there are definitely ways to improve and refine most kinds of remote work situations, and while most of those improvements will likely require a fair amount of experimentation to get right — I hope that this article has given you some inspiration as to what sort of practices that could be useful to explore.</p><p>Becoming a truly successful remote worker is also rarely something that can be done alone — it requires everyone on the team to work together to get better at asynchronous communication, using tools like video calls to bridge the gap between each individual developer, and for everyone to give each other feedback and tips as to what’s working and what’s not. Because even though it might seem like remote work can be a somewhat lonely endeavor, it really doesn’t have to be.</p><p>Got questions, comments or feedback? Find me <a href="https://twitter.com/johnsundell">on Twitter</a> or contact me <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views</guid><title>Avoiding massive SwiftUI views</title><description>This week, let’s explore the topic of UI modularization in the context of SwiftUI, by taking a look at a few different techniques that can be useful in order to avoid trading Massive View Controllers for Massive Views.</description><link>https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views</link><pubDate>Sun, 8 Mar 2020 22:45:00 +0100</pubDate><content:encoded><![CDATA[<p>When writing any form of UI code, it can often be challenging to decide when and how to split various view implementations up into smaller pieces. It’s so easy to end up with views that each represent an entire screen or feature — leading to code that’s often hard to change, refactor and reuse.</p><p>For UIKit-based apps (and to some extent AppKit-based ones, too), a very common manifestation of this problem is the <em>“Massive View Controller”</em> syndrome — which is when a view controller ends up taking on too many responsibilities, resulting in a <em>massive</em> implementation, both in terms of scope and line count.</p><p>Now, as we’re collectively moving towards SwiftUI as the go-to framework for building UIs for all of Apple’s platforms, it might first seem that this problem will simply go away. No view controllers, no problems, right? However, while SwiftUI’s overall design <em>does</em> encourage us to write more composable, decoupled code by default — it still requires us to design and factor our view code in a way that doesn’t put too many responsibilities on individual types.</p><p>This week, let’s explore that topic, and take a look at a few different techniques that can be useful in order to avoid trading Massive View Controllers for <em>Massive Views</em>.</p><h2>Extract, reuse, repeat</h2><p>Since SwiftUI views are not concrete representations of pixels on screen, but rather lightweight descriptions of the various views that we wish to render, they often lend themselves quite well to being extracted into smaller pieces that can then be reused within various contexts.</p><p>For example, let’s say that we’re working on an app for browsing movies. To render a list of movies, we’ve built a <code>MovieList</code> view — which observes a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a> and renders its various subviews like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>, selection: $selectedMovie) { movie <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>)
                    .<span class="s-call">resizable</span>()
                    .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                    .<span class="s-call">frame</span>(maxWidth: <span class="s-number">100</span>)
                <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                    <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                    <span class="s-type">HStack</span> {
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>)
                        <span class="s-type">Text</span>(<span class="s-string">"Director:"</span>)
                    }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    <span class="s-type">Text</span>(movie.<span class="s-property">director</span>)
                    <span class="s-type">HStack</span> {
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>)
                        <span class="s-type">Text</span>(<span class="s-string">"Genre:"</span>)
                    }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    <span class="s-type">Text</span>(movie.<span class="s-property">genre</span>)
                }
            }
        }
    }
}</code></pre><p>If we only look at the above view’s <em>line count</em>, it isn’t really <em>massive</em> at all. However, it’s arguably quite difficult to quickly get a grasp of what the resulting UI will look like, given that we’re currently constructing all of our view’s various parts in one single place — and that problem is likely to keep growing as we keep adding new UI variations and features.</p><p>Instead, let’s see if we can structure the above view as a collection of individual <em>components</em>, rather than as as a single unit. That way, we’d both be able to individually reuse those components within other views, and we should also be able to make our UI code read much nicer.</p><p>Let’s start with our <code>Image</code>, which doesn’t really warrant a new <code>View</code> implementation — since we’re only applying a set of modifiers to make each image render as a smaller <em>“thumbnail”</em>. So, like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views">“Configuring SwiftUI views”</a></em>, let’s instead write an extension that groups those modifiers together in order to make them more semantically meaningful:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Image</span> {
    <span class="s-keyword">func</span> asThumbnail(withMaxWidth maxWidth: <span class="s-type">CGFloat</span> = <span class="s-number">100</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">resizable</span>()
            .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
            .<span class="s-call">frame</span>(maxWidth: maxWidth)
    }
}</code></pre><p>Next, let’s refactor the subviews that render our two main pieces of information — the movie’s director and genre — into a single reusable component called <code>InfoView</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> InfoView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> icon: <span class="s-type">Image</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">HStack</span> {
                icon
                <span class="s-type">Text</span>(title)
            }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p class="info">During the refactoring process, we also took the opportunity to make the above view completely unaware of its underlying model — as it now simply renders an icon, a title and a text, rather than a <code>Movie</code> model. Check out <a href="https://www.swiftbysundell.com/articles/preventing-views-from-being-model-aware-in-swift">“Preventing views from being model aware in Swift”</a> to learn more about that approach.</p><p>The above may seem like minor changes in the grand scheme of things, but if we now go back to our <code>MovieList</code> and update it to use our new components, we can see that we’ve actually made its implementation quite a lot easier to read:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>, selection: $selectedMovie) { movie <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>).<span class="s-call">asThumbnail</span>()
                <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                    <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                    <span class="s-type">InfoView</span>(
                        icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>),
                        title: <span class="s-string">"Director:"</span>,
                        text: movie.<span class="s-property">director</span>
                    )
                    <span class="s-type">InfoView</span>(
                        icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>),
                        title: <span class="s-string">"Genre:"</span>,
                        text: movie.<span class="s-property">genre</span>
                    )
                }
            }
        }
    }
}</code></pre><p>Even though we just barely reduced our list view’s line count during or refactor, we’ve now set its implementation up to grow in a much more maintainable fashion, as we can now iterate on each of its individual components separately — which typically goes a long way to prevent views from becoming massive.</p><p>However, let’s not stop there, because the beauty of SwiftUI’s highly composable design is that we can keep splitting our UI up into separate pieces until we’ve reached a level of separation that we’re completely happy with. For example, rather than having <code>MovieList</code> itself be responsible for configuring each of its rows — we could encapsulate all those subviews into yet another component, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> movie: <span class="s-type">Movie</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>).<span class="s-call">thumbnail</span>()
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                <span class="s-type">InfoView</span>(
                    icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>),
                    title: <span class="s-string">"Director:"</span>,
                    text: movie.<span class="s-property">director</span>
                )
                <span class="s-type">InfoView</span>(
                    icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>),
                    title: <span class="s-string">"Genre:"</span>,
                    text: movie.<span class="s-property">genre</span>
                )
            }
        }
    }
}</code></pre><p>While we could’ve also made the above <code>MovieRow</code> model-agnostic, it’s questionable whether doing so would be worth it in this case — as it essentially acts as a <em>“composition layer”</em> between our core components (such as <code>InfoView</code>) and our <code>Movie</code> model.</p><p>With the above in place, we can now go back to <code>MovieList</code> one more time, and heavily simplify its implementation. It can now simply be concerned with one single task — being a list — and let its subviews configure and manage themselves:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>,
            selection: $selectedMovie,
            rowContent: <span class="s-type">MovieRow</span>.<span class="s-property">init</span>
        )
    }
}</code></pre><p>Since SwiftUI will automatically re-render each view whenever any of its data dependencies change, we don’t need to manually manage any form of state between our <code>MovieList</code> and its subviews — it’s all being taken care of by the framework.</p><h2>Binding mutable state</h2><p>However, what if we need one of our subviews to be able to mutate some form of state that’s owned by its parent? While SwiftUI always propagates state changes <em>downward</em> through our view hierarchy, to also make changes <em>upward</em>, we’ll need to create <em>two-way bindings</em> that’ll let updates flow in both directions.</p><p>Let’s now say that we’re working on an app for ordering some form of products, and that we’re looking to refactor our main <code>OrderForm</code> to become more modular — similar to what we did to our <code>MovieList</code> view above. This view uses SwiftUI’s built-in <code>Form</code> API to render a series of sections that each contain input controls for mutating the user’s current <code>Order</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OrderForm: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">var</span> handler: (<span class="s-type">Order</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">@State private var</span> order = <span class="s-type">Order</span>()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">Form</span> {
                <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Shipping address"</span>)) {
                    <span class="s-type">TextField</span>(<span class="s-string">"Name"</span>, text: $order.<span class="s-property">recipient</span>)
                    <span class="s-type">TextField</span>(<span class="s-string">"Address"</span>, text: $order.<span class="s-property">address</span>)
                    <span class="s-type">TextField</span>(<span class="s-string">"Country"</span>, text: $order.<span class="s-property">country</span>)
                }
                <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Product"</span>)) {
                    <span class="s-type">Picker</span>(
                        selection: $order.<span class="s-property">product</span>,
                        label: <span class="s-type">Text</span>(<span class="s-string">"Select product"</span>),
                        content: {
                            <span class="s-type">ForEach</span>(productManager.<span class="s-property">products</span>) { product <span class="s-keyword">in</span>
                                <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">tag</span>(product)
                            }
                        }
                    )
                }
                ...
                <span class="s-type">Button</span>(
                    action: { <span class="s-keyword">self</span>.<span class="s-call">handler</span>(<span class="s-keyword">self</span>.<span class="s-property">order</span>) },
                    label: { <span class="s-type">Text</span>(<span class="s-string">"Place order"</span>) }
                )
            }
        }
    }
}</code></pre><p class="info">Note the use of <code>NavigationView</code> above, which is needed when using the default <code>Picker</code> style on iOS — as such a picker pushes its view for selecting an option onto the current navigation stack.</p><p>So how could we split the above view up while still enabling each part to mutate the same <code>Order</code> state? Let’s take some inspiration from SwiftUI’s built-in views, and use the <code>@Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> to create two-way bindings between our new subviews and their parent’s state. Here’s how we might do just that when extracting our form’s <em>“Shipping address”</em> section:</p><pre class="splash"><code><span class="s-keyword">struct</span> ShippingAddressFormSection: <span class="s-type">View</span> {
    <span class="s-keyword">@Binding var</span> order: <span class="s-type">Order</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Shipping address"</span>)) {
            <span class="s-type">TextField</span>(<span class="s-string">"Name"</span>, text: $order.<span class="s-property">recipient</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Address"</span>, text: $order.<span class="s-property">address</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Country"</span>, text: $order.<span class="s-property">country</span>)
        }
    }
}</code></pre><p>Above we give our new stand-alone section access to the complete <code>Order</code> model, as it needs to mutate several of its properties. However, for the <em>“Product”</em> section, we’ll take a slightly different approach — and only give it access to an array of products to pick from, and a binding <code>Product</code> value to assign the user’s selection to:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductPickerFormSection: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> products: [<span class="s-type">Product</span>]
    <span class="s-keyword">@Binding var</span> selection: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Product"</span>)) {
            <span class="s-type">Picker</span>(selection: $selection, label: <span class="s-type">Text</span>(<span class="s-string">"Select product"</span>)) {
                <span class="s-type">ForEach</span>(products) { product <span class="s-keyword">in</span>
                    <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">tag</span>(product)
                }
            }
        }
    }
}</code></pre><p>Once we’ve extracted all of our sections like we did above, we can then go back to our <code>OrderForm</code> and simply have it pass binding references to its own <code>Order</code> state when creating its sections — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OrderForm: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">var</span> handler: (<span class="s-type">Order</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">@State private var</span> order = <span class="s-type">Order</span>()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">Form</span> {
                <span class="s-type">ShippingAddressFormSection</span>(order: $order)
                <span class="s-type">ProductPickerFormSection</span>(
                    products: productManager.<span class="s-property">products</span>,
                    selection: $order.<span class="s-property">product</span>
                )
                ...
                <span class="s-type">Button</span>(
                    action: { <span class="s-keyword">self</span>.<span class="s-call">handler</span>(<span class="s-keyword">self</span>.<span class="s-property">order</span>) },
                    label: { <span class="s-type">Text</span>(<span class="s-string">"Place order"</span>) }
                )
            }
        }
    }
}</code></pre><p>The fact that we can turn any form of local <code>State</code> property into a two-way <code>Binding</code> value, simply by prefixing it with <code>$</code> (which accesses its <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/%23projected-values">projected value</a></em>), is incredibly powerful — as it gives us complete freedom as to how we split our views up, even if those subviews then need to mutate their parent’s state.</p><h2>Out-of-body delegation</h2><p>Finally, let’s take a look at how we could break some of our larger <code>View</code> implementations up by delegating certain tasks to external objects. For example, let’s say that we’re building a <code>HomeView</code> that acts as the initial navigation destination for an app. It shows a menu implemented as a <code>List</code>, which in turn contains a series of rows each wrapped within a <code>NavigationLink</code>, to enable new views to be pushed onto the navigation stack — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span> {
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Catalog"</span>, icon: .<span class="s-dotAccess">browse</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Recommendations"</span>, icon: .<span class="s-dotAccess">star</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Profile"</span>, icon: .<span class="s-dotAccess">user</span>)
                }
                ...
            }.<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Home"</span>)
        }
    }
}</code></pre><p>Now the question is, how should we create the above <code>destination</code> views? One option would of course be to create each destination inline within the above view itself — however, doing so would not only risk making our <code>HomeView</code> quite massive, it would also require it to carry all of the dependencies needed by each of its destinations.</p><p>While we’ll take a closer look at various ways of managing dependencies when using SwiftUI in much more detail in upcoming articles, one way to prevent <code>HomeView</code> from taking on too many responsibilities in this case would be to introduce a separate object that can handle the complexity of creating all of our destinations.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/">“Dependency injection using factories in Swift”</a></em> and <em><a href="https://www.swiftbysundell.com/articles/managing-objects-using-locks-and-keys-in-swift/">“Managing objects using Locks and Keys in Swift”</a></em>, using the <em>factory pattern</em> can be a great way to decouple various views and screens from the rest of an app — as it lets us move the creation of navigation destinations away from where the navigation is triggered. Here’s how we might do exactly that for our <code>HomeView</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> factory: <span class="s-type">HomeViewFactory</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span> {
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeCatalogView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Catalog"</span>, icon: .<span class="s-dotAccess">browse</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeRecommendationsView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Recommendations"</span>, icon: .<span class="s-dotAccess">star</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeProfileView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Profile"</span>, icon: .<span class="s-dotAccess">user</span>)
                }
                ...
            }.<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Home"</span>)
        }
    }
}</code></pre><p>The <code>HomeViewFactory</code> that we use above can then contain all of the dependencies needed by our destinations, and be responsible for setting up each destination view in a way that leaves <code>HomeView</code> completely unaware of those details:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeViewFactory {
    <span class="s-keyword">var</span> database: <span class="s-type">Database</span>
    <span class="s-keyword">var</span> networkController: <span class="s-type">NetworkController</span>
    ...

    <span class="s-keyword">func</span> makeCatalogView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">let</span> viewModel = <span class="s-type">CatalogViewModel</span>(database: database, ...)
        <span class="s-keyword">return</span> <span class="s-type">CatalogView</span>(viewModel: viewModel)
    }
    
    <span class="s-keyword">func</span> makeRecommendationsView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
    
    <span class="s-keyword">func</span> makeProfileView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>While we probably don’t want to move <em>all</em> of our view creation code into factory types, delegating the setup of complex navigation hierarchies to <em>some form</em> of external object can often be a good idea, and the same is true for other types of complex tasks as well — such as event handling, input validation, and so on.</p><h2>Conclusion</h2><p>The fact that SwiftUI was designed with composition and two-way data binding in mind gives us an enormous amount of flexibility when it comes to how we structure our views and their various components. By starting to break our UIs up into smaller building blocks early, and by making our lower-level components as unaware of our domain-specific models as possible, we can often achieve a very flexible setup that lets us tweak and iterate on our UI with ease.</p><p>While we should always think twice before introducing new abstractions, delegating certain tasks to external objects could also help us make our top-level views simpler — as doing so could let them simply focus on connecting a set of UI components to a specific piece of state, and to mutate that state according to user input.</p><p>What do you think? How do you plan to avoid massive SwiftUI views, both now and as you continue to iterate on your code base? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or via <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-swifts-built-in-randomization-apis</guid><title>Tip: Using Swift’s built-in randomization APIs</title><description></description><link>https://www.swiftbysundell.com/tips/using-swifts-built-in-randomization-apis</link><pubDate>Wed, 4 Mar 2020 21:30:00 +0100</pubDate><content:encoded><![CDATA[<p>Swift offers quite a few different APIs that enable us to add various randomness features to our code. For example, let’s say that we wanted to generate a random number between 0 and 99 — that can be done simply by calling the static <code>random()</code> method on different numeric types, such as <code>Int</code> and <code>Double</code>:</p><pre class="splash"><code><span class="s-keyword">let</span> randomInt = <span class="s-type">Int</span>.<span class="s-call">random</span>(in: <span class="s-number">0</span>..&lt;<span class="s-number">100</span>)
<span class="s-keyword">let</span> randomDouble = <span class="s-type">Double</span>.<span class="s-call">random</span>(in: <span class="s-number">0</span>..&lt;<span class="s-number">100</span>)</code></pre><p>Worth noting is that when generating random <code>Double</code> or <code>Float</code> values (or any other non-integer type), fractional values are also included. So while the above <code>randomInt</code> has 100 potential values, <code>randomDouble</code> can contain any valid <code>Double</code> from <code>0.0</code> to <code>99.99...</code>, giving us an amount of potential values that’s several orders of magnitude larger.</p><p>Swift’s various collections also ship with built-in randomization APIs as well. For example, here’s how we could extract a random element, or completely shuffle a collection:</p><pre class="splash"><code><span class="s-comment">// Drawing a random card from a deck</span>
<span class="s-keyword">let</span> deckOfCards: [<span class="s-type">Card</span>] = <span class="s-call">makeDeck</span>()
<span class="s-keyword">let</span> card = deckOfCards.<span class="s-call">randomElement</span>()

<span class="s-comment">// Shuffling a list of players to randomize who gets to go first</span>
<span class="s-keyword">var</span> players: [<span class="s-type">Player</span>] = <span class="s-call">loadPlayers</span>()
players.<span class="s-call">shuffle</span>()</code></pre><p class="info">Note that <code>randomElement</code> returns an optional, since we might be calling it on an empty collection.</p><p>One thing to keep in mind when adding randomization to a piece of code is how doing so might impact our ability to test that code. When writing unit tests, we’d ideally like to control the entire environment that our code is executed in, as to not cause <a href="https://www.swiftbysundell.com/articles/reducing-flakiness-in-swift-tests">flakiness</a> (when tests start to sporadically fail) — and randomness is kind of the exact opposite of that sort of control.</p><p>To work around that problem, we could use <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">function-based dependency injection</a> to inject the randomization functions that we’re using into the types that we call them from. That way we’ll later be able to override those functions with <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift/%23functional-behavior">predictable stubs</a> within our tests.</p><p>For example, here we’re using that form of dependency injection to inject a <code>Randomizer</code> function into an <code>AudioPlayer</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> AudioPlayer {
    <span class="s-keyword">typealias</span> Randomizer = (<span class="s-type">Range</span>&lt;<span class="s-type">Int</span>&gt;) -&gt; <span class="s-type">Int</span>

    <span class="s-keyword">private let</span> playlist: <span class="s-type">Playlist</span>
    <span class="s-keyword">private let</span> randomizer: <span class="s-type">Randomizer</span>

    <span class="s-keyword">init</span>(playlist: <span class="s-type">Playlist</span>,
         randomizer: <span class="s-keyword">@escaping</span> <span class="s-type">Randomizer</span> = <span class="s-type">Int</span>.<span class="s-property">random</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">playlist</span> = playlist
        <span class="s-keyword">self</span>.<span class="s-property">randomizer</span> = randomizer
    }

    <span class="s-keyword">func</span> playRandomSong() {
        <span class="s-keyword">let</span> index = <span class="s-call">randomizer</span>(<span class="s-number">0</span>..&lt;playlist.<span class="s-property">songs</span>.<span class="s-property">count</span>)
        <span class="s-call">playSong</span>(atIndex: index)
    }
    
    ...
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/splitting-up-swift-types</guid><title>Splitting up Swift types</title><description>This week, let’s take a look at a few tips and techniques that can help us make our types more well-defined, by splitting them up once their responsibilities have started to grow beyond the ideal scope of a single type.</description><link>https://www.swiftbysundell.com/articles/splitting-up-swift-types</link><pubDate>Sun, 1 Mar 2020 20:10:00 +0100</pubDate><content:encoded><![CDATA[<p>The idea that an app’s various features and systems should ideally be kept clearly separated in terms of their responsibilities and concerns is something that’s quite widely accepted across the entire software industry. So many architectural patterns, techniques and principles have been invented over the years in attempts to guide us into writing more clearly decoupled code — both in Swift and in many other languages as well.</p><p>However, regardless of which kind of architecture that we’ve chosen to adopt within any given project, making sure that each of our types has a narrow and clearly defined set of responsibilities can at times be quite challenging — especially as a code base keeps evolving with new features, and in response to platform changes.</p><p>This week, let’s take a look at a few tips and techniques that can help us do just that, by splitting our types up once their responsibilities have started to grow beyond the ideal scope of a single type.</p><h2>States and scopes</h2><p>One really common source of code complexity is when a single type needs to handle multiple scopes and separate states. For example, let’s say that we’re working on the networking layer of an app, and that we’ve currently implemented that entire layer within a single class called <code>NetworkController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> NetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> accessToken: <span class="s-type">AccessToken</span>?
    
    ...

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">Endpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)

        <span class="s-keyword">if let</span> token = accessToken {
            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(token)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
        }

        <span class="s-comment">// Perform the request</span>
        ...
    }
}</code></pre><p class="info">Above we’re using an <code>Endpoint</code> type to define the various server endpoints that our app is communicating with. Check out <a href="https://www.swiftbysundell.com/articles/constructing-urls-in-swift">“Constructing URLs in Swift”</a> for more information on that approach.</p><p>While implementing an entire feature or system within a single class is not necessarily a bad thing, in this case, doing so has left us with a quite major source of ambiguity. Since we’re using the same API to request both public endpoints, as well as those that require authentication, each of the developers on our team needs to always remember which endpoint that belongs to which group — or else we’ll end up with runtime errors when a protected endpoint was accidentally requested without a logged in user.</p><p>It would arguably be a lot better if we could utilize Swift’s type system to prevent any endpoint that requires authentication from being called without a valid access token. That way we would both be able to validate our networking code much more thoroughly at compile time, and also make that system easier to use — as it’d be crystal clear which endpoint that may be requested within any given scope.</p><p>To make that happen, let’s start by moving all of the code that deals with authentication and access tokens out from <code>NetworkController</code> and into a new <em>variant</em> of that class, which we’ll name <code>AuthenticatedNetworkController</code>. Just like its predecessor, our new controller will enable us to perform endpoint-based network calls — only this time we’ll both initialize it with its required tokens, and we’ll also ensure that those tokens are kept up to date before we perform each request, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> AuthenticatedNetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">private var</span> tokens: <span class="s-type">NetworkTokens</span>
    ...

    <span class="s-keyword">init</span>(tokens: <span class="s-type">NetworkTokens</span>, ...) {
        <span class="s-keyword">self</span>.<span class="s-property">tokens</span> = tokens
        ...
    }

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">AuthenticatedEndpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-call">refreshTokensIfNeeded</span> { tokens <span class="s-keyword">in
            var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)

            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(tokens.<span class="s-property">access</span>)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
            
            <span class="s-comment">// Perform the request</span>
            ...
        }
    }
}</code></pre><p>Worth noting is that we’ve also given our new network controller its own, dedicated endpoint type — <code>AuthenticatedEndpoint</code>. That’s to also clearly separate our endpoint definitions, so that an endpoint which requires authentication won’t accidentally be passed to our previous <code>NetworkController</code>.</p><p>Since that type no longer has to deal with any authenticated requests, we can heavily simplify it, and rename it (and its endpoint type) to something that better describes its new role within our networking layer:</p><pre class="splash"><code><span class="s-keyword">class</span> NonAuthenticatedNetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>
    
    ...

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">NonAuthenticatedEndpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)
        ...
    }
}</code></pre><p>However, while the above kind of separation of concerns can give us a huge boost in terms of architecture and API clarity, it can also require a fair amount of code duplication. In this case, both of our network controllers need to create <code>URLRequest</code> instances and perform them, as well as handling tasks like caching and other networking-related operations — so they could still share most of their underlying implementations, even though we wish to keep their APIs separate.</p><p>For starters, rather than having each of our networking-related types declare their own completion handler closure types, let’s define a generic one that they can easily share:</p><pre class="splash"><code><span class="s-keyword">typealias</span> NetworkResultHandler&lt;T&gt; = (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span></code></pre><p>We can then start moving parts of our underlying networking implementations out from the controllers themselves, and into smaller, dedicated types — which should be able to remain fairly stateless. For example, here’s how we could create a private <code>NetworkRequestPerformer</code> type that both of our two controllers can use to actually perform their requests — while still keeping our top-level APIs completely separate and type-safe:</p><pre class="splash"><code><span class="s-keyword">private struct</span> NetworkRequestPerformer {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> accessToken: <span class="s-type">AccessToken</span>?
    <span class="s-keyword">var</span> cache: <span class="s-type">Cache</span>&lt;<span class="s-type">URL</span>, <span class="s-type">Data</span>&gt;

    <span class="s-keyword">func</span> perform(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Data</span>&gt;) {
        <span class="s-keyword">if let</span> data = cache.<span class="s-call">data</span>(forKey: url) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(data))
        }
                        
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: url)

        <span class="s-comment">// This if-statement is no longer a problem, since it's now
        // hidden behind a type-safe abstraction that prevents
        // accidential misuse.</span>
        <span class="s-keyword">if let</span> token = accessToken {
            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(token)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
        }
        
        ...
    }
}</code></pre><p>With the above in place, we can now let both of our network controllers focus solely on providing a type-safe API for performing requests — while their underlying implementations are being kept in sync through privately shared utility types:</p><pre class="splash"><code><span class="s-keyword">class</span> AuthenticatedNetworkController {
    ...

    <span class="s-keyword">func</span> request(
        <span class="s-keyword">_</span> endpoint: <span class="s-type">AuthenticatedEndpoint</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Data</span>&gt;
    ) {
        <span class="s-call">refreshTokensIfNeeded</span> { [cache] tokens <span class="s-keyword">in
            let</span> performer = <span class="s-type">NetworkRequestPerformer</span>(
                url: endpoint.<span class="s-property">url</span>,
                accessToken: tokens.<span class="s-property">access</span>,
                cache: cache
            )

            performer.<span class="s-call">perform</span>(then: handler)
        }
    }
}</code></pre><p>What we’ve essentially done above is to utilize the power of <em>composition</em>, in that we’ve shared various implementations by combining smaller types into the ones that define our public API. However, before we were able to <em>compose</em> our functionality, we first had to <em>decompose</em> the single type that we started out with. Doing that kind of decomposition on an ongoing basis is often key in order to keep a code base in tip-top shape, as our types tend to naturally grow as we add new features and functionality to our code base.</p><h2>Loading versus managing objects</h2><p>Next, let’s take a look at another type of situation which can make certain parts of a code base more complex than they need to be — when the same type is responsible for both <em>loading</em> and <em>managing</em> a given object. A very common example of that is when everything related to user sessions has been implemented within a single type — such as a <code>UserManager</code>.</p><p>For example, here such a type is responsible for both logging users in and out of our app, as well as keeping the currently logged in <code>User</code> instance in sync with our server:</p><pre class="splash"><code><span class="s-keyword">class</span> UserManager {
    <span class="s-keyword">private(set) var</span> user: <span class="s-type">User</span>?
    
    ...

    <span class="s-keyword">func</span> logIn(
        with credentials: <span class="s-type">LoginCredentials</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;
    ) {
        ...
    }

    <span class="s-keyword">func</span> sync(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;) {
        ...
    }

    <span class="s-keyword">func</span> logOut(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Void</span>&gt;) {
        ...
    }
}</code></pre><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/managing-objects-using-locks-and-keys-in-swift">“Managing objects using Locks and Keys in Swift”</a></em>, the main problem with the above sort of approach is that it forces us to implement our <code>User</code> property as an optional — which in turn requires us to unwrap that optional within <em>all features</em> that somehow deals with the currently logged in user — most of which likely <em>rely</em> on that value in order to actually perform their work.</p><p>To quote the article about <em>Locks and Keys</em> that’s linked above:</p><blockquote><p>What we're essentially dealing with here is a <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optional</a></em> — a value that's technically optional, but is actually required by our program logic — meaning that we risk ending up in an undefined state if it's missing, and the compiler has no way of helping us avoid that.</p></blockquote><p>So, without having to fully adopt a Locks and Keys-based architecture within our app — how could we use <em>some</em> of the principles from that design pattern in order to split our <code>UserManager</code> up into smaller, more focused types?</p><p>The first thing we’ll do is to extract all of the code related to loading <code>User</code> instances out from <code>UserManager</code> and into a new, separate type. We’ll call it <code>UserLoader</code>, and it’ll use our <code>AuthenticatedNetworkController</code> from before in order to request our server’s <code>user</code> endpoint, which requires authentication:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networkController: <span class="s-type">AuthenticatedNetworkController</span>

    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;
    ) {
        networkController.<span class="s-call">request</span>(.<span class="s-call">user</span>(withID: id)) { result <span class="s-keyword">in</span>
            <span class="s-comment">// Decode the network result into a User instance,
            // then call the passed handler with the end result.</span>
            ...
        }
    }
}</code></pre><p>By decomposing our <code>UserManager</code> into smaller building blocks, like we did above, we can enable much of our functionality to be implemented as stateless structs — since those types will simply perform tasks on behalf of other objects (just like our <code>NetworkRequestPerformer</code> from before).</p><p>We can keep doing the same thing with our login and logout code as well, for example by creating a <code>LoginPerformer</code> that uses our non-authenticated network controller to send a set of credentials to the server endpoint used to log a user into our app:</p><pre class="splash"><code><span class="s-keyword">struct</span> LoginPerformer {
    <span class="s-keyword">var</span> networking: <span class="s-type">NonAuthenticatedNetworkController</span>

    <span class="s-keyword">func</span> login(
        using credentials: <span class="s-type">LoginCredentials</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">NetworkTokens</span>&gt;
    ) {
        <span class="s-comment">// Send the passed credentials to our server's login
        // endpoint, and then call the passed completion handler
        // with the tokens that were returned.</span>
        ...
    }
}</code></pre><p>The beauty of the above approach is that we can now use either of our new types whenever we need to perform that type’s specific task, rather than always having to use the same <code>UserManager</code> type regardless of whether we’re logging in, out, or simply updating the current user.</p><p>For example, within our login code, we can now use <code>LoginPerformer</code> directly — and we can then use <code>UserLoader</code> to load our newly logged in <code>User</code> before injecting both of those instances into our <code>UserManager</code> — which now only has a single responsibility, to <em>manage</em> our current <code>User</code> instance:</p><pre class="splash"><code><span class="s-keyword">class</span> UserManager {
    <span class="s-keyword">private(set) var</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> loader: <span class="s-type">UserLoader</span>

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, loader: <span class="s-type">UserLoader</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">loader</span> = loader
    }

    <span class="s-keyword">func</span> sync(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;) {
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            if let</span> user = <span class="s-keyword">try</span>? result.<span class="s-call">get</span>() {
                <span class="s-keyword">self</span>?.<span class="s-property">user</span> = user
            }

            <span class="s-call">handler</span>(result)
        }
    }
}</code></pre><p class="info">We could even go ahead and rename the above type to <code>UserModelController</code>, since it’s now essentially a <a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">controller for our user model</a>.</p><p>Not only did the above refactor let us get rid of an unnecessary optional — which in turn should let us remove a whole lot of awkward <code>if</code> and <code>guard</code> statements from any code that relies on a user being logged in — it’ll also give us a greater degree of flexibility, since we’re now able to pick which level of <code>User</code>-related abstraction that we’d like to work with within each new feature that we’ll build.</p><h2>Conclusion</h2><p>Composition is an incredibly powerful concept, but before we can utilize it within our apps, we first need to <em>decompose</em> some of our larger types into smaller building blocks — which can then be assembled into many different combinations and configurations.</p><p>Of course, we always have to try to strike a balance between splitting things up and still keeping our code base consistent and easy to navigate — so the goal is definitely not to split things up as much as possible, but rather to create types that have a narrow set of responsibilities, which can then be combined into higher-level abstractions.</p><p>What do you think? When do you typically decide to split a type up into multiple smaller ones? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/what-makes-code-swifty</guid><title>What makes code “Swifty”?</title><description>The phrase “Swifty code” is often used to describe code that follows the conventions that are currently the most popular within the Swift community. But what exactly does that entail? Let’s take a look.</description><link>https://www.swiftbysundell.com/articles/what-makes-code-swifty</link><pubDate>Sun, 23 Feb 2020 20:35:00 +0100</pubDate><content:encoded><![CDATA[<p>Although programming languages are formally defined by their syntax, the ways in which they get used in practice are arguably just as much determined by their <em>current conventions</em>. After all, syntax-wise, most <em>“C-influenced”</em> languages look incredibly similar — to the point where you could write Swift in ways that almost makes it look like JavaScript, or C#, or C itself.</p><p>Within the Swift community, the phrase <em>“Swifty code”</em> is often used to describe code that follows the conventions that are currently the most popular. However, while Swift’s core syntax hasn’t changed <em>that</em> much since its original introduction, its conventions have dramatically shifted over time.</p><p>For example, many Swift developers remember the transition from Swift 2 to Swift 3 as a big change in terms of syntax, but the majority of those changes weren’t really <em>syntax changes</em> — they were changes to the standard library’s API based on a new set of naming conventions. Add Swift 4’s introduction of <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> and <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a>, Swift 5.1’s <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/">function builders, property wrappers and opaque return types</a>, and many more APIs and features that have been introduced over the years — and it’s starting to become quite clear that what makes code <em>“Swifty”</em> is somewhat of a <em>moving target</em>.</p><p>This week, let’s take a closer look at Swift’s core set of conventions, to try to come up with an answer to the question of <em>what really does make code “Swifty”</em>?</p><h2>Aligned goals</h2><p>In a way, a simple answer to the above question could be <em>“code that’s well-aligned with Swift’s core set of goals”</em>. After all, while Swift’s various APIs, conventions and language features tend to change over time, its fundamental goals mostly remain the same — so if we can write our own code in ways that matches those goals, then we’ll have a much better chance of making our code feel natural and clear within any given Swift context.</p><p>So, what exactly are those goals? The <a href="https://swift.org/about">about page on Swift’s official website</a> lists three keywords: <strong>Safe</strong> in terms of minimizing developer mistakes, <strong>Fast</strong> when it comes to speed of execution, and <strong>Expressive</strong>, in that Swift aims to be as clear and as easy to understand as possible.</p><p>Let’s take a look at a few different things that can be good to keep in mind in order to make our own code follow those principles.</p><h2>Clarity through strong type safety</h2><p>Let’s start with the first keyword — <em>safety</em>. The fact that Swift puts a very strong emphasis on type safety is hard to miss — with its static type checks, a powerful generics system, and the need to do things like <a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">type erasure</a> in order for the compiler to be able to verify our code’s structure as it’s being compiled.</p><p>However, it’s quite common to encounter situations in which it’s less obvious that our code’s type safety could be improved — which could also make it feel more <em>“Swifty”</em>, and in turn, become easier to work with. For example, here we’re storing a collection of notes based on the name of the group that they belong to:</p><pre class="splash"><code><span class="s-keyword">struct</span> NoteCollection {
    <span class="s-keyword">var</span> notesByGroup: [<span class="s-type">String</span> : [<span class="s-type">Note</span>]]
    ...
}</code></pre><p>At first glance, the above code may seem perfectly fine. However, one detail that’s not at all obvious when looking at the declaration above is how we’re dealing with ungrouped values, as well as with a special group containing all of the user’s recently opened notes — which is currently done by either passing an empty string, or <code>"recent"</code>, when subscripting our dictionary:</p><pre class="splash"><code><span class="s-keyword">let</span> groupedNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">"MyGroup"</span>]
<span class="s-keyword">let</span> ungroupedNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">""</span>]
<span class="s-keyword">let</span> recentNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">"recent"</span>]</code></pre><p>While the above design may have a perfectly valid justification (for example, the structure we’ve used might be how our notes are organized when loading them over the network), it does lead to some of our call sites becoming quite cryptic — which in turn increases the chances of developer mistakes. It’s easy to forget that an empty string means that all ungrouped notes should be retrieved, and what happens if the user names one of their custom groups <em>“recent”</em>?</p><p>Let’s see if we can make the above code more type safe, and in doing that, make it feel more <em>“Swifty”</em> as well. Since we have three distinct use cases for our <code>notesByGroup</code> dictionary, let’s replace its <code>String</code>-based keys with a custom enum that models those three variants as distinct cases, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Group: <span class="s-type">Hashable</span> {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> recent
    <span class="s-keyword">case</span> named(<span class="s-type">String</span>)
}

<span class="s-keyword">struct</span> NoteCollection {
    <span class="s-keyword">var</span> notesByGroup: [<span class="s-type">Group</span> : [<span class="s-type">Note</span>]]
    ...
}</code></pre><p>The above may seem like a subtle change, but it makes our call sites a lot more clear, since we’re now leveraging the type system to distinguish between our three separate types of groups — all without making our API any more complex:</p><pre class="splash"><code><span class="s-keyword">let</span> groupedNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-call">named</span>(<span class="s-string">"MyGroup"</span>)]
<span class="s-keyword">let</span> ungroupedNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-dotAccess">none</span>]
<span class="s-keyword">let</span> recentNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-dotAccess">recent</span>]</code></pre><p>That’s perhaps the essence of what makes code <em>“Swifty”</em> in terms of type safety. While there are many ways to make an API really complicated in order to make it more type-safe, the trick is to use Swift’s language features to find a way to add that type safety without making our code harder to understand or use.</p><p>While type safety is commonly used to prevent a value of type <code>B</code> from incorrectly being passed to an API that accepts <code>A</code>, strong typing also often provides a way to improve the semantics and logic of our code as well. In the following example, our code is <em>technically</em> type-safe — as we are using Swift’s <a href="https://www.swiftbysundell.com/basics/generics">generics feature</a> to implement a <code>LoadingOperation</code> that can load any <code>Resource</code> that conforms to a <code>Loadable</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> LoadingOperation&lt;Resource: <span class="s-type">Loadable</span>&gt; {
    <span class="s-keyword">private let</span> resource: <span class="s-type">Resource</span>

    <span class="s-keyword">init</span>(resource: <span class="s-type">Resource</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">resource</span> = resource

        <span class="s-keyword">if let</span> preloadable = resource <span class="s-keyword">as</span>? <span class="s-type">Preloadable</span> {
            preloadable.<span class="s-call">preload</span>()
        }
    }
    
    ...
}</code></pre><p>However, the fact that we’re conditionally casting our <code>resource</code> to see if it also conforms to <code>Preloadable</code> (and if so, we preload that resource) is arguably a bit strange. Not only does the above implementation make it hard to understand how to make a resource preload (as the type system doesn’t give us any hints that we’re supposed to conform to <code>Preloadable</code> to make that happen), it’s also quite unintuitive to have preloading be a <a href="https://www.swiftbysundell.com/articles/initializers-in-swift/%23avoiding-complexity-and-side-effects">side-effect of initializing</a> an operation.</p><p>Instead, let’s make preloading an explicit API that’s only available when an operation’s <code>Resource</code> conforms to <code>Preloadable</code> — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">LoadingOperation</span> <span class="s-keyword">where</span> <span class="s-type">Resource</span>: <span class="s-type">Preloadable</span> {
    <span class="s-keyword">func</span> preload() {
        resource.<span class="s-call">preload</span>()
    }
}</code></pre><p>The above change both makes it a lot more clear what the conditions are for a resource to be preloaded, and we can now remove our type casting side-effect from our initializer — big win!</p><p>What’s important to note is that writing <em>“Swifty”</em> code from a safety perspective is definitely <strong>not</strong> about using generics as much as possible. Rather, it’s about using the type system’s various aspects and features <em>selectively</em> to make our code easier to understand and use (and harder to misuse).</p><h2>The path to performance</h2><p>The second of Swift’s core goals, to be <em>fast</em>, is something that’s a bit trickier to reason about in general terms. After all, a major part of writing high-performance code comes down to measuring, fine-tuning, and measuring again. However, one way to make our code more aligned with Swift itself in terms of performance is to make full use of what the standard library has to offer — particularly when working with collections, such as strings.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/string-parsing-in-swift">“String parsing in Swift”</a></em> and <em><a href="https://www.swiftbysundell.com/articles/slicing-swift-collections">“Slicing Swift collections”</a></em>, the Swift standard library is highly optimized for performance, and enables us to perform many common collection operations in a highly efficient manner — given that we use the right APIs, that is.</p><p>For example, one common way to remove a certain set of characters from a string is to use the old <code>replacingOccurences(of:with:)</code> API that Swift’s <code>String</code> type inherited from its Objective-C cousin, <code>NSString</code>. Here we’re using a series of calls to that API to sanitize a string by removing a set of special characters:</p><pre class="splash"><code><span class="s-keyword">let</span> sanitizedString = string
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"@"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"#"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"&lt;"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"&gt;"</span>, with: <span class="s-string">""</span>)</code></pre><p>The problem with the above implementation is that it’ll cause 4 separate iterations through our string — which might not be a problem when working with shorter strings, or when doing the above within a code path that’s not hit very often, but it could become a bottleneck in situations when we need maximum performance.</p><p>Thankfully, Swift often doesn’t require us to pick between performant code and elegant code — all we have to do is to switch to a more appropriate API, one that just makes one pass through our string in order to remove each character that’s contained within a <code>Set</code>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> charactersToRemove: <span class="s-type">Set</span>&lt;<span class="s-type">Character</span>&gt; = [<span class="s-string">"@"</span>, <span class="s-string">"#"</span>, <span class="s-string">"&lt;"</span>, <span class="s-string">"&gt;"</span>]
string.<span class="s-call">removeAll</span>(where: charactersToRemove.<span class="s-property">contains</span>)</code></pre><p>So, to make our code more <em>“Swifty”</em> from a performance point of view, sometimes all that we have to do is to explore what the standard library has to offer when faced with a given task — and especially when it comes to collections, chances are quite high that there’s an elegant, simple API that also gives us great performance characteristics available.</p><h2>Clear, expressive naming</h2><p>Finally, let’s take a look at the third and last keyword — <em>expressive</em>. While it’s easy to think of expressiveness as something that’s purely cosmetic, and that involves nitpicking method names until they all read as grammatically perfect English sentences, it’s ultimately all about making our code clearly convey its <em>meaning</em>.</p><p>Let’s say that we’ve written a function that’s currently called <code>getContent</code>, which loads the data for a bundled <code>Content</code> model, and then decodes it:</p><pre class="splash"><code><span class="s-keyword">func</span> getContent(name: <span class="s-type">String</span>) -&gt; <span class="s-type">Content</span>? {
    <span class="s-keyword">guard let</span> url = <span class="s-type">Bundle</span>.<span class="s-property">main</span>.<span class="s-call">url</span>(
        forResource: name,
        withExtension: <span class="s-string">"json"</span>
    ) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">guard let</span> data = <span class="s-keyword">try</span>? <span class="s-type">Data</span>(contentsOf: url) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">return try</span>? <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">Content</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>Again, at first glance the above function may seem perfectly fine. There are no obvious bugs, and it gets the job done. However, in terms of being <em>expressive</em>, it could definitely be improved.</p><p>First of all, its current name — <em>”get content”</em> — doesn’t really tell us <em>how</em> the content will be retrieved. Will it simply be created as a new instance, will it be loaded over the network, or something else? Also, the fact that it simply returns <code>nil</code> in case an error occurred could make it harder to debug in case something ever starts to fail — since we won’t get any indication as to what <em>actually</em> went wrong.</p><p>So let’s see if we can improve things, by first renaming our function to <code>loadBundledContent</code> (to make it clear that we’re loading the content from our app bundle). We’ll also give it an external parameter label to make it read a bit nicer, and finally, we’ll make it report any error that it encountered by throwing it — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> loadBundledContent(named name: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Content</span> {
    <span class="s-keyword">guard let</span> url = <span class="s-type">Bundle</span>.<span class="s-property">main</span>.<span class="s-call">url</span>(
        forResource: name,
        withExtension: <span class="s-string">"json"</span>
    ) <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-property">missing</span>
    }

    <span class="s-keyword">guard let</span> data = <span class="s-keyword">try</span>? <span class="s-type">Data</span>(contentsOf: url) <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-property">missing</span>
    }

    <span class="s-keyword">do</span> {
        <span class="s-keyword">return try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">Content</span>.<span class="s-keyword">self</span>, from: data)
    } <span class="s-keyword">catch</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-call">decodingFailed</span>(error)
    }
}</code></pre><p class="info">For more on the above way of designing throwing APIs, check out the very first article on this site — <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">“Providing a unified Swift error API”</a>.</p><p>Here’s what the call site looks like before and after our change:</p><pre class="splash"><code><span class="s-comment">// Before</span>
<span class="s-keyword">let</span> content = <span class="s-call">getContent</span>(name: <span class="s-string">"Onboarding"</span>)

<span class="s-comment">// After</span>
<span class="s-keyword">let</span> content = <span class="s-keyword">try</span> <span class="s-call">loadBundledContent</span>(named: <span class="s-string">"Onboarding"</span>)</code></pre><p>While it’s important not to get <em>too</em> hung up on what we name our functions and types (it’s often a matter of taste and preference, after all), if we can find ways to more clearly convey what each of our APIs do, then that’s a big win — as it not only makes it easier for new developers to familiarize themselves with our code base, it can also often make our code more pleasant to work with long-term.</p><h2>Conclusion</h2><p>In my opinion, writing <em>“Swifty”</em> code is not about using as many language features as possible, or about making our code needlessly complex by deploying Swift’s most advanced features to solve simple problems — it’s about aligning the way we design and express our code and its various APIs with Swift’s core set of principles.</p><p>By making our code use Swift’s type system both to ensure correctness and to make its functionality more clear, by fully utilizing the standard library, and by conveying the intent of our code through expressive naming and <a href="https://www.swiftbysundell.com/tags/api-design">API design</a> — we often end up with code that better matches Swift itself, and isn’t that what writing <em>“Swifty”</em> code is all about?</p><p>Got questions, comments or feedback? I’d love to hear from you! Either find me <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">send me an email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values</guid><title>Tip: Using SwiftUI’s ForEach with raw values</title><description></description><link>https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values</link><pubDate>Fri, 21 Feb 2020 19:00:00 +0100</pubDate><content:encoded><![CDATA[<p>SwiftUI’s <code>ForEach</code> type enables us to create a series of views by transforming each element within a collection. However, since <code>ForEach</code> reuses the views that it creates in order to optimize performance (just like other list-based views, like <code>UITableView</code> and <code>UICollectionView</code>, do), it requires us to provide a way to identify each of the elements that we’re basing its views on.</p><p>When the elements that we’re transforming conform to the <code>Identifiable</code> protocol, that kind of identification is taken care of automatically, and we can simply pass our collection of values directly to <code>ForEach</code>. For example, here we’re transforming an array of <code>User</code> values into a list of vertically arranged <code>UserView</code> instances:</p><pre class="splash"><code><span class="s-keyword">struct</span> User: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> UserList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> users = [<span class="s-type">User</span>]()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">ForEach</span>(users) { user <span class="s-keyword">in</span>
                <span class="s-type">UserView</span>(user: user)
            }
        }
    }
}</code></pre><p class="info">Note how we could’ve written the above <code>ForEach</code> expression as <code>ForEach(users, content: UserView.init)</code>, since Swift supports <a href="https://www.swiftbysundell.com/clips/1">first class functions</a>.</p><p>However, sometimes we might want to base a <code>ForEach</code> on a collection of simpler, raw values — such as strings. Doing that might initially seem difficult, since we wouldn’t want to make <code>String</code> unconditionally conform to <code>Identifiable</code>. Thankfully, there’s a way to make that happen, by using the <code>\.self</code> key path to compute each element’s identifier — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-comment">// Using '\.self', we can refer to each element directly,
            // and use the element's own value as its identifier:</span>
            <span class="s-type">ForEach</span>(tags, id: \.<span class="s-keyword">self</span>) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre><p>Another option would of course be to wrap our raw values using an <code>Identifiable</code> type, for example like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Tag: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">var</span> id: <span class="s-type">String</span> { name }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">Tag</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(tags) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag.<span class="s-property">name</span>)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre><p class="info">When using either of the above two techniques, it’s important to first make sure that the values that we’re dealing with are all unique (at least within that collection), since otherwise <code>ForEach</code> might incorrectly reuse the resulting views.</p><p>Finally, if we plan to use <code>ForEach</code> with raw values in several places throughout our code base, we might want to create a simple convenience API for doing that, to avoid having to repeat that <code>\.self</code> key path argument within all those places:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ForEach</span> <span class="s-keyword">where</span> <span class="s-type">Data</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span>, <span class="s-type">ID</span> == <span class="s-type">Data</span>.<span class="s-type">Element</span>, <span class="s-type">Content</span>: <span class="s-type">View</span> {
    <span class="s-keyword">init</span>(values: <span class="s-type">Data</span>, content: <span class="s-keyword">@escaping</span> (<span class="s-type">Data</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(values, id: \.<span class="s-keyword">self</span>, content: content)
    }
}</code></pre><p class="info">Note how we use an external parameter label above, which the built-in <code>ForEach</code> APIs don’t. That’s very much by design, to avoid collisions, for example when using <code>Range&lt;Int&gt;</code>, which <code>ForEach</code> natively supports.</p><p>With the above extension in place we can now easily pass any collection of raw values, such as strings and integers, to <code>ForEach</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(values: tags) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/optional-swiftui-views</guid><title>Tip: Optional SwiftUI views</title><description></description><link>https://www.swiftbysundell.com/tips/optional-swiftui-views</link><pubDate>Tue, 18 Feb 2020 17:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Sometimes we might want one of our SwiftUI views to only be constructed and shown in case a certain optional value is available. For example, here we’re building a <code>HomeView</code> that should conditionally contain a <code>ProfileView</code> whenever a <code>LogInManager</code> contains a <code>loggedInUser</code> — which we’ve tried implementing using a standard <code>if let</code> statement:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-keyword">if let</span> user = loginManager.<span class="s-property">loggedInUser</span> {
                <span class="s-type">ProfileView</span>(user: user)
            }

            ...
        }
    }
}</code></pre><p>Unfortunately, the above code will give us a compiler error:</p><p class="info">Closure containing control flow statement cannot be used with function builder <code>ViewBuilder</code>.</p><p>Since SwiftUI (for the most part) doesn’t use standard closures, but rather <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builders</a>, we can’t put any arbitrary code within the closures used to configure views like <code>HStack</code> and <code>VStack</code>. So how can we handle optionals like the one above?</p><p>One way would be to push the responsibility of handling such optionals into the views that actually consume them. For example, here’s how we could make our <code>ProfileView</code> accept an optional <code>User</code>, rather than a concrete value:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProfileView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> user: <span class="s-type">User</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">guard let</span> user = user <span class="s-keyword">else</span> {
            <span class="s-comment">// We have to use 'AnyView' to perform type erasure here,
            // in order to give our 'body' a single return type:</span>
            <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(<span class="s-type">EmptyView</span>())
        }

        <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(<span class="s-type">VStack</span> {
            <span class="s-type">Text</span>(user.<span class="s-property">name</span>)
            ...
        })
    }
}</code></pre><p>The above works, but isn’t very elegant. After all, it doesn’t make much sense to create a <code>ProfileView</code> for a <code>nil</code> user. So let’s try another approach instead, for example by using <code>map</code> on our optional <code>User</code>, in order to conditionally convert it into a <code>ProfileView</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            loginManager.<span class="s-property">loggedInUser</span>.<span class="s-call">map</span> { user <span class="s-keyword">in</span>
                <span class="s-type">ProfileView</span>(user: user)
            }
            ...
        }
    }
}</code></pre><p class="info">To learn more about the above way of mapping an optional value into a new type, check out the <a href="https://www.swiftbysundell.com/basics/optionals">Basics article about optionals</a>.</p><p>That’s much nicer, as we no longer have to manually construct an <code>EmptyView</code> in case our <code>User</code> value is missing — and it also makes it possible for us to again have <code>ProfileView</code> accept a concrete <code>User</code>, rather than an optional. But perhaps we could take things even further?</p><p>The cool thing about SwiftUI’s <code>@ViewBuilder</code> function builder is that it isn’t a private implementation detail of SwiftUI itself, but rather a public attribute that we can annotate our own functions and closures with as well.</p><p>Using that attribute, we could construct an <code>Unwrap</code> view — that’ll accept an optional value, and a <code>@ViewBuilder</code> closure for transforming any non-<code>nil</code> value into a <code>View</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Unwrap&lt;Value, Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> value: <span class="s-type">Value</span>?
    <span class="s-keyword">private let</span> contentProvider: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Content</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>?,
         <span class="s-keyword">@ViewBuilder</span> content: <span class="s-keyword">@escaping</span> (<span class="s-type">Value</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
        <span class="s-keyword">self</span>.<span class="s-property">contentProvider</span> = content
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        value.<span class="s-call">map</span>(contentProvider)
    }
}</code></pre><p>With the above in place, we can now not only make our optional-unwrapping UI code read nicer, but we can also make full use of SwiftUI’s DSL when constructing our optional views — since we’re using the same <code>@ViewBuilder</code> functionality that SwiftUI itself uses. For example, we could now easily construct an entire optional view hierarchy like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Unwrap</span>(loginManager.<span class="s-property">loggedInUser</span>) { user <span class="s-keyword">in</span>
                <span class="s-type">HStack</span> {
                    <span class="s-type">Text</span>(<span class="s-string">"Logged in as:"</span>)
                    <span class="s-type">ProfileView</span>(user: user)
                }
            }
            ...
        }
    }
}</code></pre><p>We could also do something similar for modifiers as well, but let’s save that for a future article, shall we? 😀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/configuring-swiftui-views</guid><title>Configuring SwiftUI views</title><description>This week, let’s take a look at a few different ways of configuring views when using SwiftUI, and the sort of pros and cons that each of those approaches gives us in terms of code structure and flexibility.</description><link>https://www.swiftbysundell.com/articles/configuring-swiftui-views</link><pubDate>Sun, 16 Feb 2020 21:35:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the key ways that SwiftUI is different compared to Apple’s previous UI frameworks is how its views are created and configured. In fact, it could be argued that when using SwiftUI, we never actually <em>create</em> any views at all — instead we simply <em>describe</em> what we want our UI to look like, and then the system takes care of the actual rendering.</p><p>This week, let’s take a look at a few different techniques for structuring those view descriptions, and the sort of pros and cons that each of those approaches gives us in terms of code structure and flexibility.</p><h2>Initializers, modifiers and inheritance</h2><p>Overall, there are three different ways to configure a SwiftUI view — by passing arguments to its initializer, using modifiers, and through its surrounding environment. For example, here we’re configuring a <code>Text</code> view that acts as the <code>body</code> of a <code>TitleView</code> — using both its initializer, and by applying <em>modifiers</em> to it in order to change its font and text color:</p><pre class="splash"><code><span class="s-keyword">struct</span> TitleView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Text</span>(title)
            .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            .<span class="s-call">italic</span>()
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">blue</span>)
    }
}</code></pre><p class="info">The above way of chaining modifiers together, rather than mutating a single value, is a big part of what separates SwiftUI’s declarative programming style from how UIs are constructed when using imperative frameworks, such as UIKit or AppKit.</p><p>The above is an example of <em>direct configuration</em>, as we’re explicitly setting up and modifying our <code>Text</code> view by directly calling methods on it. However, SwiftUI also supports <em>indirect configuration</em>, as many different modifiers and properties are automatically propagated down through each given view hierarchy.</p><p>That sort of indirect, inherited configuration can be incredibly useful in situations when we want multiple sibling views to adopt the same sort of configuration or styling — like in the following case, in which we configure both a <code>Text</code> and a <code>List</code> to display all of their text using a monospaced font, simply by assigning that font to their parent <code>VStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
    <span class="s-keyword">@Binding var</span> selectedItem: <span class="s-type">Item</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Text</span>(title).<span class="s-call">bold</span>()
            <span class="s-type">List</span>(items, selection: $selectedItem) { item <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(item.<span class="s-property">title</span>)
            }
        }.<span class="s-call">font</span>(.<span class="s-call">system</span>(.<span class="s-dotAccess">body</span>, design: .<span class="s-dotAccess">monospaced</span>))
    }
}</code></pre><p>The fact that entire SwiftUI view hierarchies can be configured through their parent is incredibly powerful, as it lets us apply shared styles and configurations without having to modify each view separately. Not only does that often lead to less code, but it also establishes a single source of truth for our shared configurations — like fonts, colors, and so on — without requiring us to introduce any sort of abstraction to make that happen.</p><p>Let’s take a look at another example, in which we change an entire navigation stack’s <code>accentColor</code> simply by assigning it to our root <code>NavigationView</code> — which will cause that color to be applied to all child views, including those managed by the system, such as any navigation bar items that we’ve defined:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContactListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> contacts: <span class="s-type">ContactList</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(contacts) { contact <span class="s-keyword">in</span>
                ...
            }
            .<span class="s-call">navigationBarItems</span>(
                trailing: <span class="s-type">Button</span>(
                    action: { ... },
                    label: {
                        <span class="s-comment">// This image will be colored purple</span>
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"person.badge.plus"</span>)
                    }
                )
            )
        }.<span class="s-call">accentColor</span>(.<span class="s-dotAccess">purple</span>)
    }
}</code></pre><p>However, sometimes we might want to apply a set of styles to a group of views without having to change their relationship to their parent view. For example, let’s say that we’re building a view for displaying an address within an app, which consists of a series of stacked <code>Text</code> views:</p><pre class="splash"><code><span class="s-keyword">struct</span> AddressView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> address: <span class="s-type">Address</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Text</span>(address.<span class="s-property">recipient</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            <span class="s-type">Text</span>(address.<span class="s-property">street</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(address.<span class="s-property">postCode</span>)
                <span class="s-type">Text</span>(address.<span class="s-property">city</span>)
            }
            <span class="s-type">Text</span>(address.<span class="s-property">country</span>)
        }
    }
}</code></pre><p>Above we’re assigning the exact same styling to our first two labels, so let’s see if we can unify that code to avoid having to repeat it. In this case, we can’t apply our modifiers to our labels’ parent view, since we only want to apply the given styles to a subset of its children.</p><p>Thankfully, SwiftUI also ships with a <code>Group</code> type, which lets us treat a set of views as a group — without affecting their layout, drawing, or position within our overall view hierarchy. Using that type, we can group our two labels together, and then apply our set of modifiers to both of them at the same time:</p><pre class="splash"><code><span class="s-keyword">struct</span> AddressView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> address: <span class="s-type">Address</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Group</span> {
                <span class="s-type">Text</span>(address.<span class="s-property">recipient</span>)
                <span class="s-type">Text</span>(address.<span class="s-property">street</span>)
            }
            .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            .<span class="s-call">padding</span>(<span class="s-number">3</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            ...
        }
    }
}</code></pre><p>The power of <code>Group</code> is that it applies its modifiers directly to its children, rather than to itself. Compare that to if we would’ve grouped our labels using another <code>VStack</code> instead, which would’ve caused the padding and background color to be applied to that stack, rather than to our labels individually.</p><h2>Views versus extensions</h2><p>As our SwiftUI-based views grow in complexity, we likely need to start using multiple ways of grouping and sharing our various configurations and styles, in order to keep our code easy to work with. So far, we’ve mostly been dealing with styling through modifiers, but a major part of our UI configuration also comes down to how we structure our views themselves.</p><p>Let’s say that we’re working on a form that lets a user sign up for an account within an app. To make our form look a bit nicer, we’re prefixing each of our text fields with icons from Apple’s <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols library</a> — giving us an implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...
    <span class="s-keyword">@State private var</span> username = <span class="s-string">""</span>
    <span class="s-keyword">@State private var</span> email = <span class="s-string">""</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            <span class="s-type">Text</span>(<span class="s-string">"Sign up"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"person.circle.fill"</span>)
                <span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
            }
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"envelope.circle.fill"</span>)
                <span class="s-type">TextField</span>(<span class="s-string">"Email"</span>, text: $email)
            }
            <span class="s-type">Button</span>(
                action: { ... },
                label: { <span class="s-type">Text</span>(<span class="s-string">"Continue"</span>) }
            )
        }
    }
}</code></pre><p>Above we’re using the same <code>HStack</code> + <code>Image</code> + <code>TextField</code> combination twice, and while that isn’t necessarily a problem given that we’re configuring each of our two text fields quite differently — let’s say that we also wanted to turn that combination into a stand-alone component that we could reuse in other places throughout our app.</p><p>An initial idea on how to do that might be to create a new <code>View</code> type which takes an <code>iconName</code> and <code>title</code> to display, as well as a <code>@Binding</code> reference to the <code>text</code> property that we wish to update whenever our component’s text field was edited — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> IconPrefixedTextField: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">@Binding var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
            <span class="s-type">TextField</span>(title, text: $text)
        }
    }
}</code></pre><p>With the above in place, we can now go back to <code>SignUpForm</code> and replace our previously duplicated <code>HStack</code> configurations with instances of our new <code>IconPrefixedTextField</code> component:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            ...
            <span class="s-type">IconPrefixedTextField</span>(
                iconName: <span class="s-string">"person.circle.fill"</span>,
                title: <span class="s-string">"Username"</span>,
                text: $username
            )
            <span class="s-type">IconPrefixedTextField</span>(
                iconName: <span class="s-string">"envelope.circle.fill"</span>,
                title: <span class="s-string">"Email"</span>,
                text: $email
            )
            ...
        }
    }
}</code></pre><p>However, while the above change will enable us to reuse our new <code>IconPrefixedTextField</code> type outside of <code>SignUpForm</code>, it’s questionable whether it actually ended up <em>improving</em> our original code. After all, we didn’t really make our sign up form’s implementation <em>simpler</em> — in fact, our above call site arguably looks more complex than what it did before.</p><p>Instead, let’s take some inspiration from SwiftUI’s own API design, and see what things would look like if we implemented our text view configuration code as a <code>View</code> extension instead. That way, any view could be prefixed with an icon, simply by calling the following method:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> prefixedWithIcon(named name: <span class="s-type">String</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(systemName: name)
            <span class="s-keyword">self</span>
        }
    }
}</code></pre><p>With the above in place, we can now add any SF Symbols icon directly to SwiftUI’s native <code>TextField</code> views — or to any other view — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            ...
            <span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
                .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"person.circle.fill"</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Email"</span>, text: $email)
                .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"envelope.circle.fill"</span>)
            ...
        }
    }
}</code></pre><p>Picking between building a new <code>View</code> implementation and an extension can sometimes be quite difficult, and there’s really no clear-cut right-or-wrong way of doing things here. However, when we find ourselves creating new <code>View</code> types that just pass properties along to other views, it’s probably worth asking ourselves whether that code would work better as an extension instead.</p><h2>Modifier types</h2><p>Apart from writing <code>View</code> extensions, SwiftUI also enables us to define custom view modifiers as types conforming to the <code>ViewModifier</code> protocol. Doing so enables us to write modifiers that have their own properties, state and lifecycle — which can be used to extend SwiftUI with all sorts of new functionality.</p><p>For example, let’s say that we wanted to add inline validation to our sign up form from before, by turning each text field’s border green once the user entered a valid string. While that’s something that we could’ve implemented within our <code>SignUpForm</code> view directly, let’s instead build that feature as a completely reusable <code>ViewModifier</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Validation&lt;Value&gt;: <span class="s-type">ViewModifier</span> {
    <span class="s-keyword">var</span> value: <span class="s-type">Value</span>
    <span class="s-keyword">var</span> validator: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">func</span> body(content: <span class="s-type">Content</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Here we use Group to perform type erasure, to give our
        // method a single return type, as applying the 'border'
        // modifier causes a different type to be returned:</span>
        <span class="s-type">Group</span> {
            <span class="s-keyword">if</span> <span class="s-call">validator</span>(value) {
                content.<span class="s-call">border</span>(<span class="s-type">Color</span>.<span class="s-property">green</span>)
            } <span class="s-keyword">else</span> {
                content
            }
        }
    }
}</code></pre><p>Looking at the above implementation, we can see that a <code>ViewModifier</code> looks very much like a view, in that it has a <code>body</code> that returns <code>some View</code>. The difference is that a modifier operates on an existing view (passed in as <code>Content</code>), rather than being completely stand-alone. The benefit is that we can now add our new validation functionality to any text field (or any view, really), just like when using a <code>View</code> extension, without requiring us build any form of wrapper type:</p><pre class="splash"><code><span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
    .<span class="s-call">modifier</span>(<span class="s-type">Validation</span>(value: username) { name <span class="s-keyword">in</span>
        name.<span class="s-property">count</span> &gt; <span class="s-number">4</span>
    })
    .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"person.circle.fill"</span>)</code></pre><p>Just like when picking between an extension and a brand new <code>View</code> implementation, choosing when to implement a given view configuration as a <code>ViewModifier</code> is most likely going to be a matter of preference and style in many situations.</p><p>However, both the <code>ViewModifier</code> and <code>View</code> types have the advantage that they can contain their own set of state and properties, while extensions are much more lightweight. We’ll take a much closer look at SwiftUI-based state and data management in upcoming articles.</p><h2>Conclusion</h2><p>Just like its predecessors, SwiftUI offers a number of ways for us to structure our UI code and the way we configure our various views. While many of our custom components are likely going to be implemented as stand-alone <code>View</code> types, building our own extensions and modifiers can enable us to share styles and configurations across a code base in a much more lightweight manner — and can let us apply those configurations to more than just one type of view.</p><p>How have you been structuring your SwiftUI code so far? Have you used any of the techniques covered in this article already, or will you try them out? Let me know — along with your questions, comments and feedback — either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/optionals</guid><title>Basics: Optionals</title><description>Let’s explore how optional values work in Swift, including how they’re implemented under the hood, and what sort of techniques that we can use to handle them.</description><link>https://www.swiftbysundell.com/basics/optionals</link><pubDate>Tue, 11 Feb 2020 14:25:00 +0100</pubDate><content:encoded><![CDATA[<p>One key part of Swift’s overall design is how it requires us to explicitly handle values that might be <em>missing</em>, or <em>optional</em>. While that requirement often forces us to think more thoroughly about how we construct our objects and manage our state — it also arguably leads to fewer unhandled runtime errors caused by missing data.</p><p>In Swift, a value is marked as optional by adding a question mark right after its type, which in turn requires us to <em>unwrap</em> that value before it can be used in any concrete way. For example, here we’re using an <code>if let</code> statement to unwrap an optional <code>User</code> value in order to determine whether a user has logged into our app:</p><pre class="splash"><code><span class="s-keyword">func</span> setupApp(forUser user: <span class="s-type">User</span>?) {
    <span class="s-keyword">if let</span> user = user {
        <span class="s-call">showHomeScreen</span>(for: user)
    } <span class="s-keyword">else</span> {
        <span class="s-call">showLoginScreen</span>()
    }
}</code></pre><p>While there are multiple ways to unwrap and handle optionals, another very common pattern is to use the <code>guard</code> statement to <em><a href="https://www.swiftbysundell.com/articles/early-returning-functions-in-swift">return early</a></em> in case an optional value is missing. Here’s how we might refactor the above function to use that pattern instead:</p><pre class="splash"><code><span class="s-keyword">func</span> setupApp(forUser user: <span class="s-type">User</span>?) {
    <span class="s-keyword">guard let</span> user = user <span class="s-keyword">else</span> {
        <span class="s-comment">// Guard statements require us to "exit" out of the
        // current scope, for example by returning:</span>
        <span class="s-keyword">return</span> <span class="s-call">showLoginScreen</span>()
    }

    <span class="s-call">showHomeScreen</span>(for: user)
}</code></pre><p>Essentially, optionals provide us with a built-in way to represent the <em>“lack of a value”</em> — which make them an ideal choice in situations when we need to model some form of default or missing state.</p><p>For example, here we’ve created a <code>Relationship</code> enum, which enables us to express the relationship between two users of our app. Currently, we represent the lack of any relationship using a <code>none</code> case within that enum, which also acts as our default value:</p><pre class="splash"><code><span class="s-keyword">enum</span> Relationship {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
}

<span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> relationship: <span class="s-type">Relationship</span> = .<span class="s-dotAccess">none</span>
    ...
}</code></pre><p>However, while the above code technically works, it would arguably be better to implement our <code>relationship</code> property as an optional instead. That way, we can use Swift’s built-in way to represent the lack of any relationship, which will both let us use mechanisms like <code>if let</code> and <code>guard</code> — and also lets us simplify our enum by removing its <code>none</code> case:</p><pre class="splash"><code><span class="s-keyword">enum</span> Relationship {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
}

<span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> relationship: <span class="s-type">Relationship</span>? = <span class="s-keyword">nil</span>
    ...
}</code></pre><p>However, optionals can also become a source of ambiguity if we’re not careful. It’s always important to consider whether a given value is <em>actually optional</em> before implementing it as such — since if a value is required in order for our code to function, we should ideally be able to guarantee that it’ll always be there.</p><p>For example, let’s have a look at a view controller implementation which currently uses optionals to store its subviews — a <code>headerView</code> and a <code>logOutButton</code> — in order to <em>lazily create them</em> once the system calls <code>viewDidLoad()</code>, which is the recommended way of constructing view controller-based UIs:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private var</span> headerView: <span class="s-type">HeaderView</span>?
    <span class="s-keyword">private var</span> logOutButton: <span class="s-type">UIButton</span>?

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerView = <span class="s-type">HeaderView</span>()
        view.<span class="s-call">addSubview</span>(headerView)
        <span class="s-keyword">self</span>.<span class="s-property">headerView</span> = headerView

        <span class="s-keyword">let</span> logOutButton = <span class="s-type">UIButton</span>()
        view.<span class="s-call">addSubview</span>(logOutButton)
        <span class="s-keyword">self</span>.<span class="s-property">logOutButton</span> = logOutButton
        
        <span class="s-comment">// More view configuration</span>
        ...
    }
}</code></pre><p>The above is a very common pattern, but it does come with a quite substantial problem, in that we always have to keep unwrapping our subviews as optionals — even though they are required parts of our view controller’s logic. For example, here we have to unwrap our <code>headerView</code> property in order to be able to assign various model values to its properties:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ProfileViewController</span> {
    <span class="s-keyword">func</span> userDidUpdate(<span class="s-keyword">_</span> user: <span class="s-type">User</span>) {
        <span class="s-keyword">guard let</span> headerView = headerView <span class="s-keyword">else</span> {
            <span class="s-comment">// This should never happen, but we still have
            // to maintain this code path.</span>
            <span class="s-keyword">return</span>
        }

        headerView.<span class="s-property">imageView</span>.<span class="s-property">image</span> = user.<span class="s-property">image</span>
        headerView.<span class="s-property">label</span>.<span class="s-property">text</span> = user.<span class="s-property">name</span>
    }
}</code></pre><p>What we’re essentially dealing with above, is <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optionals</a></em> — values that might <em>technically</em> be optionals, but are in fact <strong>not optional</strong> when it comes to how we’ve implemented our logic.</p><p>While removing non-optional optionals can sometimes be quite difficult, in the above case, there’s a quite straightforward way. Using Swift’s <code>lazy</code> keyword, we can delay the initialization of our view controller’s subviews until those properties are first accessed — giving us the exact same behavior as we had before, but without any optionals — leading to much simpler code:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private lazy var</span> headerView = <span class="s-type">HeaderView</span>()
    <span class="s-keyword">private lazy var</span> logOutButton = <span class="s-type">UIButton</span>()

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        view.<span class="s-call">addSubview</span>(headerView)
        view.<span class="s-call">addSubview</span>(logOutButton)
        
        <span class="s-comment">// More view configuration</span>
        ...
    }

    <span class="s-keyword">func</span> userDidUpdate(<span class="s-keyword">_</span> user: <span class="s-type">User</span>) {
        headerView.<span class="s-property">imageView</span>.<span class="s-property">image</span> = user.<span class="s-property">image</span>
        headerView.<span class="s-property">label</span>.<span class="s-property">text</span> = user.<span class="s-property">name</span>
    }
}</code></pre><p class="info">For more information about using lazy properties in Swift, <a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift">check out this article</a>.</p><p>An alternative way of dealing with non-optional optionals is to use force unwrapping (using <code>!</code>) to turn an optional value into a concrete one, without any checks. However, while force unwrapping might occasionally be warranted, it does always come with the risk of causing a crash in case its value ended up being missing — so if we can find another solution, that’s most often preferable.</p><p>Next, let’s take a quick look under the hood of how optionals are actually implemented. The cool thing about Swift’s version of optionals is that they’re actually modeled using a standard enum, which looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Optional&lt;Wrapped&gt;: <span class="s-type">ExpressibleByNilLiteral</span> {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> some(<span class="s-type">Wrapped</span>)
}</code></pre><p>The above is just one of many examples of how Swift uses its <em>own type system</em> to implement many of its core language features — which is not only a really interesting design, but in this case also enables us to treat optional values just like any other enum. For example, we can switch on them:</p><pre class="splash"><code><span class="s-keyword">func</span> icon(forRelationship relationship: <span class="s-type">Relationship</span>?) -&gt; <span class="s-type">Icon</span>? {
    <span class="s-comment">// Here we switch on the optional itself, rather than on
    // its underlying Relationship value:</span>
    <span class="s-keyword">switch</span> relationship {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">some</span>(<span class="s-keyword">let</span> relationship):
        <span class="s-comment">// Then, we switch on the wrapped value itself:</span>
        <span class="s-keyword">switch</span> relationship {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">user</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">familyMember</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">work</span>
        }
    <span class="s-keyword">case</span> .<span class="s-dotAccess">none</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p>The above might be interesting in terms of how Swift’s various features work together — but the resulting code is arguably a bit hard to read, due to the many nested statements. Thankfully, Swift also enables us to switch on any optional directly — just as if we were switching on its wrapped value. All we have to do is to include a <code>nil</code> case to handle the lack of a value:</p><pre class="splash"><code><span class="s-keyword">func</span> icon(forRelationship relationship: <span class="s-type">Relationship</span>?) -&gt; <span class="s-type">Icon</span>? {
    <span class="s-keyword">switch</span> relationship {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">user</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">familyMember</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">work</span>
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p class="info">The above syntax works in Swift 5.1 and above. When using earlier versions, we have to append a question mark to each non-<code>nil</code> case — like this: <code>case .friend?:</code>.</p><p>The fact that optionals are implemented using their own, stand-alone type, also means that they can have methods and properties of their own. For example, here we’re converting a <code>String</code> that represents a URL into a <code>URLRequest</code> instance — which requires us to first optionally convert that string into a <code>URL</code> value, which we then pass into our new <code>URLRequest</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> makeRequest(forURLString string: <span class="s-type">String</span>) -&gt; <span class="s-type">URLRequest</span>? {
    <span class="s-keyword">guard let</span> url = <span class="s-type">URL</span>(string: string) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">return</span> <span class="s-type">URLRequest</span>(url: url)
}</code></pre><p>The above code works, but if we wanted to, we could make it a lot more compact — by instead calling <code>map</code> directly on our optional <code>URL</code>. Similar to how we can use <code>map</code> to <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">transform a collection</a>, calling <code>map</code> on an optional lets us use a closure to transform any value that it’s wrapping — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeRequest(forURLString string: <span class="s-type">String</span>) -&gt; <span class="s-type">URLRequest</span>? {
    <span class="s-type">URL</span>(string: string).<span class="s-call">map</span> { <span class="s-type">URLRequest</span>(url: $0) }
}</code></pre><p>What’s really cool is that not only can we use methods and properties that come built into the <code>Optional</code> type, we can also define our own. For example, here’s how we could define two properties that enable us to check whether any collection is <code>nil</code> or empty:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Optional</span> <span class="s-keyword">where</span> <span class="s-type">Wrapped</span>: <span class="s-type">Collection</span> {
    <span class="s-keyword">var</span> isNilOrEmpty: <span class="s-type">Bool</span> {
        <span class="s-comment">// If the left-hand expression is nil, the right one
        // will be used, meaning that 'true' is our default:</span>
        <span class="s-keyword">self</span>?.<span class="s-property">isEmpty</span> ?? <span class="s-keyword">true</span>
    }

    <span class="s-keyword">var</span> nonEmpty: <span class="s-type">Wrapped</span>? {
        <span class="s-comment">// Either return this collection, or nil if it's empty:</span>
        isNilOrEmpty ? nil : <span class="s-keyword">self</span>
    }
}</code></pre><p>With the above in place, we can now easily handle any missing values, and empty ones — all using a single <code>guard</code> statement:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">EditorViewController</span>: <span class="s-type">UITextFieldDelegate</span> {
    <span class="s-keyword">func</span> textFieldDidEndEditing(<span class="s-keyword">_</span> textField: <span class="s-type">UITextField</span>) {
        <span class="s-keyword">guard let</span> text = textField.<span class="s-property">text</span>.<span class="s-property">nonEmpty</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span>
        }

        <span class="s-comment">// Handle non-empty text</span>
        ...
    }
}</code></pre><p class="info">To learn more about the above technique, check out <a href="https://www.swiftbysundell.com/articles/extending-optionals-in-swift">“Extending optionals in Swift”</a>.</p><p>How we handle our optional, potentially missing values is arguably just as important as how we handle our concrete ones — and by fully utilizing Swift’s <code>Optional</code> type and its various features, we can often end up with code that doesn’t only have a higher chance of being correct, but that’s also very concise and elegant as well.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/exploring-swift-5-2s-new-functional-features</guid><title>Exploring Swift 5.2’s new functional features</title><description>Let’s explore two of Swift 5.2’s new features, that both give the language some really interesting capabilities from a functional programming perspective.</description><link>https://www.swiftbysundell.com/articles/exploring-swift-5-2s-new-functional-features</link><pubDate>Sun, 9 Feb 2020 22:15:00 +0100</pubDate><content:encoded><![CDATA[<p>On the surface level, Swift 5.2 is definitely a minor release in terms of new language features, as much of the focus of this new release has been on improving the speed and stability of Swift’s underlying infrastructure — such as how compiler errors are reported, and how build-level dependencies are resolved.</p><p>However, while Swift 5.2’s <em>total number</em> of new language features might be relatively small, it does include two new capabilities that could potentially have quite a big impact on Swift’s overall power as a <em>functional programming language</em>.</p><p>This week, let’s explore those features, and how we could potentially use them to embrace a few different paradigms that are very popular in the functional programming world — in ways that might feel more consistent and familiar within an object-oriented Swift code base.</p><p>Before we begin, as Swift 5.2 is (at the time of writing) still in beta as part of Xcode 11.4, please note that this article is a very exploratory piece that represents my first impressions of these new language features. My opinions are likely to change as I gain more experience using the new features in production, and while I’ll try to keep this article updated as that happens, I recommend using this article purely as inspiration to explore these new features yourself, rather than directly using the solutions presented as-is.</p><p>With that little disclaimer out of the way, let’s start exploring!</p><h2>Calling types as functions</h2><p>Even though Swift isn’t a strictly functional programming language, there’s no doubt that functions play a very central role in its overall design and usage. From how closures are used as asynchronous callbacks, to how collections make heavy use of classic functional patterns like <code>map</code> and <code>reduce</code> — functions are everywhere.</p><p>What’s interesting about Swift 5.2 in this regard is that it starts to blur the lines between functions and types. Although we’ve always been able to pass any given type’s instance methods as functions (since Swift supports <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class functions</a>), we’re now able to <em>call certain types as if they were functions themselves</em>.</p><p>Let’s start by taking a look at an example using an excerpt of the <code>Cache</code> type that we built in <em><a href="https://www.swiftbysundell.com/articles/caching-in-swift">”Caching in Swift”</a></em> — which provides a more <em>“Swift-friendly”</em> API on top of a wrapped <code>NSCache</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> Cache&lt;Key: <span class="s-type">Hashable</span>, Value&gt; {
    <span class="s-keyword">private let</span> wrapped = <span class="s-type">NSCache</span>&lt;<span class="s-type">WrappedKey</span>, <span class="s-type">Entry</span>&gt;()
    <span class="s-keyword">private let</span> dateProvider: () -&gt; <span class="s-type">Date</span>
    <span class="s-keyword">private let</span> entryLifetime: <span class="s-type">TimeInterval</span>
    
    ...

    <span class="s-keyword">func</span> insert(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>, forKey key: <span class="s-type">Key</span>) {
        ...
    }
}</code></pre><p>Let’s say that we wanted to add a convenience API to the above type — to let us automatically use an inserted value’s <code>id</code> as its cache key, in case the current <code>Value</code> type conforms to the standard library’s <code>Identifiable</code> protocol. While we could simply name that new API <code>insert</code> as well, we’re going to give it a very particular name — <code>callAsFunction</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Cache</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Identifiable</span>, <span class="s-type">Key</span> == <span class="s-type">Value</span>.<span class="s-type">ID</span> {
    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-call">insert</span>(value, forKey: value.<span class="s-property">id</span>)
    }
}</code></pre><p>That might seem like a strange naming convention, but by naming our new convenience method that way, we’ve actually given our <code>Cache</code> type an interesting new capability — it may now be called as if it was a function — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> document: <span class="s-type">Document</span> = ...
<span class="s-keyword">let</span> cache = <span class="s-type">Cache</span>&lt;<span class="s-type">Document</span>.<span class="s-type">ID</span>, <span class="s-type">Document</span>&gt;()

<span class="s-comment">// We can now call our 'cache' variable as if it was referencing a
// function or a closure:</span>
<span class="s-call">cache</span>(document)</code></pre><p>That’s arguably both really cool, and really strange. But the question is — what might it be useful for? Let’s continue exploring by taking a look at a <code>DocumentRenderer</code> protocol, that defines a common interface for various types that are used to render <code>Document</code> instances within an app:</p><pre class="splash"><code><span class="s-keyword">protocol</span> DocumentRenderer {
    <span class="s-keyword">func</span> render(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>,
                in context: <span class="s-type">DocumentRenderingContext</span>,
                enableAnnotations: <span class="s-type">Bool</span>)
}</code></pre><p>Similar to how we previously added a function-based convenience API to our <code>Cache</code> type, let’s do the same thing here — only this time, we’ll extend the above protocol to enable any conforming type to be called as a function with a set of default arguments:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentRenderer</span> {
    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>) {
        <span class="s-call">render</span>(document,
            in: .<span class="s-call">makeDefaultContext</span>(),
            enableAnnotations: <span class="s-keyword">false</span>
        )
    }
}</code></pre><p>Each of the above two changes might not seem that impressive in isolation, but if we put them together, we can start to see the appeal of providing function-based convenience APIs for some of our more complex types. For example, here we’ve built a <code>DocumentViewController</code> — which uses both our <code>Cache</code> type, and a Core Animation-based implementation of our <code>DocumentRenderer</code> protocol — both of which can now simply be called as functions when a document was loaded:</p><pre class="splash"><code><span class="s-keyword">class</span> DocumentViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> cache: <span class="s-type">Cache</span>&lt;<span class="s-type">Document</span>.<span class="s-type">ID</span>, <span class="s-type">Document</span>&gt;
    <span class="s-keyword">private let</span> render: <span class="s-type">CoreAnimationDocumentRenderer</span>
    
    ...

    <span class="s-keyword">private func</span> documentDidLoad(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>) {
        <span class="s-call">cache</span>(document)
        <span class="s-call">render</span>(document)
    }
}</code></pre><p>That’s quite cool, especially if we’re aiming for a more <a href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">lightweight API design</a>, or if we’re building some form of <a href="https://www.swiftbysundell.com/articles/building-dsls-in-swift">domain-specific language</a>. While it’s always been possible to achieve a similar result by passing instance methods <a href="https://www.swiftbysundell.com/clips/1">as if they were closures</a> — by enabling our types to be called directly, we both avoid having to manually pass those methods, and we’re able to retain any external parameter labels that our APIs might be using.</p><p>For example, let’s say that we also wanted to make a <code>PriceCalculator</code> become a callable type. To maintain the semantics of our original API, we’ll keep the <code>for</code> external parameter label, even when declaring our <code>callAsFunction</code> implementation — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">func</span> callAsFunction(for product: <span class="s-type">Product</span>) -&gt; <span class="s-type">Int</span> {
        <span class="s-call">calculatePrice</span>(for: product)
    }
}</code></pre><p>Here’s how the above approach compares to if we were to store a reference to our type’s <code>calculatePrice</code> method instead — note how the first piece of code discards our parameter label, while the second retains it:</p><pre class="splash"><code><span class="s-comment">// Using a method reference:</span>
<span class="s-keyword">let</span> calculatePrice = <span class="s-type">PriceCalculator</span>().<span class="s-property">calculatePrice</span>
...
<span class="s-call">calculatePrice</span>(product)

<span class="s-comment">// Calling our type directly:</span>
<span class="s-keyword">let</span> calculatePrice = <span class="s-type">PriceCalculator</span>()
...
<span class="s-call">calculatePrice</span>(for: product)</code></pre><p>Enabling types to be called as if they were functions is a very intriguing concept, but perhaps even more interesting is that it also enables us to go the opposite direction — and transform functions into proper types.</p><h2>Functional programming in an object-oriented way</h2><p>While there’s a tremendous amount of power in many functional programming concepts, applying those concepts and patterns when using heavily object-oriented frameworks (like most of Apple’s are) can often be quite challenging. Let’s see if Swift 5.2’s new callable types feature that can help us change that.</p><p>Since we can now make any type callable, we could also enable any function to be converted into a type, while still enabling that function to be called as it normally would. To make that happen, let’s define a type called <code>Function</code>, which looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Function&lt;Input, Output&gt; {
    <span class="s-keyword">let</span> raw: (<span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> raw: <span class="s-keyword">@escaping</span> (<span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">raw</span> = raw
    }

    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> input: <span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span> {
        <span class="s-call">raw</span>(input)
    }
}</code></pre><p class="info">Just like the callable types that we defined earlier, <code>Function</code> instances can be called directly, making them act the same way as their underlying functions in most cases.</p><p>To enable functions that don’t accept any input to still be called without having to manually specify <code>Void</code> as an argument, let’s also define the following extension for <code>Function</code> values which have <code>Void</code> as their <code>Input</code> type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Function</span> <span class="s-keyword">where</span> <span class="s-type">Input</span> == <span class="s-type">Void</span> {
    <span class="s-keyword">func</span> callAsFunction() -&gt; <span class="s-type">Output</span> {
        <span class="s-call">raw</span>(<span class="s-type">Void</span>())
    }
}</code></pre><p>The cool thing about the above wrapper type is that it enables us to adopt really powerful functional programming concepts in much more object-oriented ways. Let’s take a look at two such concepts — <em>partial application</em> and <em>piping</em> (which we also used in <em><a href="https://www.swiftbysundell.com/articles/functional-networking-in-swift">“Functional networking in Swift”</a></em>). The former lets us combine a function with a value to produce a new function that doesn’t require any input, while the latter enables us to chain two functions together — and could now be implemented like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Function</span> {
    <span class="s-keyword">func</span> combined(with value: <span class="s-type">Input</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Output</span>&gt; {
        <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Output</span>&gt; { <span class="s-keyword">self</span>.<span class="s-call">raw</span>(value) }
    }
    
    <span class="s-keyword">func</span> chained&lt;T&gt;(to next: <span class="s-keyword">@escaping</span> (<span class="s-type">Output</span>) -&gt; <span class="s-type">T</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Input</span>, <span class="s-type">T</span>&gt; {
        <span class="s-type">Function</span>&lt;<span class="s-type">Input</span>, <span class="s-type">T</span>&gt; { <span class="s-call">next</span>(<span class="s-keyword">self</span>.<span class="s-call">raw</span>($0)) }
    }
}</code></pre><p class="info">Note how we named the above two functions <code>combined</code> and <code>chained</code> in order to make them feel more <em>“at home”</em> in Swift, rather than using the names typically found in more strictly functional programming languages.</p><p>What the above setup enables us to do is to use techniques like <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">function-based dependency injection</a> in a way that still feels very object-oriented. For example, here we’ve built a view controller for editing notes — which accepts two functions, one for loading the current version of the note that it’s editing, and one for submitting an update to our app’s central data store:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteEditorViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> provideNote: <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Note</span>&gt;
    <span class="s-keyword">private let</span> updateNote: <span class="s-type">Function</span>&lt;<span class="s-type">Note</span>, <span class="s-type">Void</span>&gt;

    <span class="s-keyword">init</span>(provideNote: <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Note</span>&gt;,
         updateNote: <span class="s-type">Function</span>&lt;<span class="s-type">Note</span>, <span class="s-type">Void</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">provideNote</span> = provideNote
        <span class="s-keyword">self</span>.<span class="s-property">updateNote</span> = updateNote
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...

    <span class="s-keyword">private func</span> editorTextDidChange(to text: <span class="s-type">String</span>) {
        <span class="s-keyword">var</span> note = <span class="s-call">provideNote</span>()
        note.<span class="s-property">text</span> = text
        <span class="s-call">updateNote</span>(note)
    }
}</code></pre><p>The beauty of the above approach is that it lets us build our UI in a way that’s completely decoupled from the concrete types that we use to drive our model and data logic. For example, the functions that our above view controller actually uses are in this case methods on a <code>NoteManager</code> type, that looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManager {
    ...

    <span class="s-keyword">func</span> loadNote(withID id: <span class="s-type">Note</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Note</span> {
        ...
    }
    
    <span class="s-keyword">func</span> updateNote(<span class="s-keyword">_</span> note: <span class="s-type">Note</span>) {
        ...
    }
}</code></pre><p>Then, when we’re creating an instance of our view controller, we’re using our <code>Function</code> type to convert the above two methods into functions that our UI code can directly call — without having to be aware of any of the underlying types or details:</p><pre class="splash"><code><span class="s-keyword">func</span> makeEditorViewController(
    forNoteID noteID: <span class="s-type">Note</span>.<span class="s-type">ID</span>
) -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> provider = <span class="s-type">Function</span>(noteManager.<span class="s-property">loadNote</span>).<span class="s-call">combined</span>(with: noteID)
    <span class="s-keyword">let</span> updater = <span class="s-type">Function</span>(noteManager.<span class="s-property">updateNote</span>)

    <span class="s-keyword">return</span> <span class="s-type">NoteEditorViewController</span>(
        provideNote: provider,
        updateNote: updater
    )
}</code></pre><p>Not only does the above approach give us a greater separation of concerns, it also makes testing a breeze, as we no longer have to mock any protocols or fight with singleton-based global state — we can simply inject any sort of behavior that we wish to test against by <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift/%23functional-behavior">passing in test-specific functions</a>.</p><h2>Passing key paths as functions</h2><p>Another really interesting new feature introduced in Swift 5.2 is that <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> can now be passed as functions. That comes very much in handy in situations when we’re using a closure simply to extract a piece of data from a property — as we can now pass that property’s key path directly:</p><pre class="splash"><code><span class="s-keyword">let</span> notes: [<span class="s-type">Note</span>] = ...

<span class="s-comment">// Before:</span>
<span class="s-keyword">let</span> titles = notes.<span class="s-call">map</span> { $0.<span class="s-property">title</span> }

<span class="s-comment">// After:</span>
<span class="s-keyword">let</span> titles = notes.<span class="s-call">map</span>(\.<span class="s-property">title</span>)</code></pre><p>Combining that capability with our <code>Function</code> type from before, we can now easily construct a chain of functions that lets us load a given value, and then extract a property from it. Here we’re doing just that to create a function that lets us easily look up what tags that are associated with a given note ID:</p><pre class="splash"><code><span class="s-keyword">func</span> tagLoader(forNoteID noteID: <span class="s-type">Note</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, [<span class="s-type">Tag</span>]&gt; {
    <span class="s-type">Function</span>(noteManager.<span class="s-property">loadNote</span>)
        .<span class="s-call">combined</span>(with: noteID)
        .<span class="s-call">chained</span>(to: \.<span class="s-property">tags</span>)
}</code></pre><p>Of course, the above examples barely scratch the surface of what could be possible when we start to mix functional programming patterns with object-oriented APIs — so it’s definitely a topic that we’ll return to in future articles.</p><h2>Conclusion</h2><p>Swift 5.2 and Xcode 11.4 are both quite substantial releases — with a new diagnostics engine for compiler errors, lots of new testing and debugging features, and <a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes">much more</a>. But Swift 5.2 is also an interesting release from a syntax perspective, as it continues to broaden the ways that Swift can be used to adopt functional programming concepts, and how it starts to blur the lines between types and functions.</p><p>I’ll of course continue to explore these features over the coming weeks and months, and will report my findings in future articles, <a href="https://www.swiftbysundell.com/podcast">podcast episodes</a> and <a href="https://www.swiftbysundell.com/videos">videos</a>.</p><p>What do you think? What are your first impressions of these new features, and do you have any concrete use cases in which they might become useful? Let me know — along with your questions, comments or feedback — either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/passing-key-paths-as-functions</guid><title>Tip: Passing key paths as functions</title><description></description><link>https://www.swiftbysundell.com/tips/passing-key-paths-as-functions</link><pubDate>Thu, 6 Feb 2020 17:25:00 +0100</pubDate><content:encoded><![CDATA[<p><strong>New in Swift 5.2:</strong> Key path literals can now be passed as functions. This might be a small change in the grand scheme of things, but it really makes closures in which we’re simply accessing a property read so much nicer — since we can now pass that property’s key path directly:</p><pre class="splash"><code><span class="s-keyword">struct</span> Movie {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFavorite: <span class="s-type">Bool</span>
    ...
}

<span class="s-keyword">let</span> movies: [<span class="s-type">Movie</span>] = <span class="s-call">loadMovies</span>()

<span class="s-comment">// Equivalent to movies.map { $0.name }</span>
<span class="s-keyword">let</span> movieNames = movies.<span class="s-call">map</span>(\.<span class="s-property">name</span>)

<span class="s-comment">// Equivalent to movies.filter { $0.isFavorite }</span>
<span class="s-keyword">let</span> favoriteMovies = movies.<span class="s-call">filter</span>(\.<span class="s-property">isFavorite</span>)</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/picking-between-for-and-for-each</guid><title>Tip: Picking between a for loop and forEach</title><description></description><link>https://www.swiftbysundell.com/tips/picking-between-for-and-for-each</link><pubDate>Tue, 4 Feb 2020 17:40:00 +0100</pubDate><content:encoded><![CDATA[<p>When iterating over a collection, such an <code>Array</code> or a <code>Set</code>, it may at first seem like a matter of preference and style whether to use a classic <code>for</code> loop, or the closure-based <code>forEach</code> method. While it’s definitely true that those two mechanisms are highly similar, they do differ in a few distinct ways.</p><p>One of those differences is that a <code>for</code> loop’s iteration is performed directly within our code’s control flow, which gives us much more precise control over those iterations. For example, we can choose to skip to the next element at any point using the <code>continue</code> keyword, or to break the iteration completely using <code>break</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> recentArticles(among articles: [<span class="s-type">Article</span>]) -&gt; [<span class="s-type">Article</span>] {
    <span class="s-keyword">var</span> results = [<span class="s-type">Article</span>]()
    
    <span class="s-keyword">for</span> article <span class="s-keyword">in</span> articles {
        <span class="s-keyword">guard</span> !article.<span class="s-property">isDraft</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// Immediately skip to the next element.</span>
            <span class="s-keyword">continue</span>
        }
    
        results.<span class="s-call">append</span>(article)
        
        <span class="s-keyword">guard</span> results.<span class="s-property">count</span> &lt; <span class="s-number">5</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// Break the iteration. In this case we could've also
            // returned here directly.</span>
            <span class="s-keyword">break</span>
        }
    }
    
    <span class="s-keyword">return</span> results
}</code></pre><p>When a <code>for</code> loop’s iteration starts with a <code>guard</code> (or <code>if</code>) statement that’s used for filtering (like above), we can also chose to implement that logic using <code>where</code>-based <a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift/%23iterative-patterns">pattern matching</a> instead — like this:</p><pre class="splash"><code><span class="s-keyword">for</span> article <span class="s-keyword">in</span> articles <span class="s-keyword">where</span> !article.<span class="s-property">isDraft</span> {
    results.<span class="s-call">append</span>(article)
    
    <span class="s-keyword">guard</span> results.<span class="s-property">count</span> &lt; <span class="s-number">5</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">break</span>
    }
}</code></pre><p>The above kind of control flow-related features are a big part of what makes <code>for</code> loops so powerful, but if we don’t need that level of control, using a call to <code>forEach</code> might give us slightly simpler-looking code. For example, here we’re adding a new view for each of an array’s elements, which can be done really elegantly using <code>forEach</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> addArticleViews(for articles: [<span class="s-type">Article</span>]) {
    articles.<span class="s-call">forEach</span> { article <span class="s-keyword">in
        let</span> articleView = <span class="s-type">ArticleView</span>()
        
        <span class="s-comment">// Seting up our new view using the closure's article.</span>
        ...
        
        view.<span class="s-call">addSubview</span>(articleView)
    }
}</code></pre><p>However, it would perhaps be even more elegant to use Swift’s <em><a href="https://www.swiftbysundell.com/clips/1">first class functions</a></em> capabilities — by refactoring the above method to only accept a single <code>Article</code>, and then directly injecting that method into a call to <code>forEach</code>, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ArticleGroupViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> articles: [<span class="s-type">Article</span>]
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        ...
        articles.<span class="s-call">forEach</span>(addArticleView)
    }

    <span class="s-keyword">private func</span> addArticleView(for article: <span class="s-type">Article</span>) {
        <span class="s-keyword">let</span> articleView = <span class="s-type">ArticleView</span>()
        ...
        view.<span class="s-call">addSubview</span>(articleView)
    }
}</code></pre><p>To sum up: Using a <code>for</code> loop gives us a much greater degree of control over an iteration, while using <code>forEach</code> enables us to take advantage of the power of closures and first class functions, even though we won’t be able to stop an iteration once it was started (apart from throwing an error, that is).</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/slicing-swift-collections</guid><title>Slicing Swift collections</title><description>Let’s take a look at how we can utilize Swift’s various collection slicing APIs, and how doing so can help us boost the performance of various algorithms and functionality.</description><link>https://www.swiftbysundell.com/articles/slicing-swift-collections</link><pubDate>Sun, 2 Feb 2020 18:00:00 +0100</pubDate><content:encoded><![CDATA[<p>One of Swift’s goals is to be a truly general-purpose programming language — that gracefully scales from high-level tasks, like building UIs and scripting, to low-level systems programming. That’s quite an ambitious goal, and arguably one that’s yet to be fully achieved, but there are a number of aspects of Swift’s design that does give it very scalable characteristics.</p><p>One such aspect is how the standard library takes great care to make working with its built-in collections as efficient as possible — by minimizing the number of circumstances in which their elements need to be copied, mutated and moved.</p><p>However, like with most optimizations, fully utilizing those behaviors does also require us to write our code in specific ways — especially when accessing slices or subsets of a given collection. That’s exactly what we’ll take a look at this week.</p><h2>A slice of a binary pie</h2><p>In Swift, a <em>slice</em> is a special kind of collection that doesn’t actually store any elements of its own, but rather acts as a proxy (or <em>view</em>) to enable us access and work with a subset of another collection as a separate instance.</p><p>As a very simple example, let’s say that we have an array containing ten numbers, and that we wish to extract the first five numbers in order to work with them separately. That can be done using <code>Range</code>-based <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">subscripting</a>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> numbers = [<span class="s-number">1</span>, <span class="s-number">2</span>, <span class="s-number">3</span>, <span class="s-number">4</span>, <span class="s-number">5</span>, <span class="s-number">6</span>, <span class="s-number">7</span>, <span class="s-number">8</span>, <span class="s-number">9</span>, <span class="s-number">10</span>]
<span class="s-keyword">let</span> firstFive = numbers[..&lt;<span class="s-number">5</span>]</code></pre><p>At first glance, it might seem like <code>firstFive</code> would have the same type as <code>numbers</code>, which is <code>Array&lt;Int&gt;</code>, but it actually doesn’t. In fact, what we’ve done above is to create a slice, in this case of type <code>ArraySlice&lt;Int&gt;</code>.</p><p>Rather than copying the first five elements into a new <code>Array</code> instance, the standard library instead simply provided us with a view into that range of elements — which has significant performance benefits, especially when working with larger collections.</p><p>By not performing any copying or additional memory allocation for a collection’s elements, a slice can be created in constant (<code>O(1)</code>) time. Not only does that make creating a single slice faster, it also makes further slicing just as fast as if we performed it on the original collection — giving us a lot of freedom when it comes to how we use and compose Swift’s various slicing APIs in practice.</p><h2>Prefixes and suffixes</h2><p>Let’s start by taking a look at how we can use slicing to extract <em>prefixes</em> and <em>suffixes</em> from a collection. As an example, let’s say that we’re working on a todo app, which uses the following model to represent one of its todo lists:</p><pre class="splash"><code><span class="s-keyword">struct</span> TodoList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> items = [<span class="s-type">Item</span>]()
    ...
}</code></pre><p>Now let’s say that we’re building a feature that lets our users quickly view the top three items within any given list — for example within a <em>“Today Extension”</em> widget on iOS or macOS. To make that happen, we could use the same subscripting API as we used when slicing our above array of numbers, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">var</span> topItems: <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items[..&lt;<span class="s-number">3</span>]
    }
}</code></pre><p>However, while the above looks very elegant from a syntax point of view, it’s a quite dangerous implementation in this situation. Since we can’t know how many items that each <code>TodoList</code> will actually contain, our app might end up crashing when accessing the above property — since just like when retrieving a single element from an array, range-based subscripting also causes a crash if used with out-of-bounds indexes.</p><p>While we <em>could</em> of course add our own bounds-checking to our implementation, we don’t have to — since <code>Array</code> (and all other <code>Collection</code> implementations) has a <code>prefix</code> method that does just that:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">var</span> topItems: <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items.<span class="s-call">prefix</span>(<span class="s-number">3</span>)
    }
}</code></pre><p>Now our new API will work as expected, even if a <code>TodoList</code> contains less than 3 items, and our implementation still has <code>O(1)</code> <a href="https://www.swiftbysundell.com/basics/time-complexity">time complexity</a> — which means that we can comfortably let it remain a computed property without the risk of causing <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift/%23accidental-bottlenecks">accidental bottlenecks</a>. Fantastic!</p><p>However, one thing that we have to keep in mind when working with slices is that they truly are a separate types compared to their original collections. That means that we can’t pass an <code>ArraySlice</code> instance to any API that accepts a standard <code>Array</code>, and vice versa — without first performing an explicit conversion. That may at first seem like an unnecessary inconvenience, but it’s actually really important — as it gives us complete control over when a slice should be separated (and its elements copied) from its original collection.</p><p>Let’s take a look at an example of doing just that, in which we’re using another <em>“flavor”</em> of the standard library’s <code>prefix</code> API (along with its <code>suffix</code> counterpart) to split a shipment of packages up into two separate shipments based on indexes. Since we don’t want our <code>Shipment</code> model to contain an <code>ArraySlice</code>, but rather a proper array of packages, we have to convert each of our two slices back into <code>Array&lt;Package&gt;</code> values — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Shipment {
    <span class="s-keyword">var</span> destination: <span class="s-type">Address</span>
    <span class="s-keyword">var</span> packages = [<span class="s-type">Package</span>]()
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Shipment</span> {
    <span class="s-keyword">func</span> split() -&gt; (first: <span class="s-type">Shipment</span>, second: <span class="s-type">Shipment</span>) {
        <span class="s-keyword">guard</span> packages.<span class="s-property">count</span> &gt; <span class="s-number">1</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> (<span class="s-keyword">self</span>, <span class="s-type">Shipment</span>(destination: destination))
        }

        <span class="s-keyword">let</span> splitIndex = packages.<span class="s-property">count</span> / <span class="s-number">2</span>

        <span class="s-keyword">return</span> (
            <span class="s-type">Shipment</span>(
                destination: destination,
                packages: <span class="s-type">Array</span>(packages.<span class="s-call">prefix</span>(upTo: splitIndex))
            ),
            <span class="s-type">Shipment</span>(
                destination: destination,
                packages: <span class="s-type">Array</span>(packages.<span class="s-call">suffix</span>(from: splitIndex))
            )
        )
    }
}</code></pre><p class="info">The above calls to <code>prefix</code> and <code>suffix</code> are equivalent to the range-based subscripts <code>packages[..&lt;splitIndex]</code> and <code>packages[splitIndex...]</code>, so which one we’ll use is simply a matter of taste in this situation.</p><p>So far, we’ve been computing our prefixes and suffixes based on element counts and indexes, but we can also use completely custom logic when doing so as well. For example, here we’re calling <code>prefix</code> with a custom closure to determine which of a game’s top players that have scored more than 100,000 points:</p><pre class="splash"><code><span class="s-keyword">let</span> qualifiedPlayers = topPlayers.<span class="s-call">prefix</span> { $0.<span class="s-property">score</span> &gt; <span class="s-number">100_000</span> }</code></pre><p><em>The above implementation assumes that the <code>topPlayers</code> array is in order according to each player’s score.</em></p><h2>Dropping elements</h2><p>An important aspect of both <code>prefix</code> and <code>suffix</code> is that neither of those APIs affect the original collection that they’re being called on, and instead return new instances for working with those subsets of elements. The same is also true for the <code>drop</code> family of APIs, with the only difference that they <em>subtract</em> a given prefix or suffix from a collection, rather than extracting it.</p><p>As an example, let’s say that we wanted to remove any numbers that appear at the beginning of a string, for example to prepare a string to be used as some form of normalized identifier. To do that, we could ask the string in question to drop all elements while the current element is a number — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">StringProtocol</span> {
    <span class="s-keyword">func</span> trimmingLeadingNumbers() -&gt; <span class="s-type">SubSequence</span> {
        <span class="s-call">drop</span>(while: { $0.<span class="s-property">isNumber</span> })
    }
}</code></pre><p class="info">Note how we extend <code>StringProtocol</code> above, and not <code>String</code> directly. That’s to enable our new API to be used on both standard strings, as well as the <code>Substring</code> type, which represents as slice of a <code>String</code>. To learn more about that, check out <a href="https://www.swiftbysundell.com/basics/strings">the Basics article about strings</a>.</p><p>As mentioned earlier, one of the major benefits of Swift’s slice-based collection APIs is that they can be composed without causing any unnecessary copying. That’s really beneficial in situations like the one below, in which we’re composing our above <code>trimmingLeadingNumbers</code> method with a call to <code>filter</code> in order to normalize a <code>username</code> value:</p><pre class="splash"><code><span class="s-keyword">func</span> normalizeUsername(<span class="s-keyword">_</span> username: <span class="s-type">String</span>) -&gt; <span class="s-type">String</span> {
    username.<span class="s-call">trimmingLeadingNumbers</span>().<span class="s-call">filter</span> {
        $0.<span class="s-property">isLetter</span> || $0.<span class="s-property">isNumber</span>
    }
}</code></pre><p>Using the above approach, we can construct increasingly complex value transformations simply by chaining a series of operations together — all in a highly performant manner. Really cool.</p><p>Along those same lines, let’s take a look at how we could combine another <code>drop</code> variant — <code>dropFirst</code> — with <code>prefix</code> to easily add pagination support to any <code>BidirectionalCollection</code> (which includes types like <code>Array</code>, <code>Range</code>, and so on). By first calling <code>dropFirst</code> to remove all elements prior to where the current page begins, and then using <code>prefix</code> to extract a slice of the same size as our page size, we can implement our pagination extension like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">BidirectionalCollection</span> {
    <span class="s-keyword">func</span> page(withIndex pageIndex: <span class="s-type">Int</span>, size: <span class="s-type">Int</span>) -&gt; <span class="s-type">SubSequence</span> {
        <span class="s-call">dropFirst</span>(pageIndex * size).<span class="s-call">prefix</span>(size)
    }
}</code></pre><p>Going back to our <code>TodoList</code> type from before, we can then wrap the above API in a slightly more high-level abstraction, giving us a really nice pagination method that can be used to display any list of todo items in a page-by-page manner:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">func</span> page(at index: <span class="s-type">Int</span>) -&gt; <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items.<span class="s-call">page</span>(withIndex: index, size: <span class="s-number">25</span>)
    }
}</code></pre><p>At first, it might seem like a strange decision to return an <code>ArraySlice</code> from the above API, instead of converting the result into a proper <code>Array</code>. However, by doing so we’re following the same conventions as the standard library does — enabling the call site to decide how and when to convert each slice, which in turn enables us to perform additional chaining without performance penalties.</p><h2>Splitting things up</h2><p>Finally, let’s take a look at a third variant of collection slicing — <em>splitting</em>, which is a technique that’s incredibly commonly used when working with strings. Swift offers two main ways of splitting strings — the <code>String</code> type’s own <code>split</code> method, as well as Foundation’s <code>components(separatedBy:)</code> API (which was inherited from Objective-C’s <code>NSString</code>):</p><pre class="splash"><code><span class="s-keyword">let</span> lines = text.<span class="s-call">components</span>(separatedBy: <span class="s-string">"\n"</span>)
<span class="s-keyword">let</span> lines = text.<span class="s-call">split</span>(separator: <span class="s-string">"\n"</span>)</code></pre><p>While the above two calls may seem like they’re doing the exact same thing, they’re actually quite different when we start looking at the details. For starters, the first variant accepts a <code>String</code> to use as a separator, while the second accepts a single <code>Character</code>. The first also returns an array of strings, compared to the second, which returns an array of <code>Substring</code> values — which gives the second variant much better performance characteristics in scenarios that don’t require any copying.</p><p>Another important difference is that <code>split</code> gives us the option to limit the amount of splits that’ll occur, which can help us boost performance in situations when we want to extract only a limited number of substrings from a much larger string. For example, here we’re extracting the first five lines from a large body of text, by combining <code>split</code> with <code>dropLast()</code> (in order to remove the last component, which represents the remainder of the text):</p><pre class="splash"><code><span class="s-keyword">let</span> firstLines = text.<span class="s-call">split</span>(
    separator: <span class="s-string">"\n"</span>,
    maxSplits: <span class="s-number">5</span>,
    omittingEmptySubsequences: <span class="s-keyword">true</span>
).<span class="s-call">dropLast</span>()</code></pre><p>What’s really cool about <code>split</code> is that it’s not just a <code>String</code> API — just like <code>prefix</code>, <code>suffix</code> and the various <code>drop</code> methods we’ve taken a look at so far, it can be used with any collection. For example, here’s how we could use it to split an array of analytics events up into sessions, based on when the app moved to and from the background:</p><pre class="splash"><code><span class="s-keyword">enum</span> Event: <span class="s-type">Equatable</span> {
    <span class="s-keyword">case</span> appEnteredForeground
    <span class="s-keyword">case</span> appEnteredBackground
    <span class="s-keyword">case</span> impression(contentID: <span class="s-type">ContentID</span>)
    <span class="s-keyword">case</span> interaction(contentID: <span class="s-type">ContentID</span>)
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> sessions() -&gt; [<span class="s-type">ArraySlice</span>&lt;<span class="s-type">Event</span>&gt;] {
        <span class="s-call">split</span>(omittingEmptySubsequences: <span class="s-keyword">true</span>) {
            $0 == .<span class="s-dotAccess">appEnteredForeground</span> ||
            $0 == .<span class="s-dotAccess">appEnteredBackground</span>
        }
    }
}</code></pre><p>The above is another example of when the Swift standard library’s protocol-oriented design really shines, as it gives us access to many different algorithms and pieces of functionality in a way that’s not directly tied to any concrete types. Not only can the APIs we’ve taken a look at in this article be used with any built-in collection, they can also be used with <a href="https://www.swiftbysundell.com/articles/creating-custom-collections-in-swift/">custom ones</a> as well.</p><h2>Conclusion</h2><p>Swift’s focus on <em>“algorithmic correctness”</em> is something that, at times, may seem like an over-optimization — especially when dealing with smaller amounts of data typically found in simpler client/server-based iOS apps. However, this design does give Swift a lot more versatility, and can also often guide us to adopt better practices when it comes to how we handle our data.</p><p>By limiting the amount of implicit copying and memory allocation that occurs when working with collections, we ultimately gain more control over our core data structures — which in turn can help us boost the overall performance of the apps that we build, even though it might require a few conversions here and there.</p><p>What do you think? Do you use collection slices when writing Swift code, or do you mostly consider them an implementation detail of the standard library? Let me know — along with your questions, comments or feedback — either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics</guid><title>Swift’s closure capturing mechanics</title><description>This week, let’s take a look at the various ways that Swift closures can capture the objects and values that they depend on, and how we can control those mechanics.</description><link>https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics</link><pubDate>Sun, 26 Jan 2020 19:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Closures are an increasingly important part of Swift, both in terms of the overall direction of the language itself, and when it comes to the ways that both Apple and third party developers design libraries and APIs using it. However, closures also come with a certain set of complexities and behaviors that at first can be quite difficult to fully grasp — especially when it comes to how they capture values and objects from their surrounding context in order to perform their work.</p><p>While we already took a look at various ways to capture objects within closures in 2017’s <em><a href="https://www.swiftbysundell.com/articles/capturing-objects-in-swift-closures">“Capturing objects in Swift closures”</a></em>, this week’s, let’s explore the concept of capturing more broadly — by taking a closer look at some of the opportunities and challenges that comes with writing capturing closures in general.</p><h2>Implicit capturing</h2><p>Whenever we’re defining an <em>escaping</em> closure — that is, a closure that either gets stored in a property, or captured by another escaping closure — it’ll implicitly capture any objects, values and functions that are referenced within it. Since such closures may be executed at a later time, they need to maintain strong references to all of their dependencies in order to prevent them from being deallocated in the meantime.</p><p>For example, here we’re using <em><a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a></em> to delay the presentation of a <code>UIAlertController</code> by three seconds, which requires the closure passed into the call to <code>asyncAfter</code> to capture the <code>presenter</code> view controller instance:</p><pre class="splash"><code><span class="s-keyword">func</span> presentDelayedConfirmation(in presenter: <span class="s-type">UIViewController</span>) {
    <span class="s-keyword">let</span> queue = <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>

    queue.<span class="s-call">asyncAfter</span>(deadline: .<span class="s-call">now</span>() + <span class="s-number">3</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"..."</span>,
            message: <span class="s-string">"..."</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        <span class="s-comment">// By simply refering to 'presenter' here, our closure
        // will automatically capture that instance, and retain
        // it until the closure itself gets released from memory:</span>
        presenter.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above behavior is really convenient, it can also become the source of some really tricky bugs and memory-related issues if we’re not careful.</p><p>For example, since we’re delaying the execution of the above code by a few seconds, it’s possible for our <code>presenter</code> view controller to have been removed from our app’s view hierarchy by the time the closure actually gets run — and while that wouldn’t be a catastrophe in this case, it would arguably be better for us to only present our confirmation if the view controller is still being retained by another object (presumably its parent view controller or window).</p><h2>Using capture lists</h2><p>This is where <em>capture lists</em> come in, which enable us to customize how a given closure captures any of the objects or values that it refers to. Using a capture list, we can instruct our above closure to capture the <code>presenter</code> view controller <em>weakly</em>, rather than <em>strongly</em> (which is the default). That way, the view controller will get deallocated if not referenced by any other part of our code base — resulting in memory getting freed up quicker, and no unnecessary operations being performed:</p><pre class="splash"><code><span class="s-keyword">func</span> presentDelayedConfirmation(in presenter: <span class="s-type">UIViewController</span>) {
    <span class="s-keyword">let</span> queue = <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>

    <span class="s-comment">// A capture list is defined using a set of square brackets
    // directly following a closure's opening curly bracket:</span>
    queue.<span class="s-call">asyncAfter</span>(deadline: .<span class="s-call">now</span>() + <span class="s-number">3</span>) { [<span class="s-keyword">weak</span> presenter] <span class="s-keyword">in</span>
        <span class="s-comment">// Here we verify that our presenter is still in memory,
        // otherwise we can return early:</span>
        <span class="s-keyword">guard let</span> presenter = presenter <span class="s-keyword">else</span> { <span class="s-keyword">return</span> }

        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"..."</span>,
            message: <span class="s-string">"..."</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        presenter.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>Capture lists are perhaps even more useful when we need to reference <code>self</code>, especially when doing so would cause a <em>retain cycle</em>, which is when two objects or closures refer to each other — preventing both of them from ever getting deallocated (since they can’t reach a reference count of zero).</p><p>Here’s an example of such a situation, in which we’re using a capture list to avoid referencing <code>self</code> strongly within a closure that will also be retained by <code>self</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    <span class="s-keyword">let</span> storage: <span class="s-type">UserStorage</span>
    <span class="s-keyword">private var</span> user: <span class="s-type">User</span> { <span class="s-keyword">didSet</span> { <span class="s-call">userDidChange</span>() } }

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">storage</span> = storage
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] user <span class="s-keyword">in
            self</span>?.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p class="info">Alternatively, we could’ve converted the above <code>user</code> property into a function using its key path, like we did in <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/%23converting-to-functions">“The power of key paths in Swift”</a> — since all that we’re doing inside of our observation closure is updating that property’s value.</p><p>The reason the above closure would end up causing a retain cycle if we didn’t capture <code>self</code> weakly is because <code>UserStorage</code> will retain that closure, and <code>self</code> already retains that object through its <code>storage</code> property.</p><h2>Weak references are not always the answer</h2><p>While the above two code samples might make it seem like always capturing <code>self</code> weakly is the way to go, that’s definitely not the case. Like with other kinds of memory management, we’ll have to carefully consider how <code>self</code> will be used within each situation, and for how long we expect each capturing closure to remain in memory.</p><p>For example, if we’re dealing with really short-lived closures, such as ones passed to the <code>UIView.animate</code> API (which are just executed to perform interpolation for an animation, and then released), capturing <code>self</code> is really not a problem, and will most likely lead to code that’s easier to read:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ProductViewController</span> {
    <span class="s-keyword">func</span> expandImageView() {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: <span class="s-number">0.3</span>) {
            <span class="s-keyword">self</span>.<span class="s-property">imageView</span>.<span class="s-property">frame</span> = <span class="s-keyword">self</span>.<span class="s-property">view</span>.<span class="s-property">bounds</span>
            <span class="s-keyword">self</span>.<span class="s-call">showImageCloseButton</span>()
        }
    }
}</code></pre><p>Note how we always need to explicitly refer to <code>self</code> when accessing both instance methods and properties within an escaping closure. That’s a good thing, as it requires us to make an explicit decision to capture <code>self</code>, given the consequences that doing so might have.</p><p>There are also many kinds of situations in which we <em>might want</em> to retain <code>self</code> even for longer — for example if the current object is required in order to perform a closure’s work, like in this case:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkingController</span> {
    <span class="s-keyword">func</span> makeImageUploadingTask(for image: <span class="s-type">Image</span>) -&gt; <span class="s-type">Task</span> {
        <span class="s-type">Task</span> { handler <span class="s-keyword">in
            let</span> request = <span class="s-type">Request</span>(
                endpoint: .<span class="s-dotAccess">imageUpload</span>,
                payload: image
            )

            <span class="s-comment">// The current NetworkingController is required here,
            // so for as long the returned task is retained,
            // we'll also retain its underlying controller:</span>
            <span class="s-keyword">self</span>.<span class="s-call">perform</span>(request, then: handler)
        }
    }
}</code></pre><p class="info">The above code won’t cause any retain cycles, since <code>NetworkingController</code> doesn’t retain the tasks that it creates. For more sophisticated ways of modeling and working with tasks in Swift, check out <a href="https://www.swiftbysundell.com/articles/task-based-concurrency-in-swift">“Task-based concurrency in Swift”</a>.</p><p>We can also capture each of a closure’s dependencies directly, rather than referencing <code>self</code> — again using a capture list. For example, here we’re capturing an image loader’s <code>cache</code> property in order to be able to use it once an image was successfully downloaded:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> cache = <span class="s-type">Cache</span>&lt;<span class="s-type">URL</span>, <span class="s-type">Image</span>&gt;()

    <span class="s-keyword">func</span> loadImage(
        from url: <span class="s-type">URL</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Image</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-comment">// Here we capture our image loader's cache without
        // capturing 'self', and without having to deal with
        // any optionals or weak references:</span>
        <span class="s-call">request</span>(url) { [cache] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> image = <span class="s-keyword">try</span> result.<span class="s-call">decodedAsImage</span>()
                cache.<span class="s-call">insert</span>(image, forKey: url)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>The above technique works really well when we only need access to a few of our properties, rather than to <code>self</code> as a whole — as long as those properties either contain reference types (class instances), or immutable value types.</p><h2>Capturing values</h2><p>Value types can sometimes be a bit more complex to deal with when it comes to closure capturing, since they’re passed to external scopes <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">as copies, rather than as references</a>. Although that’s exactly what makes Swift’s value types so powerful, it can have somewhat unexpected consequences in situations like the one below — in which we’re capturing a <code>sender</code> and <code>message</code> property when assigning a <code>handler</code> closure to a button:</p><pre class="splash"><code><span class="s-keyword">class</span> MessageComposerViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> sender: <span class="s-type">MessageSender</span>
    <span class="s-keyword">private var</span> message = <span class="s-type">Message</span>()
    <span class="s-keyword">private lazy var</span> sendButton = <span class="s-type">ActionButton</span>()
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        ...

        sendButton.<span class="s-property">handler</span> = { [sender, message] <span class="s-keyword">in</span>
            sender.<span class="s-call">send</span>(message)
        }
    }
}</code></pre><p>At first glance, the above code may seem perfectly fine. However, the <code>Message</code> type that we’re using above is implemented as a struct, which gives it <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">value semantics</a> — meaning that we’re just capturing its <em>current value</em> when adding it to our capture list. So even though that value might change during our view controller’s lifecycle, once our <code>sendButton</code> is tapped, we’ll still send our original value — which isn’t great.</p><p>One way to solve the above problem, while still avoiding any additional <code>guard</code> statements, would be to only capture <code>self</code> to be able to access its <code>message</code> — and then map that value directly to our sender’s <code>send</code> method, like this:</p><pre class="splash"><code>sendButton.<span class="s-property">handler</span> = { [<span class="s-keyword">weak self</span>, sender] <span class="s-keyword">in
    let</span> message = <span class="s-keyword">self</span>?.<span class="s-property">message</span>
    message.<span class="s-call">map</span>(sender.<span class="s-property">send</span>)
}</code></pre><p>However, the above is really only a problem when dealing with mutable values. If we instead only have constants, like in the following example, then we can add those properties to any closure’s capture list without any problems (as their values won’t change):</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">private let</span> product: <span class="s-type">Product</span>

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        ...

        buyButton.<span class="s-property">handler</span> = { [productManager, product] <span class="s-keyword">in</span>
            productManager.<span class="s-call">startCheckout</span>(for: product)
        }
    }
}</code></pre><p class="info">In situations like the one above, we could also create a new function by combining our value (<code>product</code> in this case) with the method that it’ll be passed into. Check out <a href="https://www.swiftbysundell.com/clips/1">the first episode of Swift Clips</a> for an example of doing just that.</p><p>Finally, let’s take a look at how values are captured when it comes to <em>local variables</em>. Contrary to how value-based properties are captured, local variables still maintain their connection to their original declaration when captured by a closure <em>within the same scope</em> — which can be incredibly useful in order to keep track of various kinds of state.</p><p>For example, let’s say that we wanted to extend Swift’s <code>Collection</code> protocol with an API to enable us to iterate over any collection using a buffer consisting of the current element, as well as the next one. That could be done by combining the standard library’s <code>AnySequence</code> and <code>AnyIterator</code> types with locally captured values — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Collection</span> {
    <span class="s-keyword">typealias</span> Buffer = (current: <span class="s-type">Element</span>, next: <span class="s-type">Element</span>?)

    <span class="s-keyword">var</span> buffered: <span class="s-type">AnySequence</span>&lt;<span class="s-type">Buffer</span>&gt; {
        <span class="s-type">AnySequence</span> { () -&gt; <span class="s-type">AnyIterator</span>&lt;<span class="s-type">Buffer</span>&gt; <span class="s-keyword">in</span>
            <span class="s-comment">// We define our state as local variables:</span>
            <span class="s-keyword">var</span> iterator = <span class="s-keyword">self</span>.<span class="s-call">makeIterator</span>()
            <span class="s-keyword">var</span> next: <span class="s-type">Element</span>?

            <span class="s-keyword">return</span> <span class="s-type">AnyIterator</span> { () -&gt; <span class="s-type">Buffer</span>? <span class="s-keyword">in</span>
                <span class="s-comment">// We can then use our state to make decisions by
                // capturing them within our iterator's closure:</span>
                <span class="s-keyword">guard let</span> current = next ?? iterator.<span class="s-call">next</span>() <span class="s-keyword">else</span> {
                    <span class="s-keyword">return nil</span>
                }

                next = iterator.<span class="s-call">next</span>()
                <span class="s-keyword">return</span> (current, next)
            }
        }
    }
}</code></pre><p class="info">For more information about the above way of creating custom sequences, check out <a href="https://www.swiftbysundell.com/articles/wrapping-sequences-in-swift">“Wrapping sequences in Swift”</a>.</p><p>So values <em>copied</em> when captured using a capture list, while they’re <em>not copied</em> when referenced directly — for example when accessed as properties, or when a local variable is captured within the same scope as it was defined in.</p><h2>Unowned references</h2><p>One final option when it comes to closure capturing is to use <code>unowned</code> references. These are, just like <code>weak</code> references, specified using capture lists — and can also only be applied to reference types. Using <code>unowned</code> gives us essentially the same result as when using force-unwrapped optionals, in that it lets us treat a weak reference as if it was non-optional, but will result in a crash if we try to access it after it was deallocated.</p><p>Going back to our <code>UserModelController</code> example from before, here’s what it’d look like if we were to use <code>unowned</code> instead of <code>weak</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    ...

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        ...

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">unowned self</span>] user <span class="s-keyword">in
            self</span>.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p>While using <code>unowned</code> lets us get rid of optionals, and might occasionally be really convenient, the fact that it causes crashes for deallocated references makes it quite dangerous to use unless we’re absolutely certain that a given closure won’t accidentally be triggered after one of its dependencies has been deallocated.</p><p>One advantage of such crashes, however, is that they let us identify code paths that ideally should never have been entered. For example, if our above observation closure ends up getting triggered after <code>self</code> was deallocated, that probably means that we’re not unregistering our observations properly, which would be great to know.</p><p>However, rather than using <code>unowned</code>, we could (in this case) achieve the exact same thing using an <code>assert</code> — and while doing so will result in a bit more code, it’ll also give us a much more actionable error message in case of a failure, and we wouldn’t be causing any crashes in production:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    ...

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        ...

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] user <span class="s-keyword">in</span>
            <span class="s-call">assert</span>(<span class="s-keyword">self</span> != <span class="s-keyword">nil</span>, <span class="s-string">"""
            It seems like UserModelController didn't unregister \
            itself as a storage observer before being deallocated
            """</span>)

            <span class="s-keyword">self</span>?.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p class="info">To learn more about <code>assert</code>, along with other ways of propagating various errors — check out <a href="https://www.swiftbysundell.com/articles/picking-the-right-way-of-failing-in-swift">“Picking the right way of failing in Swift”</a>.</p><h2>Conclusion</h2><p>Although Swift’s <em><a href="https://www.swiftbysundell.com/basics/memory-management">Automatic Reference Counting</a></em> memory management model doesn’t require us to manually allocate and deallocate memory, it still requires us to decide exactly how we want our various objects and values to be referenced.</p><p>While it’s common to hear over-simplified rules like <em>“Always use <code>weak</code> references within closures”</em>, writing well-performing and predictable apps and systems often requires a bit more nuanced thinking than that. Like with most things within the world of software development, the best approach tends to be to throughly learn the underlying mechanics and behaviors, and then choose how to apply them within each given situation.</p><p>Hopefully this article has provided a few insights into those mechanics and behaviors when it comes to closure capturing, and if you have any questions, comments or feedback — just let me know, either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/result-type-convenience-apis</guid><title>Tip: Result’s convenience APIs</title><description></description><link>https://www.swiftbysundell.com/tips/result-type-convenience-apis</link><pubDate>Fri, 24 Jan 2020 17:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The Swift standard library’s <code>Result</code> type might just be a simple enum with cases for modeling an operation’s <code>success</code> or <code>failure</code>, but it also comes with several really useful convenience APIs built-in.</p><p>For example, it has a closure-based initializer, which we can use to easily convert any expression that <code>throws</code> into a <code>Result</code> value:</p><pre class="splash"><code><span class="s-keyword">let</span> data: <span class="s-type">Data</span> = ...
<span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()

<span class="s-comment">// This will create a Result&lt;Model, Error&gt; instance, which will contain
// 'success' if its expression succeeded, and 'failure' if it ended
// up throwing an error:</span>
<span class="s-keyword">let</span> result = <span class="s-type">Result</span> {
    <span class="s-keyword">try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Model</span>.<span class="s-keyword">self</span>, from: data)
}

<span class="s-comment">// The above API is really useful when we want to return a Result
// value from an asynchronous operation, for example by calling
// a completion handler:</span>
<span class="s-call">completionHandler</span>(result)</code></pre><p>Above we’re converting a raw <code>Data</code> value into a decoded <code>Result</code>, but we can also do the opposite — and extract a <code>Data</code> value from a <code>Result</code> instance, which we’ll then decode:</p><pre class="splash"><code><span class="s-keyword">func</span> decode(<span class="s-keyword">_</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Model</span> {
    <span class="s-comment">// Using Result's 'get' method, we can either extract its
    // underlying value, or throw any error that it contains:</span>
    <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
    <span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()
    <span class="s-keyword">return try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Model</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>Finally, <code>Result</code> also ships with a series of really useful mapping functions, for example <code>map</code> — which enables us to convert any result’s value into a new type, without having to do any error handling as part of such an operation:</p><pre class="splash"><code><span class="s-keyword">let</span> dataResult: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt; = ...

<span class="s-keyword">let</span> stringResult = dataResult.<span class="s-call">map</span> {
    <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>)
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/property-wrappers-in-swift</guid><title>Property wrappers in Swift</title><description>This week, let’s take a look at how Swift’s property wrappers work, and explore a few examples of situations in which they could be really useful.</description><link>https://www.swiftbysundell.com/articles/property-wrappers-in-swift</link><pubDate>Sun, 19 Jan 2020 22:20:00 +0100</pubDate><content:encoded><![CDATA[<p>When dealing with properties that represent some form of state, it’s very common to have some kind of associated logic that gets triggered every time that a value is modified. For example, we might validate each new value according to a set of rules, we might transform our assigned values in some way, or we might be notifying a set of observers whenever a value was changed.</p><p>In those kinds of situations, Swift 5.1’s <em>property wrappers</em> feature can be incredibly useful, as it enables us to attach such behaviors and logic directly to our properties themselves — which often opens up new opportunities for code reuse and generalization. This week, let’s take a look at how property wrappers work, and explore a few examples of situations in which they could be used in practice.</p><h2>Transparently wrapping a value</h2><p>Like the name implies, a property wrapper is essentially a type that <em>wraps</em> a given value in order to attach additional logic to it — and can be implemented using either a struct or a class by annotating it with the <code>@propertyWrapper</code> attribute. Besides that, the only real requirement is that each property wrapper type should contain a stored property called <code>wrappedValue</code>, which tells Swift which underlying value that’s being wrapped.</p><p>For example, let’s say that we wanted to create a property wrapper that automatically capitalizes all <code>String</code> values that were assigned to it. That might be implemented like this:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> Capitalized {
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">String</span> {
        <span class="s-keyword">didSet</span> { wrappedValue = wrappedValue.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue.<span class="s-property">capitalized</span>
    }
}</code></pre><p class="info">Note how we need to explicitly capitalize any string that was passed into our initializer, since <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">property observers</a> are only triggered after a value or object was fully initialized.</p><p>To apply our new property wrapper to any of our <code>String</code> properties, we simply have to annotate it with <code>@Capitalized</code> — and Swift will automatically match that annotation to our above type. Here’s how we might do that to ensure that a <code>User</code> type’s <code>firstName</code> and <code>lastName</code> properties are always capitalized:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">@Capitalized var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">@Capitalized var</span> lastName: <span class="s-type">String</span>
}</code></pre><p>The cool thing about property wrappers is that they act completely transparently, which means that we can still work with our above two properties as if they were normal strings — both when initializing our <code>User</code> type, and when modifying its property values:</p><pre class="splash"><code><span class="s-comment">// John Appleseed</span>
<span class="s-keyword">var</span> user = <span class="s-type">User</span>(firstName: <span class="s-string">"john"</span>, lastName: <span class="s-string">"appleseed"</span>)

<span class="s-comment">// John Sundell</span>
user.<span class="s-property">lastName</span> = <span class="s-string">"sundell"</span></code></pre><p>Similarly, as long as a property wrapper defines an <code>init(wrappedValue:)</code> initializer (like our <code>Capitalized</code> type does) — then we can even natively assign default values to our wrapped properties, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Document {
    <span class="s-keyword">@Capitalized var</span> name = <span class="s-string">"Untitled document"</span>
}</code></pre><p>So property wrappers enable us to transparently wrap and modify any stored property — using a combination of an <code>@propertyWrapper</code>-marked type, and annotations matching the name of that type. But that’s just the beginning.</p><h2>A property’s properties</h2><p>Property wrappers can also have properties of their own, which enables further customization, and even makes it possible to inject dependencies into our wrapper types.</p><p>As an example, let’s say that we’re working on a messaging app that uses Foundation’s <code>UserDefaults</code> API to store various user settings and other pieces of lightweight data on disk. Doing so typically involves writing some form of mapping code for synchronizing each value with its underlying <code>UserDefaults</code> storage — which often needs to be replicated for each piece of data that we’re looking to store.</p><p>However, by implementing that sort of logic within a generic property wrapper, we could make it easily reusable — as doing so would let us simply attach our wrapper to any property that we’d like to be backed by <code>UserDefaults</code>. Here’s what such a wrapper might look like:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    <span class="s-keyword">let</span> key: <span class="s-type">String</span>
    <span class="s-keyword">var</span> storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>? {
        <span class="s-keyword">get</span> { storage.<span class="s-call">value</span>(forKey: key) <span class="s-keyword">as</span>? <span class="s-type">Value</span> }
        <span class="s-keyword">set</span> { storage.<span class="s-call">setValue</span>(newValue, forKey: key) }
    }
}</code></pre><p>Just like any other struct, our above <code>UserDefaultsBacked</code> type will automatically get a <a href="https://www.swiftbysundell.com/tips/improved-memberwise-initializers-in-swift-5-1">memberwise initializer</a> with default arguments for all properties that have a default value — which means that we’ll be able to initialize instances of it by simply specifying which <code>UserDefaults</code> key that we want each property to be backed by:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p class="info">The compiler will automatically infer which type to specialize our generic <code>UserDefaultsBacked</code> wrapper with, based on the type of the property that it’s wrapping.</p><p>The above setup makes our new property wrapper easy to use whenever we want a property to be backed by <code>UserDefaults.standard</code>, but since we parameterized that dependency, we could also choose to use a custom instance if we’d like — for example to facilitate testing, or to be able to share values between multiple apps within the same app group:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UserDefaults</span> {
    <span class="s-keyword">static var</span> shared: <span class="s-type">UserDefaults</span> {
        <span class="s-keyword">let</span> combined = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
        combined.<span class="s-call">addSuite</span>(named: <span class="s-string">"group.johnsundell.app"</span>)
        <span class="s-keyword">return</span> combined
    }
}

<span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaults: .<span class="s-dotAccess">shared</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaults: .<span class="s-dotAccess">shared</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p class="info">For more information about using <code>UserDefaults</code> to share data between multiple apps, check out <a href="https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift">“The power of UserDefaults in Swift”</a>.</p><p>However, our above implementation has a quite significant flaw. Even though both of our above two properties are declared as non-optional, their actual values will still be optionals, since our <code>UserDefaultsBacked</code> type specifies <code>Value?</code> as its <code>wrappedValue</code> property’s type.</p><p>Thankfully, that flaw can be quite easily fixed. All we have to do is to add a <code>defaultValue</code> property to our wrapper, which we’ll then use whenever our underlying <code>UserDefaults</code> storage didn’t contain a value for our property’s key:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    <span class="s-keyword">let</span> key: <span class="s-type">String</span>
    <span class="s-keyword">let</span> defaultValue: <span class="s-type">Value</span>
    <span class="s-keyword">var</span> storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> {
        <span class="s-keyword">get</span> {
            <span class="s-keyword">let</span> value = storage.<span class="s-call">value</span>(forKey: key) <span class="s-keyword">as</span>? <span class="s-type">Value</span>
            <span class="s-keyword">return</span> value ?? defaultValue
        }
        <span class="s-keyword">set</span> {
            storage.<span class="s-call">setValue</span>(newValue, forKey: key)
        }
    }
}</code></pre><p>With the above in place, we’re now able to turn both of our properties into non-optionals, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaultValue: <span class="s-keyword">true</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaultValue: <span class="s-number">20</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p>That’s really nice. However, some of our <code>UserDefaults</code> values are likely to <em>actually be optionals</em>, and it would be unfortunate if we had to constantly specify <code>nil</code> as the default value for those properties — as that’s not something that we have to do when <em>not</em> using property wrappers.</p><p>To address that, let’s also add a convenience API to our wrapper for whenever its <code>Value</code> type conforms to <code>ExpressibleByNilLiteral</code> (which <code>Optional</code> does) — in which we’ll automatically insert <code>nil</code> as the default value:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UserDefaultsBacked</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">ExpressibleByNilLiteral</span> {
    <span class="s-keyword">init</span>(key: <span class="s-type">String</span>, storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(key: key, defaultValue: <span class="s-keyword">nil</span>, storage: storage)
    }
}</code></pre><p>With the above change in place, we can now freely use our <code>UserDefaultsBacked</code> wrapper with both optional and non-optional values with ease:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaultValue: <span class="s-keyword">true</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaultValue: <span class="s-number">20</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"signature"</span>)
    <span class="s-keyword">var</span> messageSignature: <span class="s-type">String</span>?
}</code></pre><p>However, there is one more thing that we’ll need to take into account, since we’ll now be able to assign <code>nil</code> to a <code>UserDefaultsBacked</code> property. To avoid crashes in such situations, we’ll have to update our property wrapper to first check if any assigned value is <code>nil</code> before proceeding to store it within the current <code>UserDefaults</code> instance, like this:</p><pre class="splash"><code><span class="s-comment">// Since our property wrapper's Value type isn't optional, but
// can still contain nil values, we'll have to introduce this
// protocol to enable us to cast any assigned value into a type
// that we can compare against nil:</span>
<span class="s-keyword">private protocol</span> AnyOptional {
    <span class="s-keyword">var</span> isNil: <span class="s-type">Bool</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">Optional</span>: <span class="s-type">AnyOptional</span> {
    <span class="s-keyword">var</span> isNil: <span class="s-type">Bool</span> { <span class="s-keyword">self</span> == <span class="s-keyword">nil</span> }
}

<span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    ...

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> {
        <span class="s-keyword">get</span> { ... }
        <span class="s-keyword">set</span> {
            <span class="s-keyword">if let</span> optional = newValue <span class="s-keyword">as</span>? <span class="s-type">AnyOptional</span>, optional.<span class="s-property">isNil</span> {
                storage.<span class="s-call">removeObject</span>(forKey: key)
            } <span class="s-keyword">else</span> {
                storage.<span class="s-call">setValue</span>(newValue, forKey: key)
            }
        }
    }
}</code></pre><p>The fact that property wrappers are implemented as actual types gives us a lot of power — as we can give them properties, initializers, and even extensions — which in turn enables us to both make our call sites really neat and clean, and to make full use of Swift’s robust type system.</p><h2>Decoding and overriding</h2><p>Although most property wrappers are likely going to be implemented as structs in order to <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">utilize value semantics</a>, sometimes we might want to opt for <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference semantics</a> by using a class instead.</p><p>For example, let’s say that we’re working on a project that uses <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift">feature flags</a> to enable testing and gradual rollouts of new features and experiments, and that we want to build a property wrapper that’ll let us specify such flags in different ways. Since we’ll want to share those values across our code base, we’ll implement that wrapper as a class:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper final class</span> Flag&lt;Value&gt; {
    <span class="s-keyword">let</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>

    <span class="s-keyword">fileprivate init</span>(name: <span class="s-type">String</span>, defaultValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = defaultValue
    }
}</code></pre><p>With our new wrapper type in place, we can now start defining our flags as properties within an encapsulating <code>FeatureFlags</code> type — which’ll act as a single source of truth for all of our app’s feature flags:</p><pre class="splash"><code><span class="s-keyword">struct</span> FeatureFlags {
    <span class="s-keyword">@Flag</span>(name: <span class="s-string">"feature-search"</span>, defaultValue: <span class="s-keyword">false</span>)
    <span class="s-keyword">var</span> isSearchEnabled: <span class="s-type">Bool</span>

    <span class="s-keyword">@Flag</span>(name: <span class="s-string">"experiment-note-limit"</span>, defaultValue: <span class="s-number">999</span>)
    <span class="s-keyword">var</span> maximumNumberOfNotes: <span class="s-type">Int</span>
}</code></pre><p>At this point, the above <code>Flag</code> property wrapper might seem a bit redundant, given that it doesn’t actually do anything other than store its <code>wrappedValue</code> — but that’s about to change.</p><p>A very common way to use feature flags is to download their values over the network, for example every time that the app launches, or according to a certain time interval. However, even when using <a href="https://www.swiftbysundell.com/basics/codable">Codable</a>, there’s typically a fair amount of boilerplate involved in making that happen — given that we’ll most likely want to fall back to our app’s default values for flags that may not have been added to our backend yet (or those that have been removed after a test or rollout was completed).</p><p>So let’s use our <code>Flag</code> property wrapper to implement that form of decoding. Since we want to use each flag’s <code>name</code> as its coding key, the first thing we’ll do is to define a new <code>CodingKey</code> type that’ll let us do just that:</p><pre class="splash"><code><span class="s-keyword">private struct</span> FlagCodingKey: <span class="s-type">CodingKey</span> {
    <span class="s-keyword">var</span> stringValue: <span class="s-type">String</span>
    <span class="s-keyword">var</span> intValue: <span class="s-type">Int</span>?

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        stringValue = name
    }
    
    <span class="s-comment">// These initializers are required by the CodingKey protocol:</span>

    <span class="s-keyword">init</span>?(stringValue: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">stringValue</span> = stringValue
    }

    <span class="s-keyword">init</span>?(intValue: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">intValue</span> = intValue
        <span class="s-keyword">self</span>.<span class="s-property">stringValue</span> = <span class="s-type">String</span>(intValue)
    }
}</code></pre><p>Next, we’re going to need a way to reference each of our flags without knowing their generic type — but rather than resorting to <a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">full type erasure</a>, we’re going to add a protocol called <code>DecodableFlag</code>, which’ll enable each flag to decode its own value according to its <code>Value</code> type:</p><pre class="splash"><code><span class="s-keyword">private protocol</span> DecodableFlag {
    <span class="s-keyword">typealias</span> Container = <span class="s-type">KeyedDecodingContainer</span>&lt;<span class="s-type">FlagCodingKey</span>&gt;
    <span class="s-keyword">func</span> decodeValue(from container: <span class="s-type">Container</span>) <span class="s-keyword">throws</span>
}</code></pre><p>Besides enabling our server to fully control our app’s feature flags, it would also be really useful to be able to add local overrides for individual flags as well. That way we could specify exactly which values to use when writing <a href="https://www.swiftbysundell.com/articles/getting-started-with-xcode-ui-testing-in-swift">UI tests</a>, and easily enable a new feature while working on it. So let’s also add that capability to our <code>Flag</code> wrapper, which we’ll do by once again using <code>UserDefaults</code> (which has the somewhat hidden feature of being able to <a href="https://www.swiftbysundell.com/tips/parsing-command-line-arguments-using-userdefaults">parse command line arguments</a>), giving us a decoding implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Flag</span>: <span class="s-type">DecodableFlag</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">fileprivate func</span> decodeValue(from container: <span class="s-type">Container</span>) <span class="s-keyword">throws</span> {
        <span class="s-comment">// This enables us to pass an override using a command line
        // argument matching the flag's name:</span>
        <span class="s-keyword">if let</span> value = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">value</span>(forKey: name) {
            <span class="s-keyword">if let</span> matchingValue = value <span class="s-keyword">as</span>? <span class="s-type">Value</span> {
                wrappedValue = matchingValue
                <span class="s-keyword">return</span>
            }
        }

        <span class="s-keyword">let</span> key = <span class="s-type">FlagCodingKey</span>(name: name)

        <span class="s-comment">// We only want to attempt to decode a value if it's present,
        // to enable our app to fall back to its default value
        // in case the flag is missing from our backend data:</span>
        <span class="s-keyword">if let</span> value = <span class="s-keyword">try</span> container.<span class="s-call">decodeIfPresent</span>(<span class="s-type">Value</span>.<span class="s-keyword">self</span>, forKey: key) {
            wrappedValue = value
        }
    }
}</code></pre><p class="info">For more information about using command line arguments to implement debugging utilities, check out <a href="https://www.swiftbysundell.com/articles/launch-arguments-in-swift">“Launch arguments in Swift”</a>.</p><p>Finally, let’s complete our decoding implementation by making <code>FeatureFlags</code> conform to <code>Decodable</code>. Here we’ll use <a href="https://www.swiftbysundell.com/articles/reflection-in-swift">reflection</a> to dynamically iterate over each of our flag properties, and we’ll then ask each flag to attempt to decode its value using the current decoding container, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">FeatureFlags</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">container</span>(keyedBy: <span class="s-type">FlagCodingKey</span>.<span class="s-keyword">self</span>)

        <span class="s-keyword">for</span> child <span class="s-keyword">in</span> <span class="s-type">Mirror</span>(reflecting: <span class="s-keyword">self</span>).<span class="s-property">children</span> {
            <span class="s-keyword">guard let</span> flag = child.<span class="s-property">value</span> <span class="s-keyword">as</span>? <span class="s-type">DecodableFlag</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">continue</span>
            }

            <span class="s-keyword">try</span> flag.<span class="s-call">decodeValue</span>(from: container)
        }
    }
}</code></pre><p>While we did have to implement a bit of underlying infrastructure, we now have a very flexible feature flag system in place — with the ability to specify flag values both server- and client side, support for overriding flags via command line arguments, and for new flags to be defined simply by adding a <code>@Flag</code>-annotated property to our <code>FeatureFlags</code> type.</p><h2>Projected values</h2><p>As we’ve explored so far in this article, one of the major benefits of property wrappers is that they enable us to add logic and behaviors to properties in a way that doesn’t impact our call sites at all — as values are read and written the exact same way regardless of whether a property is wrapped or not.</p><p>However, sometimes we might actually want to access a property wrapper itself, rather than the value that it’s wrapping. That’s especially common when building UIs using Apple’s new <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> framework, which makes <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23property-wrappers">heavy use of property wrappers</a> to implement its various data binding APIs.</p><p>For example, here we’re building a <code>QuantityView</code> that enables some form of quantity to be specified using a <code>Stepper</code> view. In order to bind that piece of state to our view, we’ve annotated it with <code>@State</code>, and we’re then giving our stepper direct access to that wrapped state (rather than just its current <code>Int</code> value) by passing it prefixed with <code>$</code> — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> QuantityView: <span class="s-type">View</span> {
    ...
    <span class="s-keyword">@State private var</span> quantity = <span class="s-number">1</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Passing a wrapped property prefixd with "$" passes
        // the property wrapper itself, rather than its value:</span>
        <span class="s-type">Stepper</span>(<span class="s-string">"Quantity:</span> \(quantity)<span class="s-string">"</span>,
            value: $quantity,
            in: <span class="s-number">1</span>...<span class="s-number">99</span>
        )
    }
}</code></pre><p>The above feature might seem like something that was tailor-made for SwiftUI, but it’s actually a capability that can be added to any property wrapper, for example our <code>Flag</code> type from before. That <em>“dollar-prefixed”</em> version of our above property is known as its wrapper’s <em>projected value</em>, and is implemented by adding a <code>projectedValue</code> property to any wrapper type:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper final class</span> Flag&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Flag</span> { <span class="s-keyword">self</span> }
    ...
}</code></pre><p>Just like that, any <code>Flag</code>-annotated property can now also be passed as a projected value — that is, as a reference to its wrapper itself. Again, that’s not something that’s coupled with SwiftUI, in fact we could adopt the same sort of pattern when using UIKit as well — for example by having a <code>UIViewController</code> accept an instance of <code>Flag</code> when initialized.</p><p>Here’s an example of how we might do just that to implement a view controller that’ll let us toggle a given <code>Bool</code>-based feature flag on or off when using a debug build of our app:</p><pre class="splash"><code><span class="s-keyword">class</span> FlagToggleViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> flag: <span class="s-type">Flag</span>&lt;<span class="s-type">Bool</span>&gt;
    <span class="s-keyword">private lazy var</span> label = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> toggle = <span class="s-type">UISwitch</span>()

    <span class="s-keyword">init</span>(flag: <span class="s-type">Flag</span>&lt;<span class="s-type">Bool</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">flag</span> = flag
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        label.<span class="s-property">text</span> = flag.<span class="s-property">name</span>
        toggle.<span class="s-property">isOn</span> = flag.<span class="s-property">wrappedValue</span>

        toggle.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(toggleFlag),
            for: .<span class="s-dotAccess">valueChanged</span>
        )
        
        ...
    }

    <span class="s-keyword">@objc private func</span> toggleFlag() {
        flag.<span class="s-property">wrappedValue</span> = toggle.<span class="s-property">isOn</span>
    }
}</code></pre><p>To initialize the above view controller, we’ll use the same <code>$</code>-prefix-based syntax as when passing an <code>@State</code> reference when using SwiftUI:</p><pre class="splash"><code><span class="s-keyword">let</span> flags: <span class="s-type">FeatureFlags</span> = ...

<span class="s-keyword">let</span> searchToggleVC = <span class="s-type">FlagToggleViewController</span>(
    flag: flags.<span class="s-property">$isSearchEnabled</span>
)</code></pre><p>We’ll definitely explore the above use of property wrappers more in upcoming articles — as it could enable us to make our code more declarative, to implement property-based observation APIs, to perform quite sophisticated data binding, and much more.</p><h2>Conclusion</h2><p>Property wrappers is definitely one of the most exciting new features in Swift 5.1 — as it opens up a lot of doors for code reuse and customizability, and enables powerful new ways to implement property-level functionality. Even outside of declarative frameworks like SwiftUI, there’s a ton of potential use cases for property wrappers, many of which won’t require us to make any big changes to our overall code — as property wrappers mostly operate completely transparently.</p><p>However, that transparency can be both an advantage and a liability. On one hand, it enables us to access and assign wrapped properties the exact same way as unwrapped ones — but on the other hand, the risk is that we’ll end up hiding too much functionality behind what might be a quite non-obvious abstraction.</p><p>What do you think? Have you started adopting property wrappers, or do you have a use case that you think they’d be a great fit for? Let me know — along with your comments, questions and feedback — either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/test-assertions-in-swift</guid><title>Test assertions in Swift</title><description>This week, let’s take a look at various ways that we can assert that our code produces the right outcomes within our unit tests, including how we can create our own assertion functions.</description><link>https://www.swiftbysundell.com/articles/test-assertions-in-swift</link><pubDate>Sun, 12 Jan 2020 22:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Most <a href="https://www.swiftbysundell.com/basics/unit-testing">unit tests</a> written using Apple’s built-in <code>XCTest</code> framework tend to follow a pattern made up of three steps: first, we set up the values and objects that we wish to test, we then perform a set of actions that trigger the functionality that we’re looking to verify, and finally we <em>assert</em> that the correct outcome was produced.</p><p>That may seem like a very simple structure, at least on the surface level, but just like when building any other kind of software, there’s a nearly infinite number of ways that we can approach each of those three steps when writing tests.</p><p>This week, let’s take a closer look at the last of those steps — asserting that our code produces the right outcome — by both exploring the <code>XCTAssert</code> family of functions that <code>XCTest</code> ships with, and also how we can construct our very own test assertions as well.</p><h2>Picking the right assertion</h2><p>A test assertion’s main role is to compare a certain result against a control value, and to fail the current test if those two values don’t match. The assertions that ship as part of the built-in <code>XCTest</code> framework all have the prefix <code>XCTAssert</code>, the most basic of which simply compares any boolean value against <code>true</code>:</p><pre class="splash"><code><span class="s-comment">// Without a custom message:</span>
<span class="s-call">XCTAssert</span>(aBoolValue)

<span class="s-comment">// With a custom message that will be displayed in case of a failure:</span>
<span class="s-call">XCTAssert</span>(aBoolValue, <span class="s-string">"An unexpected result was encountered"</span>)</code></pre><p>However, when it comes to most standard forms of verification, we rarely have to call <code>XCTAssert</code> directly — instead, there are a number of more specific versions of that function that we can use for different kinds of values.</p><p>For example, let’s say that we want to verify that a <code>ContentCollection</code> type correctly returns the right <code>Item</code> when queried using a specific item ID. To perform our assertion in this case, we’ll use <code>XCTAssertEqual</code>, which lets us verify that the returned item is equal to the one we were expecting — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ContentCollectionTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testQueryingItemByID() {
        <span class="s-keyword">var</span> collection = <span class="s-type">ContentCollection</span>()

        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(id: <span class="s-string">"an-item"</span>, title: <span class="s-string">"A title"</span>)
        collection.<span class="s-call">add</span>(item)

        <span class="s-keyword">let</span> retrievedItem = collection.<span class="s-call">item</span>(withID: <span class="s-string">"an-item"</span>)
        <span class="s-call">XCTAssertEqual</span>(retrievedItem, item)
    }
}</code></pre><p>While <code>XCTAssertEqual</code> is great in situations when we want to verify our code’s outcome against a very specific value, sometimes we might need keep our verification slightly less granular. For example, below we’re verifying that a <code>Cache</code> assigns an expiration date to an item when inserted — and we’re not really interested in verifying the <em>exact date</em> (since that’s an implementation detail of our cache itself), but rather just that <em>any date</em> was assigned, which can be done using <code>XCTAssertNil</code> and <code>XCTAssertNotNil</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> CacheTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testExpirationDateAssignedToInsertedItem() {
        <span class="s-keyword">let</span> cache = <span class="s-type">Cache</span>()
        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(id: <span class="s-string">"an-item"</span>, title: <span class="s-string">"A title"</span>)

        <span class="s-comment">// It's often a good idea to verify that our initial state
        // is correct as well, especially when dealing with code
        // that includes some form of persistence:</span>
        <span class="s-call">XCTAssertNil</span>(cache.<span class="s-call">expirationDate</span>(for: item))

        cache.<span class="s-call">insert</span>(item)
        <span class="s-call">XCTAssertNotNil</span>(cache.<span class="s-call">expirationDate</span>(for: item))
    }
}</code></pre><p>When picking which assertion function to use within each situation, it’s arguably just as important to consider how each potential option will behave <em>when failing</em> as it is to match it against the type of input that we’ll be passing into it.</p><p>As an example, let’s say that we wanted to verify that a <code>NoteManager</code> class successfully removed all of its notes when asked to do so. We’ll do that by verifying that our manager’s <code>allNotes</code> array is empty — which might make <code>XCTAssertTrue</code> seem like a perfect fit, as we can simply pass <code>allNotes.isEmpty</code> into it:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRemovingMultipleNotes() {
        <span class="s-keyword">let</span> manager = <span class="s-type">NoteManager</span>()

        <span class="s-keyword">let</span> notes = (<span class="s-number">0</span>..&lt;<span class="s-number">3</span>).<span class="s-call">map</span> { <span class="s-type">Note</span>(id: <span class="s-string">"</span>\($0)<span class="s-string">"</span>) }
        notes.<span class="s-call">forEach</span>(manager.<span class="s-property">add</span>)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">count</span>, <span class="s-number">3</span>)

        manager.<span class="s-call">remove</span>(notes)
        <span class="s-call">XCTAssertTrue</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">isEmpty</span>)
    }
}</code></pre><p>While the above will definitely work, the error message that we’ll get in case of a failure will simply be <em>“XCTAssertTrue failed”</em>, which doesn’t give us much of an indication as to what actually went wrong. If we instead could see the exact <code>Note</code> values that incorrectly remained within our <code>NoteManager</code> after our <code>remove()</code> call, that’d most likely make it much easier to debug such a failure.</p><p>To make that happen, let’s instead use <code>XCTAssertEqual</code> again, and simply compare our <code>allNotes</code> array with an empty one — which will show us exactly which notes that weren’t removed in case of a failure, since <code>XCTAssertEqual</code> always includes both of the values that it compared in any error message that it’ll generate:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRemovingMultipleNotes() {
        ...
        manager.<span class="s-call">remove</span>(notes)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>, [])
    }
}</code></pre><p>It’s of course quite difficult to predict what sort of information that we <em>might</em> want to get access to in order to debug future failures before they’ve even happened — but in general, the richer debugging information that we can provide our future selves when writing tests, the easier those tests tend to be to maintain and work with in the long run.</p><h2>Custom assertion functions</h2><p>While the default suite of <code>XCTAssert</code> functions definitely cover the most common use cases, there are situations in which we might want to extend that suite with a more specialized, custom assertion function that we’ve written ourselves.</p><p>An example of such a situation might be if our tests require us to verify slightly larger collections of data. Let’s say that our <code>NoteManager</code> from before also includes a pagination feature, which divides all added notes up into groups containing 25 elements each. To test that feature, we’re adding 50 notes to our manager, and we’re then asserting that each page contains the right subset of those added notes — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testPagination() {
        <span class="s-keyword">let</span> manager = <span class="s-type">NoteManager</span>()

        <span class="s-keyword">let</span> notes = (<span class="s-number">0</span>..&lt;<span class="s-number">50</span>).<span class="s-call">map</span> { <span class="s-type">Note</span>(id: <span class="s-string">"</span>\($0)<span class="s-string">"</span>) }
        notes.<span class="s-call">forEach</span>(manager.<span class="s-property">add</span>)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">count</span>, <span class="s-number">50</span>)

        <span class="s-call">XCTAssertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">0</span>),
            <span class="s-type">Array</span>(notes[..&lt;<span class="s-number">25</span>])
        )

        <span class="s-call">XCTAssertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">1</span>),
            <span class="s-type">Array</span>(notes[<span class="s-number">25</span>...])
        )

        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-call">notesOnPage</span>(<span class="s-number">2</span>), [])
    }
}</code></pre><p>Again, the above works perfectly fine as long as our test keeps succeeding, but if we’ll ever end up with a failure — say a single note that was misplaced — debugging that failure among an array of 25 or 50 values might become quite frustrating.</p><p>Wouldn’t it be great if we instead could see <em>exactly which element</em> that caused the failure, including any missing or unexpected new elements? Let’s see if we can make that happen by using Swift 5.1’s new <em><a href="https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1/%23ordered-collection-diffing">ordered collection diffing</a></em> feature. That feature will only work on iOS 13, macOS Catalina, and the other operating systems that Apple released in 2019, but that might not be an issue for our unit testing suite — even if we still ship our app itself with support for older system versions.</p><p>The ordered collection diffing API produces a <code>CollectionDifference</code> instance, which in turn is a collection containing <code>Change</code> values, that represent the changes between the two collections that are being compared. So let’s start by extending <code>CollectionDifference</code> with a method for converting a given change into a human-readable error message:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">CollectionDifference</span> {
    <span class="s-keyword">func</span> testDescription(for change: <span class="s-type">Change</span>) -&gt; <span class="s-type">String</span>? {
        <span class="s-keyword">switch</span> change {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> element, <span class="s-keyword">let</span> association):
            <span class="s-keyword">if let</span> oldIndex = association {
                <span class="s-keyword">return</span> <span class="s-string">"""
                Element moved from index</span> \(oldIndex) <span class="s-string">to</span> \(index)<span class="s-string">:</span> \(element)
                <span class="s-string">"""</span>
            } <span class="s-keyword">else</span> {
                <span class="s-keyword">return</span> <span class="s-string">"Additional element at index</span> \(index)<span class="s-string">:</span> \(element)<span class="s-string">"</span>
            }
        <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> element, <span class="s-keyword">let</span> association):
            <span class="s-comment">// If a removal has an association, it means that
            // it's part of a move, which we're handling above.</span>
            <span class="s-keyword">guard</span> association == <span class="s-keyword">nil else</span> {
                <span class="s-keyword">return nil</span>
            }

            <span class="s-keyword">return</span> <span class="s-string">"Missing element at index</span> \(index)<span class="s-string">:</span> \(element)<span class="s-string">"</span>
        }
    }
}</code></pre><p>Using the above, we can again extend <code>CollectionDifference</code> with another method that lets us convert its entire set of changes into one unified error message — like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">CollectionDifference</span> {
    <span class="s-keyword">func</span> asTestErrorMessage() -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">let</span> descriptions = <span class="s-call">compactMap</span>(testDescription)

        <span class="s-keyword">guard</span> !descriptions.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-string">""</span>
        }

        <span class="s-keyword">return</span> <span class="s-string">"- "</span> + descriptions.<span class="s-call">joined</span>(separator: <span class="s-string">"\n- "</span>)
    }
}</code></pre><p class="info">Above we’re making use of the fact that Swift supports <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class functions</a>, which enables us to pass our <code>testDescription(for:)</code> method as if it was a closure.</p><p>Finally, let’s write our new, custom assertion function — which we’ll simply call <code>assertEqual</code> (we shouldn’t use the <code>XCT</code> prefix since we’re defining this new function outside of the <code>XCTest</code> framework itself). Since the ordered collection diffing API is only compatible with collections that conform to <code>BidirectionalCollection</code>, we’ll make that a requirement for our new function, while also requiring that all elements conform to <code>Hashable</code>.</p><p>Within our function, we’ll then use the standard library’s <code>difference(from:)</code> API to produce a <code>CollectionDifference</code> instance, which we’ll convert into an error message using the method we defined above. If that message isn’t empty, we cause our test to fail by passing that message along to <code>XCTAssert</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> assertEqual&lt;T: <span class="s-type">BidirectionalCollection</span>&gt;(
    <span class="s-keyword">_</span> first: <span class="s-type">T</span>,
    <span class="s-keyword">_</span> second: <span class="s-type">T</span>,
    file: <span class="s-type">StaticString</span> = <span class="s-keyword">#file</span>,
    line: <span class="s-type">UInt</span> = <span class="s-keyword">#line</span>
) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span> {
    <span class="s-keyword">let</span> diff = second.<span class="s-call">difference</span>(from: first).<span class="s-call">inferringMoves</span>()
    <span class="s-keyword">let</span> message = diff.<span class="s-call">asTestErrorMessage</span>()

    <span class="s-call">XCTAssert</span>(message.<span class="s-property">isEmpty</span>, <span class="s-string">"""
    The two collections are not equal. Differences:</span>
    \(message<span class="s-string">)
    """</span>, file: file, line: line)
}</code></pre><p class="info">Note how we capture the <code>file</code> and <code>line</code> of the code location that our custom assertion function was called from, and we then pass that data along to <code>XCTAssert</code>. That way, Xcode will display any failures that our function will generate at the correct location, inline within our code.</p><p>With the above in place, all we now need to do is to replace our previous test implementation’s calls to <code>XCTAssertEqual</code> with <code>assertEqual</code>, and we’ll get much more granular (and actionable) error messages if we ever start encountering a failure:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testPagination() {
        ...
        
        <span class="s-call">assertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">0</span>),
            <span class="s-type">Array</span>(notes[..&lt;<span class="s-number">25</span>])
        )

        <span class="s-call">assertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">1</span>),
            <span class="s-type">Array</span>(notes[<span class="s-number">25</span>...])
        )

        <span class="s-call">assertEqual</span>(manager.<span class="s-call">notesOnPage</span>(<span class="s-number">2</span>), [])
    }
}</code></pre><p>What’s really cool is that not only can the above function be used to verify the contents of ordered data structures like <code>Array</code>, but because we used the <code>BidirectionalCollection</code> protocol as its constraint, it can also be used with other collections as well — such as ranges, index sets, and strings.</p><p>However, when it comes to strings in particular, we’ll end up with a character-by-character comparison, which might be <em>a bit too granular</em> — so we might want to split each string that we’re verifying up a bit, for example into words, so that it’ll be easier to identify what the actual differences were:</p><pre class="splash"><code><span class="s-keyword">let</span> string = ...
<span class="s-keyword">let</span> expectedString = ...

<span class="s-call">assertEqual</span>(
    string.<span class="s-call">split</span>(separator: <span class="s-string">" "</span>),
    expectedString.<span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
)</code></pre><p>The above is yet another another example of the power of writing <a href="https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions">reusable extensions</a> that are not bound to a concrete type, but rather to a standard library protocol — as it lets us get much more milage out of each utility that we write.</p><h2>Conclusion</h2><p>Picking the right set of assertion functions for each test that we write can have a big impact on both the clarity and semantics of our testing code, and also on the kind of information that we’ll get access to if a test starts failing.</p><p>While the standard suite of assertions that the <code>XCTest</code> framework ships with are most likely going to be enough to cover the needs of most code bases, also being able to create our own assertion functions when needed is incredibly powerful — and can help us build up our own <em>“library”</em> of testing utilities, that in turn can make it easier and easier to write new tests.</p><p>What do you think? How do you tend to perform the assertions within your unit tests, and have you ever written a custom assertion function? Let me know — along with your questions, comments and feedback — either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/access-control</guid><title>Basics: Access Control</title><description>An overview of Swift’s five different levels of access control, how they work, and when each of them might be useful in practice.</description><link>https://www.swiftbysundell.com/basics/access-control</link><pubDate>Sat, 11 Jan 2020 16:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The concept of <em>access control</em> enables us to restrict how types, functions and other declarations can be accessed by other code. Swift offers five different levels of access control, and making full use of them can be crucial in order to write programs that have clearly separated concerns and a robust structure.</p><p>When we define any new type, property, or function in Swift, it’ll have the <code>internal</code> access level by default. That means that it’ll be visible to all other code that lives within the same <em>module</em> — such as an app, a system extension, a framework, or a Swift package.</p><p>As an example, let’s say that we’re building a shopping app, and that we’ve defined a class called <code>PriceCalculator</code> that lets us calculate the total price for an array of products:</p><pre class="splash"><code><span class="s-keyword">class</span> PriceCalculator {
    <span class="s-keyword">func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-comment">// The reduce function enables us to reduce a collection,
        // in this case an array of products, into a single value:</span>
        products.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { totalPrice, product <span class="s-keyword">in</span>
            totalPrice += product.<span class="s-property">price</span>
        }
    }
}</code></pre><p>As we’re currently not specifying any explicit access level, our <code>PriceCalculator</code> class (and its <code>calculatePrice</code> method) will be accessible from anywhere within our app. However, if we’re looking to share our new class with other modules (we might, for instance, implement it within a framework that we share between our main app and an extension, or a companion Apple Watch app), then we’ll need to make it <code>public</code> in order for it to be visible within those external contexts:</p><pre class="splash"><code><span class="s-keyword">public class</span> PriceCalculator {
    <span class="s-keyword">public func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        products.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { totalPrice, product <span class="s-keyword">in</span>
            totalPrice += product.<span class="s-property">price</span>
        }
    }
}</code></pre><p>However, the above change is not quite enough. While we’re now able to find our class outside of the module that it’s defined in, we can’t create any instances of it — since its (implicit) initializer is, just like any other code, <code>internal</code> by default. To fix that, let’s define a <code>public</code> initializer, which we’ll leave empty since there’s no actual work to be done within it:</p><pre class="splash"><code><span class="s-keyword">public class</span> PriceCalculator {
    <span class="s-keyword">public init</span>() {}
    ...
}</code></pre><p>We’re now able to find, initialize, and call our <code>PriceCalculator</code> both inside and outside of its module — fantastic. But let’s now say that we’re also looking to <em>subclass it</em> in order to modify it, or to add new functionality to it. While that’s currently possible within its own module, it’s again something that’s prevented outside of it.</p><p>To change that, we’ll have to use Swift’s currently most open level of access control, which is appropriately named <code>open</code>:</p><pre class="splash"><code><span class="s-keyword">open class</span> PriceCalculator {
    ...
}</code></pre><p>With the above change in place, we can now create custom subclasses of <code>PriceCalculator</code> anywhere — which can have new initializers, new properties, and new methods. Here’s how we might use that to implement a <code>DiscountedPriceCalculator</code>, which lets us apply a given <code>discount</code> to all price calculations:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">let</span> discount: <span class="s-type">Int</span>

    <span class="s-keyword">init</span>(discount: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">discount</span> = discount
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>()
    }

    <span class="s-keyword">func</span> calculateDiscountedPrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">let</span> price = <span class="s-call">calculatePrice</span>(for: products)
        <span class="s-keyword">return</span> price - discount
    }
}</code></pre><p>Above we’re defining a brand new price calculation method, but it would arguably be much more appropriate to override and modify the existing <code>calculatePrice</code> method that we inherited from our base class instead. That way, there would be no confusion around which method to call, and we could keep our two classes consistent.</p><p>To be able to do that, we again have to mark the original declaration — this time our <code>calculatePrice</code> method declaration — as <code>open</code>:</p><pre class="splash"><code><span class="s-keyword">open class</span> PriceCalculator {
    <span class="s-keyword">public init</span>() {}

    <span class="s-keyword">open func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        ...
    }
}</code></pre><p>With the above in place, we can now freely override <code>calculatePrice</code>, rather than having to create a separate method:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">let</span> discount: <span class="s-type">Int</span>

    <span class="s-keyword">init</span>(discount: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">discount</span> = discount
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>()
    }

    <span class="s-keyword">override func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">let</span> price = <span class="s-keyword">super</span>.<span class="s-call">calculatePrice</span>(for: products)
        <span class="s-keyword">return</span> price - discount
    }
}</code></pre><p>So that’s <code>internal</code>, <code>public</code> and <code>open</code> — which are used to gradually <em>open a declaration up</em> for public use and modification. But we can of course also go the other way, and hide parts of our code from being discovered and used. At first, it may seem questionable what the value is in doing that, but it can really help us make our API much more narrow and focused — which in turn can make it easier to understand, test, and use.</p><p>So let’s now go all the way to the other side of the access level spectrum, and take a look at the most restrictive level — <code>private</code>. Any type, property or method that’s marked as <code>private</code> will only be visible <em>within its own type</em> (which also includes extensions on that type defined within the same file).</p><p>Anything that should be considered a <em>private implementation detail</em> of a given type should arguably be marked as <code>private</code>. For example, our price calculator’s <code>discount</code> property from before was really only meant to be used within its own class — so let’s go ahead and make that property private:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">private let</span> discount: <span class="s-type">Int</span>
    ...
}</code></pre><p>Our previous implementation will continue to work exactly the same way as before, since <code>discount</code> will remain entirely visible within our <code>DiscountedPriceCalculator</code> class. However, if we wanted to slightly extend that visibility to also include <em>other types</em> defined within the same file, we’d have to use <code>fileprivate</code> — which does exactly what it sounds like, it keeps a declaration private <em>within the file that it’s defined in</em>:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">fileprivate let</span> discount: <span class="s-type">Int</span>
    ...
}</code></pre><p>With the above change in place, we can now access our <code>discount</code> property from related code defined in the same file — such as this extension on <code>UIAlertController</code> which lets us easily show a price description for an array of products within an alert:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIAlertController</span> {
    <span class="s-keyword">func</span> showPriceDescription(
        for products: [<span class="s-type">Product</span>],
        calculator: <span class="s-type">DiscountedPriceCalculator</span>
    ) {
        <span class="s-keyword">let</span> price = calculator.<span class="s-call">calculatePrice</span>(for: products)

        <span class="s-comment">// We can now access 'discount' even outside of the type
        // that it's declared in, thanks to 'fileprivate':</span>
        message = <span class="s-string">"""
        Your</span> \(products.<span class="s-property">count</span>) <span class="s-string">product(s) will cost</span> \(price)<span class="s-string">.
        Including a discount of</span> \(calculator.<span class="s-property">discount</span>)<span class="s-string">.
        """</span>
    }
}</code></pre><p class="info">When it comes to free functions, types and extensions, <code>private</code> and <code>fileprivate</code> act exactly the same. They’re only different when applied to declarations that are defined <strong>within a type</strong>.</p><p>So, to sum up, these are the five levels of access control that Swift currently offers:</p><ul><li><code>private</code> keeps a property or function private within its enclosing type, including any extensions on that type that are defined within the same file. When applied to a top-level type, function or extension, it acts the same way as <code>fileprivate</code>.</li><li><code>fileprivate</code> makes a declaration visible within the entire file that it’s defined in, while hiding it from all other code.</li><li><code>internal</code> is the default access level, and makes a declaration visible within the whole module that it’s defined in.</li><li><code>public</code> reveals a function, type, extension or property outside of its module.</li><li><code>open</code> enables a class to be subclassed, and a function or property to be overridden, outside of its module.</li></ul><p>In general, it’s often best to start out with the most restrictive level of access that a given declaration can practically have, and then open things up later if needed. That way we’re limiting the avenues for interaction between our various types and functions, which may at first seem like a bad thing, but is often truly essential in order to build maintainable and well-structured systems.</p><p>Thanks for reading! 🚀</p><p><em>(Note that this article didn’t go into mutation-specific access modifiers, such as <code>private(set)</code>. Those will be covered by another Basics article in the future.)</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-self-to-refer-to-enclosing-types</guid><title>Tip: Using Self to refer to enclosing types</title><description></description><link>https://www.swiftbysundell.com/tips/using-self-to-refer-to-enclosing-types</link><pubDate>Wed, 8 Jan 2020 20:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Swift includes a number of features that can help us make our code more concise and easier to read, such as its type inference capabilities, <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type aliases</a>, and the way that types can be referred to within their own declarations and extensions.</p><p>For example, let’s say that we wanted to extend a generic type, such as the <code>PublishingStep&lt;Site&gt;</code> type from <a href="https://github.com/JohnSundell/publish">Publish</a>, with a new <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory method</a>. When declaring our method, we <em>could</em> of course type out <code>PublishingStep&lt;Site&gt;</code> every time that we want to refer to the extended type itself, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(
        <span class="s-keyword">_</span> steps: [<span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt;]
    ) -&gt; <span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt; {
        <span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt;(...)
    }
}</code></pre><p>However, that’s quite verbose, and not in the way that makes our code easier to read or understand — quite the opposite. Thankfully, when extending a generic type, we don’t have to type out its complete signature, all we need is the name of the type itself — and the compiler will infer the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(
        <span class="s-keyword">_</span> steps: [<span class="s-type">PublishingStep</span>]
    ) -&gt; <span class="s-type">PublishingStep</span> {
       <span class="s-type">PublishingStep</span>(...)
    }
}</code></pre><p>That’s definitely better, and functionally the same as our initial implementation — but as of Swift 5.1, we can go one step further. Thanks to the improvements made to the <code>Self</code> alias, we can now use that to refer to any method or property’s enclosing type in a really compact manner, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(<span class="s-keyword">_</span> steps: [<span class="s-type">Self</span>]) -&gt; <span class="s-type">Self</span> {
       <span class="s-type">Self</span>(...)
    }
}</code></pre><p class="info">Note how <code>Self</code> can even be used when creating a new instance of our type.</p><p>While compact code isn’t always better code, in this case, using <code>Self</code> has definitely made our code easier to read — without sacrificing any of its functionality or meaning. It’s a great tool to keep in mind when working with types that have longer names, or complex generic types.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions</guid><title>Writing reusable Swift extensions</title><description>A look at what goes into writing type- and protocol extensions that can be reused between different use cases and projects, and what sort of principles that can be good to keep in mind when doing that.</description><link>https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions</link><pubDate>Sun, 5 Jan 2020 20:50:00 +0100</pubDate><content:encoded><![CDATA[<p>Arguably one of Swift’s most interesting and powerful features is how it lets us extend any type or protocol with new functionality. Not only does that let us tweak the language and its standard library to fit each projects’ needs, it also opens up many different opportunities for writing extensions that could be reused across multiple use cases and projects.</p><p>This week, let’s take a look at a few examples of doing just that, as well as a set of principles that can be good to keep in mind when generalizing an extension to be usable in a much wider context.</p><h2>Generalizing through abstractions</h2><p>When writing code on a day-to-day basis, it’s very common for each new feature and piece of functionality to start its life as a very domain-specific implementation. There’s nothing wrong with that, in fact, it helps us avoid <em>“premature generalization”</em> and often lets us iterate much faster by initially focusing on just a single use case.</p><p>For example, let’s say that we’re working on a text editor for writing articles — and that in order to improve our app’s performance in certain scenarios, we’ve written the following function to enable us to easily cache a given article to disk:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">func</span> cacheOnDisk() <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> folderURLs = <span class="s-type">FileManager</span>.<span class="s-property">default</span>.<span class="s-call">urls</span>(
            for: .<span class="s-dotAccess">cachesDirectory</span>,
            in: .<span class="s-dotAccess">userDomainMask</span>
        )

        <span class="s-keyword">let</span> fileName = <span class="s-string">"Article-</span>\(id)<span class="s-string">.cache"</span>
        <span class="s-keyword">let</span> fileURL = folderURLs[<span class="s-number">0</span>].<span class="s-call">appendingPathComponent</span>(fileName)
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">JSONEncoder</span>().<span class="s-call">encode</span>(<span class="s-keyword">self</span>)
        <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: fileURL)
    }
}</code></pre><p class="info">The above caching implementation is just an example, for a much more thorough look at building various forms of caching systems in Swift, check out <a href="https://www.swiftbysundell.com/articles/caching-in-swift">“Caching in Swift”</a>.</p><p>Extending specific types with the above kind of utilities can be a great way to both reduce code duplication, and to make it easier to perform common tasks across a code base. However, a concrete type extension can also sometimes be a bit of a missed opportunity to make our code less decoupled and more flexible. In this particular case, chances are very high that we’ll not only want to cache <code>Article</code> instances, but also other kinds of models as well — which our current implementation won’t let us do.</p><p>When looking to generalize a specific extension, it may first seem like the work that’s being done is indeed strongly tied to the concrete type that’s being extended. For example, our above caching function uses our <code>Article</code> type’s name, and its <code>id</code> property, to form each <code>fileName</code>. However, conceptually, there’s really nothing about those two pieces of data that’s specific to articles — every type has a name, and any type can have an <code>id</code> property, so we should be able to make that extension reusable.</p><p>Let’s start by reviewing what our caching function’s requirements <em>actually are</em>:</p><ul><li>In order to be able to encode each value into a JSON representation, we need any type that’s going to be used with our function to conform to the standard library’s <code>Encodable</code> protocol.</li><li>We also need each compatible type to have an <code>id</code> property, to be able to compute a unique <code>fileName</code> for each value that’s being cached.</li></ul><p>To model those two requirements in a way that’s not directly tied to any concrete type, we’ll use <code>Encodable</code> as the new base target for our extension, and we’ll then add a <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraint</a> to specify that our caching method may only be called on types that also conform to <code>Identifiable</code> — another standard library protocol, which gives us the <code>id</code> property that we need:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Encodable</span> <span class="s-keyword">where</span> <span class="s-type">Self</span>: <span class="s-type">Identifiable</span> {
    <span class="s-comment">// We also take this opportunity to parameterize our JSON
    // encoder, to enable the users of our new API to pass in
    // a custom encoder, and to make our method's dependencies
    // more clear:</span>
    <span class="s-keyword">func</span> cacheOnDisk(using encoder: <span class="s-type">JSONEncoder</span> = .<span class="s-keyword">init</span>()) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> folderURLs = <span class="s-type">FileManager</span>.<span class="s-property">default</span>.<span class="s-call">urls</span>(
            for: .<span class="s-dotAccess">cachesDirectory</span>,
            in: .<span class="s-dotAccess">userDomainMask</span>
        )

        <span class="s-comment">// Rather than hard-coding a specific type's name here,
        // we instead dynamically resolve a description of the
        // type that our method is currently being called on:</span>
        <span class="s-keyword">let</span> typeName = <span class="s-type">String</span>(describing: <span class="s-type">Self</span>.<span class="s-keyword">self</span>)
        <span class="s-keyword">let</span> fileName = <span class="s-string">"</span>\(typeName)<span class="s-string">-</span>\(id)<span class="s-string">.cache"</span>
        <span class="s-keyword">let</span> fileURL = folderURLs[<span class="s-number">0</span>].<span class="s-call">appendingPathComponent</span>(fileName)
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> encoder.<span class="s-call">encode</span>(<span class="s-keyword">self</span>)
        <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: fileURL)
    }
}</code></pre><p>Just like that, we’ve converted our caching method from a very <code>Article</code>-specific implantation into a completely reusable one — and since our new extension only depends on protocols and abstractions defined by Swift’s standard library, we could also now share it between code bases that need the same sort of functionality.</p><h2>Finding the right protocol</h2><p>Let’s take a look at another example, in which we’ve again written an <code>Article</code>-specific extension, this time on the standard library’s <a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift"><code>Result</code> type</a> — to enable a result instance carrying an array of <code>Article</code> values to be easily combined with another instance of the same type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Result</span> <span class="s-keyword">where</span> <span class="s-type">Success</span> == [<span class="s-type">Article</span>] {
    <span class="s-keyword">func</span> combine(with other: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">try</span> .<span class="s-call">success</span>(<span class="s-call">get</span>() + other.<span class="s-call">get</span>())
    }
}</code></pre><p>Just like our caching method from before, there’s really nothing about the above <code>combine</code> method that requires it to know about <code>Article</code> as a concrete type. In this case, all we need is to be able to combine two underlying collections of values into one — which is something that can be done with any type that conforms to <code>RangeReplaceableCollection</code>.</p><p>So let’s again replace our concrete type requirement with a much more generic constraint, and this time we don’t even need to change our actual implementation at all:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Result</span> <span class="s-keyword">where</span> <span class="s-type">Success</span>: <span class="s-type">RangeReplaceableCollection</span> {
    <span class="s-keyword">func</span> combine(with other: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">try</span> .<span class="s-call">success</span>(<span class="s-call">get</span>() + other.<span class="s-call">get</span>())
    }
}</code></pre><p>What both of the above two examples demonstrate is that it’s often possible to generalize a utility extension into something that’s much more general-purpose — by picking one of the standard library’s many built-in abstractions as our extension’s target, rather than using one of our own, concrete types. By doing so, we not only make it possible to reuse our functionality among our own types, but we could potentially also share it between projects — and even <a href="https://www.swiftbysundell.com/articles/open-sourcing-swift-code">open source it</a>.</p><h2>Avoiding conflicts and type pollution</h2><p>So far, the extensions that we’ve defined have all contained the actual functionality that we wanted to add, but that’s not always the case. For example, sometimes the entire purpose of an extension is to retrofit an existing type with a protocol conformance, or to make it compatible with a custom system or API.</p><p>Let’s take a look at such a scenario, in which we’re building a general-purpose storage framework that’ll enable various projects to save and load different values using a <code>Container</code> type. To be able to write a given piece of data into one of those containers, we’ve defined a <code>DataConvertible</code> protocol that we’ve then made several system types conform to — like this:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> DataConvertible {
    <span class="s-keyword">var</span> data: <span class="s-type">Data</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-keyword">self</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-type">Data</span>(utf8) }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-call">pngData</span>()! }
}

<span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> value: <span class="s-type">DataConvertible</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = value.<span class="s-property">data</span>
        ...
    }
}</code></pre><p>The above approach might work reasonably well within a single code base, but if our intention is for this functionality to be shared among multiple projects, it’ll most likely end up becoming quite problematic.</p><p>Since we’ve defined our property requirement simply as <code>data</code>, chances are high that it’ll end up colliding with other property definitions that have the same name. That’s also true for our protocol itself, which has the very generic name <code>DataConvertible</code> — which could become ambiguous in a larger context. While type names can always be disambiguated using <code>ModuleName.TypeName</code>, property names cannot.</p><p>One potential solution to this problem would be to remove our protocol (and its associated extensions) altogether, and instead add a number of type-specific overloads to our <code>Container</code> type, like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> data: <span class="s-type">Data</span>) <span class="s-keyword">throws</span> {
        ...
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">try</span> <span class="s-call">write</span>(<span class="s-type">Data</span>(string.<span class="s-property">utf8</span>))
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">guard let</span> data = image.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data)
    }
}</code></pre><p>While the above approach works great as long as the number of types that we’re supporting remains fairly low, things can start to get tricky in case we ever want to add more configuration options and parameters to our container API.</p><p>For example, let’s say that we wanted to enable our API users to specify what level of persistence to use when writing a given value, or to associate a set of tags with it. Just those two minor additions would already make our implementation a lot more complicated, and cause a fair amount of code duplication — as we’d need to add both of those parameters (and their default values) to every single overload:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> data: <span class="s-type">Data</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        ...
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> string: <span class="s-type">String</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-type">Data</span>(string.<span class="s-property">utf8</span>)

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data,
            persistence: persistence,
            tags: tags
        )
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        <span class="s-keyword">guard let</span> data = image.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data,
            persistence: persistence,
            tags: tags
        )
    }
}</code></pre><p>As it turns out that internalizing all possible argument combinations within our <code>Container</code> type isn’t necessarily great either — let’s go back and explore the protocol-oriented route a bit further.</p><p>Since our main problem before was that our protocol and its requirement were named in a way that could potentially cause conflicts — let’s instead use a slightly more verbose naming convention, which explicitly includes the word <em>“Container”</em>. Let’s also make our protocol requirement a throwing function, which lets us avoid any force unwrapping when converting a <code>UIImage</code> into <code>Data</code>:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> ContainerDataConvertible {
    <span class="s-keyword">func</span> asContainerData() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">self</span>
    }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() -&gt; <span class="s-type">Data</span> {
        <span class="s-type">Data</span>(utf8)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">guard let</span> data = <span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Container</span>.<span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">return</span> data
    }
}</code></pre><p class="info">Note that not just because a protocol function is marked as <code>throws</code> doesn’t mean that all <a href="https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing/">implementations of it need to throw</a>.</p><p>With the above change in place, chances are now much lower that our extension will end up causing problems when mixed with other code bases, and we’re back to <code>Container</code> having just a single <code>write</code> method that can handle any <code>ContainerDataConvertible</code>-conforming type:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(
        <span class="s-keyword">_</span> value: <span class="s-type">ContainerDataConvertible</span>,
        persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
        tags: [<span class="s-type">Tag</span>] = []
    ) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> value.<span class="s-call">asContainerData</span>()
        ...
    }
}</code></pre><p>That’s already much better, but perhaps we could go one step further in terms of making our system extensions as unobtrusive as possible. Up until now, we’ve been adding instance properties and methods to the types that are being retrofitted, which makes those additions quite visible and likely to show up as autocompletion results (even though they’re more or less intended to be implementation details of <code>Container</code>).</p><p>To address that, let’s instead define our protocol requirement as a <em>static</em> function — and implement it on the actual types themselves, rather than adding it to all instances of them:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> ContainerDataConvertible {
    <span class="s-keyword">static func</span> makeContainerData(for value: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">Data</span>) -&gt; <span class="s-type">Data</span> {
        value
    }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">String</span>) -&gt; <span class="s-type">Data</span> {
        <span class="s-type">Data</span>(value.<span class="s-property">utf8</span>)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">UIImage</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">guard let</span> data = value.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Container</span>.<span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">return</span> data
    }
}</code></pre><p>The above implementation still lets us maintain just a single <code>write</code> function, all without having to add any additional complexity to the instances of our compatible types — since we’ll now simply call <code>makeContainerData</code> directly on each value’s type, like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write&lt;T: <span class="s-type">ContainerDataConvertible</span>&gt;(
        <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
        persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
        tags: [<span class="s-type">Tag</span>] = []
    ) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">T</span>.<span class="s-call">makeContainerData</span>(for: value)
        ...
    }
}</code></pre><p>Especially when it comes to making a number of system types compatible with a custom API or framework, adding the required complexity in a static context can be a great way to better encapsulate all of those implementation details, and can let us avoid <em>“polluting”</em> the instances of those types.</p><h2>Conclusion</h2><p>A big part of enabling a given extension to be reused often comes down to picking the right level of abstraction for it, and the more we can rely on the standard library to act as a common denominator for all compatible types, the more portable our extensions are likely to become.</p><p>However, sometimes we do need to introduce our own custom protocols when sharing extensions between projects, and there’s nothing wrong with that — as long as we make sure that we’re doing everything that we can to avoid adding additional cruft or potential sources of conflict to any system types that we’re making conform to those protocols.</p><p>What do you think? How do you currently use extensions in your projects, and do you tend to share any of your extensions between projects? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/the-decade-of-swift</guid><title>The Decade of Swift</title><description>For the 150th weekly article on this site, and the last one before the end of the decade, let’s look back at how Swift has fundamentally changed the way apps for Apple’s platforms are built, and where things might be going from here.</description><link>https://www.swiftbysundell.com/articles/the-decade-of-swift</link><pubDate>Sun, 29 Dec 2019 21:40:00 +0100</pubDate><content:encoded><![CDATA[<p>Even before it started, WWDC 2014 was a very special event for me, personally. Not only was it the first (and at the time of writing, the only) time that I was lucky enough to be able to attend the conference in person, it was also my very first encounter with the wider Apple developer community — which had a profound impact on me in terms of how I’d come to view my work, and myself as a member of that community.</p><p>But this is not a story about me. Instead, it’s the story of how approximately one hour and forty-five minutes into the WWDC 2014 keynote, the world of iOS and Mac development fundamentally changed — when Craig Federighi announced that <em>”We have a new programming language”</em>. This is weekly article number 150 — looking back at what, for me and many others, has been <em>The Decade of Swift</em>.</p><h2>Type safety and expressiveness</h2><p>If you open up your macOS terminal app of choice and type <code>man swift</code> to bring up the manual entry for the Swift compiler, it’s described as a <em>“safe, fast, and expressive general-purpose programming language”</em>.</p><p>While the idea of type safety and utilizing the compiler to more strictly verify the code that it’s processing isn’t something that’s unique to Swift, the combination of a very robust type system and a highly expressive syntax is one of the key aspects that instantly made Swift feel so refreshing to me and many others.</p><p>A core part of building any kind of software — whether it’s an app, a framework, or a compiler for a programming language — is constantly trying to find the right balance between various trade-offs. The question we have to keep asking ourselves again and again is: what potential downsides or obstacles are we willing to accept in order to achieve our goals, and how can we best utilize the strengths of our chosen approach?</p><p>What’s interesting about Swift’s strict, static type system is that it’s arguably both a trade-off and an asset at the same time. A strength in that it encourages us to write code that’s less prone to runtime errors, but also a potential weakness in that it requires us to spend more time designing our code up-front, which — at least initially — can have a negative impact on productivity and speed of iteration.</p><p>That’s why Swift’s expressive and very lightweight syntax (especially when compared to its predecessor, Objective-C), played such an important role since the very beginning, and why it’s increasingly becoming a very defining factor of the language as a whole. Take <a href="https://www.swiftbysundell.com/basics/enums">enums</a> for example. Not only do they let us model and handle finite sets of values using dedicated, strongly verified types — they also make the available values much more discoverable, and enable us to write highly expressive <em>dot syntax</em>-based call sites:</p><pre class="splash"><code><span class="s-keyword">let</span> favorites = <span class="s-call">articles</span>(in: .<span class="s-dotAccess">favorites</span>)</code></pre><p>From the very first 1.0 release, to the great standard library API redesign of Swift 3, to the introduction of <a href="https://www.swiftbysundell.com/basics/codable/"><code>Codable</code></a> and <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> in Swift 4, to how conformances to protocols like <code>Equatable</code> and <code>Hashable</code> can now be auto-synthesized as of Swift 4.1, to Swift 5.1’s <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">new DSL-focused features</a> — every new release of Swift, so far, has improved and tweaked the language to enable new kinds of expressions and patterns to be constructed.</p><h2>New patterns and conventions</h2><p>That constant flow of new features and patterns has also resulted in a ton of new ideas, both from Apple and third party developers. While the rapid speed of iteration that we’ve seen over Swift’s first five and a half years might’ve occasionally been problematic — especially in the early days, when several APIs and language features were drastically changed from one version to the next — it’s also been a great source of inspiration and excitement for the community as a whole.</p><p>In many ways, a new programming language means a new beginning, and an opportunity for current patterns and conventions to be rethought and changed to leverage the new language’s features and strengths. While Swift was initially strongly based on Objective-C’s existing conventions, it didn’t take long for new best practices to start to form, and for the community to start developing a sense of what makes code <em>“swifty”</em>.</p><p>A big part of that is the increased use of Swift’s powerful type system to drive logic and to validate values. While Objective-C code tends to rely heavily on runtime validation using more free-form values, Swift-native patterns often focus on stronger types and relationships that can be enforced by the compiler. For example, let’s say that we wanted to write a function for sorting an array based on an element property — in the early days of Swift, we might’ve written something like this:</p><pre class="splash"><code><span class="s-comment">// We extend NSArray, rather than Swift's native Array type, to
// be able to leverage dynamic Objective-C features like Selectors:</span>
<span class="s-keyword">extension</span> <span class="s-type">NSArray</span> {
    <span class="s-comment">// Since we're calling an Objective-C API under the hood, we
    // can't retain type safety, and are forced to return [Any]:</span>
    <span class="s-keyword">func</span> sortedArrayBasedOn(key: <span class="s-type">String</span>) -&gt; [<span class="s-type">Any</span>] {
        <span class="s-keyword">return</span> <span class="s-call">sortedArray</span>(using: <span class="s-type">Selector</span>(key))
    }
}</code></pre><p>While being able to call into existing Objective-C APIs from Swift, and vice versa, was (and in many code bases, still is) incredibly important — it quickly became quite clear that Swift needed its own set of conventions and API design styles, which resulted in the <a href="https://swift.org/documentation/api-design-guidelines">official API design guidelines</a>.</p><p>Using some of those modern Swift conventions and guidelines, here’s how we might refactor the above implementation — to use Swift’s native <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths feature</a> rather than relying on dynamic strings, and to retain full type safety thanks to Swift’s powerful <a href="https://www.swiftbysundell.com/basics/generics">generics capabilities</a>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> {
    <span class="s-keyword">func</span> sorted&lt;T: <span class="s-type">Comparable</span>&gt;(
        by keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">T</span>&gt;
    ) -&gt; <span class="s-type">Self</span> {
        <span class="s-call">sorted</span> { $0[keyPath: keyPath] &lt; $1[keyPath: keyPath] }
    }
}</code></pre><p>Using the above, we can now sort any array in a way that’s both fully type-safe, and highly expressive:</p><pre class="splash"><code><span class="s-keyword">let</span> mostPopular = articles.<span class="s-call">sorted</span>(by: \.<span class="s-property">numberOfViews</span>)</code></pre><p>Changes like the one above may initially seem minor in the grand scheme of things, but step by step there’s no doubt that Swift has fundamentally changed how most Apple-platform apps are built — in that it has required us to rethink and restructure the way we write code, especially if we previously relied heavily on the very dynamic nature of Objective-C.</p><p>That trend is likely to grow even stronger, especially as Apple has now started to roll out Swift-only frameworks that uses the above type of modern conventions, such as Combine and SwiftUI — both of which favor more minimalistic API designs and make heavy use of Swift’s type system, to the point where SwiftUI uses the type system itself to determine when to re-render a given view.</p><h2>A major cultural shift</h2><p>However, perhaps the biggest impact that Swift has had on the Apple developer community isn’t so much a technical one — but rather a cultural one. While there was definitely a strong community surrounding Apple’s developer tools long before Swift, there’s no denying that the introduction of Swift drastically transformed and shifted that community’s focus.</p><p>Think about it, how often were the iOS and Mac developer communities referred to as <em>“The Objective-C community”</em>? Before Swift it seemed like the programming language being used was more of an implementation detail — while frameworks like Cocoa, and the platforms themselves, were what defined the community and what brought people together. Compare that to now, at the end of 2019, when that same community has in many ways and circles been practically renamed to <em>“The Swift community”</em>.</p><p>However, what’s perhaps even more interesting than how the third party developer community has changed, is how Apple has changed their approach to how their Swift-based developer tools are built and evolved. After all, there was never an <em>“Objective-C Evolution”</em> process that let anyone pitch ideas and changes to the language and its standard library. There was never a dedicated Objective-C forum on which both first- and third party tools could be discussed with Apple engineers.</p><p>The way Swift is (for the most part) designed and developed in the open is a huge shift compared to the very isolated and secretive ways in which Apple typically works — and that shift has likely played a major part in making the community feel so attached to, and excited about, Swift as a language.</p><h2>What might the future have in store?</h2><p>Looking back at the 12 Swift updates that have been released since version 1.0, it’s quite clear that language-level ergonomics and user-facing features have been a major focus. The syntax has been streamlined and fine-tuned, the standard library has been made much more capable, generics are now a lot more powerful, and major sources of boilerplate have been eliminated. That in addition to achieving ABI and module stability, and much more.</p><p>However, going forward, I expect that focus to slightly change more towards the overall stability and speed of the Swift compiler itself. There’s no doubt that there’s a ton of potential improvements to be made within this area, which wouldn’t just make the process of writing and running Swift code much more enjoyable, but also continue to unlock new use cases for Swift — for example to build just-in-time compiled plugins, for scripting, and to expand how Swift can be used for server-side development.</p><p>While Swift will most likely always be slower to compile compared to languages that perform far fewer compile-time checks and inference, more stable and capable tooling would definitely be welcome — and we’ve already seen tools like the <a href="https://github.com/apple/swift-llbuild"><code>llbuild</code></a> build system drastically improve compile times and the overall developer experience. A trend which I hope, and think, will continue.</p><p>A new <a href="https://swift.org/blog/new-diagnostic-arch-overview">diagnostics engine</a> is already being developed for Swift 5.2, which aims to improve the type checker and the warnings and error messages that the Swift compiler generates when an expression failed to compile — which should be particularly useful when writing code that makes heavy use of generics, such as when building views using SwiftUI.</p><p>Besides improved tooling, I’m also really looking forward to the day when Swift includes some form of language-level support for asynchronous programming. While frameworks like <a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a> and Combine are incredibly powerful, being able to express asynchronous operations using native language features (such as <code>async/await</code>, or any of the other approaches outlined by Chris Lattner in his <a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782"><em>“Swift Concurrency Manifesto”</em></a>) would most likely result in much simpler and more expressive asynchronous code.</p><h2>Conclusion</h2><p>Starting with the iPad, iPhone 4, and Grand Central Dispatch in 2010, and ending with SwiftUI and Combine in 2019 — it’s been an incredibly exciting decade to be a developer for Apple’s platforms. Seeing so many new people joining our community from all around the world, and constantly seeing new ideas, patterns and conventions being shared through articles, videos, podcasts and conferences is absolutely wonderful.</p><p>There’s no doubt that both Swift and SwiftUI have been incredible energizers for the community at large, enabling new developers to write their very first app, for new patterns and tools to be invented, and for existing code bases to be improved. It may <em>just</em> be a programming language, but the way it has influenced our community, and fundamentally changed my work and my career, there’s no doubt in my mind that this has been <em>The Decade of Swift</em>.</p><p>I can’t wait to see what the next decade will bring, and how both Apple and the community will continue to improve, evolve and invent new tools that’ll help us build even better software — both for our existing devices and for brand new ones. I’ll of course continue to cover Swift and its related technologies on this site and on <a href="https://www.swiftbysundell.com/podcast">the podcast</a> for as long as I possibly can, hopefully all throughout the 2020s, and I hope that you’ll join me for that ride.</p><p>Thanks for reading, and Happy New Year! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/initializers-in-swift</guid><title>Initializers in Swift</title><description>Let’s take a look at one of the core aspects of object-oriented programming — initialization. What characteristics should an initializer ideally have, and what sort of techniques could be useful in order to keep our initializers simple and predictable?</description><link>https://www.swiftbysundell.com/articles/initializers-in-swift</link><pubDate>Sun, 22 Dec 2019 20:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Although Swift’s overall design incorporates several distinct programming paradigms, and makes it possible to write code using many different styles, it’s still substantially rooted in the object-oriented world.</p><p>From the way objects and values are constructed, to how inheritance and references still play a huge role in how Apple’s frameworks are designed, object-oriented concepts are a key part of Swift — even though they are often mixed with influences from other paradigms, such as functional programming.</p><p>This week, let’s take a look at one of the core aspects of object-oriented programming — initialization, which is the act of preparing an object or value for use. What characteristics should an initializer ideally have, and what sort of techniques and patterns could be useful in order to keep our initializers simple and predictable? Let’s dive right in.</p><h2>The simplicity of structs</h2><p>Arguably one of the most significant characteristics that we’re looking for in an initializer is <em>simplicity</em>. After all, the way an object or value is created often acts as our very first impression of its API — so making that process as simple and as easy to understand as possible is definitely important.</p><p>One way that Swift assists us in achieving that sort of simplicity is through the way structs work — specifically how their <em>memberwise initializers</em> enable us to easily create a new instance of a given type without requiring any custom logic.</p><p>For example, let’s say that our code base contains a <code>User</code> type that has the following properties — some of which are required, and some of which are optional:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">let</span> id = <span class="s-type">ID</span>()
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> address: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> cityName: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>?
}</code></pre><p>While Swift was always capable of auto-generating initializers matching a struct’s list of properties, as of Swift 5.1, those initializers no longer require us to pass values for the properties that are optional (or that have a default value) — enabling us to create a new <code>User</code> instance like this:</p><pre class="splash"><code><span class="s-keyword">let</span> user = <span class="s-type">User</span>(id: <span class="s-type">User</span>.<span class="s-type">ID</span>(), name: <span class="s-string">"John"</span>)</code></pre><p>Not only does that act as a great convenience, and helps keep our call sites clean and simple, it also serves another important function — it encourages us to keep our initializers free of logic and custom setup code.</p><p>By sticking with the initializers that the compiler generates for us, we’ll automatically keep those initializers simple and side-effect-free, as assigning the passed values to our type’s various properties is the only work that they’ll perform.</p><p class="info">Worth noting is that memberwise initializers are only available internally within the module that each given struct is defined in. While that may at first seem like an inconvenience (or an oversight, even), the benefit is that it “forces” us to consider what we want each type’s public API to be, and to not have that API implicitly change if we modify a given type’s set of properties — which would most likely be a breaking change for our API users.</p><h2>Ready from the start</h2><p>Since an initializer’s main job is to prepare its instance for use, the more complete and thorough we can make that setup process, the more robust our types are likely to become. Requiring additional data or dependencies to be assigned post-init often leads to misunderstandings and unintentional results, since it’s — in most cases — fair to assume that an instance is fully ready for use once it has been initialized.</p><p>Let’s say that we’re working on an app that includes some form of audio processing, and that we’ve built an <code>AudioProcessor</code> class to perform that work. Currently, that type uses the <a href="https://www.swiftbysundell.com/articles/delegation-in-swift">delegate pattern</a> to enable its owner to decide whether or not a given file should actually be processed — like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> AudioProcessingDelegate: <span class="s-type">AnyObject</span> {
    <span class="s-keyword">func</span> audioProcessor(<span class="s-keyword">_</span> processor: <span class="s-type">AudioProcessor</span>,
                        shouldProcessFile file: <span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>
}

<span class="s-keyword">class</span> AudioProcessor {
    <span class="s-keyword">weak var</span> delegate: <span class="s-type">AudioProcessingDelegate</span>?

    <span class="s-keyword">func</span> processAudioFiles(<span class="s-keyword">_</span> files: [<span class="s-type">File</span>]) <span class="s-keyword">throws</span> {
        <span class="s-keyword">for</span> file <span class="s-keyword">in</span> files {
            <span class="s-keyword">guard let</span> delegate = delegate <span class="s-keyword">else</span> {
                <span class="s-comment">// This code path should ideally never be entered</span>
                <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
                <span class="s-keyword">continue</span>
            }

            <span class="s-keyword">let</span> shouldProcess = delegate.<span class="s-call">audioProcessor</span>(<span class="s-keyword">self</span>,
                shouldProcessFile: file
            )

            <span class="s-keyword">if</span> shouldProcess {
                <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
            }
        }
    }
    
    ...
}</code></pre><p>While the delegate pattern is incredibly useful in many different circumstances, the way we’ve implemented it above does come with a quite significant downside. Since we can’t guarantee that a delegate has been assigned by the time the <code>processAudioFiles</code> method is called, we’re forced to include a code path that causes all files to be processed whenever a delegate is missing — which will most likely lead to unintended results, at least in some cases.</p><p>Thankfully, like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/delegation-in-swift">“Delegation in Swift”</a></em>, using a weakly-referenced protocol isn’t the <em>only</em> way to implement the delegate pattern. When we’re dealing with a situation in which our delegation logic is required in order to perform an object’s work, it ideally shouldn’t be assigned post-init — but rather be a part of the initializer itself. That way, we can be 100% sure that all of our required dependencies will be available right from the start.</p><p>One way to do just that in this case is to change our protocol-based approach from before into a closure-based one instead — which also results in a much more compact implementation:</p><pre class="splash"><code><span class="s-keyword">class</span> AudioProcessor {
    <span class="s-keyword">private let</span> predicate: (<span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">init</span>(predicate: <span class="s-keyword">@escaping</span> (<span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">predicate</span> = predicate
    }

    <span class="s-keyword">func</span> processAudioFiles(<span class="s-keyword">_</span> files: [<span class="s-type">File</span>]) <span class="s-keyword">throws</span> {
        <span class="s-keyword">for</span> file <span class="s-keyword">in</span> files <span class="s-keyword">where</span> predicate(file) {
            <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
        }
    }
    
    ...
}</code></pre><p class="info">A simple closure might be all that we need in the above situation, but if we wanted to take things one step further, we could’ve also opted for a more powerful predicate implementation — like the one from <a href="https://www.swiftbysundell.com/articles/predicates-in-swift">“Predicates in Swift”</a>.</p><p>Regardless of whether we choose a protocol, a closure, or some other form of abstraction, the goal remains the same — to be able to guarantee that our objects are as fully configured as possible by the time their initializer returns. The more we can avoid requiring any form of post-init setup, the easier to understand our types usually become.</p><h2>Avoiding complexity and side effects</h2><p>Another factor that often has a huge impact on our types’ ease of use is how predictable their underlying implementations are. If we can make the results of calling our APIs match user expectations — then we can avoid misunderstandings, and ultimately, bugs.</p><p>When it comes to initializers in particular, avoiding all sorts of side-effects is often key to maintaining a high degree of predictability. For example, the following <code>Request</code> type’s initializer doesn’t only set up its instance, it also starts the underlying <code>URLSessionDataTask</code> — which might be quite unexpected:</p><pre class="splash"><code><span class="s-keyword">class</span> Request&lt;Value: <span class="s-type">Codable</span>&gt; {
    <span class="s-keyword">private let</span> task: <span class="s-type">URLSessionDataTask</span>

    <span class="s-keyword">init</span>(url: <span class="s-type">URL</span>,
         session: <span class="s-type">URLSession</span> = .<span class="s-dotAccess">shared</span>,
         handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        task = session.<span class="s-call">dataTask</span>(with: url) {
            data, response, error <span class="s-keyword">in</span>
            ...
            <span class="s-call">handler</span>(result)
        }

        task.<span class="s-call">resume</span>()
    }

    ...
}</code></pre><p>Whenever we have to use the word <em>“and”</em> when explaining what one of our initializers does, chances are high that it causes some form of side-effect. For example, the above initializer might be described as <em>“Setting up <strong>and</strong> performing a given request”</em> — and while that may seem completely harmless at first, it’ll most likely make our initializer way too complex, and less flexible — as we give our API users no control over when and how each request is actually performed.</p><p>Instead, let’s make our initializer only set up a <code>Request</code> instance with its required property values, and then create a new, dedicated method for performing it — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Request&lt;Value: <span class="s-type">Codable</span>&gt; {
    <span class="s-keyword">private let</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">private let</span> session: <span class="s-type">URLSession</span>
    <span class="s-keyword">private var</span> task: <span class="s-type">URLSessionDataTask</span>?

    <span class="s-keyword">init</span>(url: <span class="s-type">URL</span>, session: <span class="s-type">URLSession</span> = .<span class="s-dotAccess">shared</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">url</span> = url
        <span class="s-keyword">self</span>.<span class="s-property">session</span> = session
    }

    <span class="s-keyword">func</span> perform(then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        task?.<span class="s-call">cancel</span>()

        <span class="s-keyword">let</span> task = session.<span class="s-call">dataTask</span>(with: url) {
            [<span class="s-keyword">weak self</span>] data, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            ...
            <span class="s-call">handler</span>(result)
            <span class="s-keyword">self</span>?.<span class="s-property">task</span> = <span class="s-keyword">nil</span>
        }

        <span class="s-keyword">self</span>.<span class="s-property">task</span> = task
        task.<span class="s-call">resume</span>()
    }

    ...
}</code></pre><p>The above change doesn’t only give each call site the power to freely decide when to perform the requests they create, we’ve also made it possible to reuse a single <code>Request</code> instance within each given context — since a new task is now created (and any previous one cancelled) each time that our <code>perform</code> method is called.</p><p>Another potential source of unpredictability is when a given type’s initializer performs some form of internal setup that varies in terms of complexity and execution time. For example, the following <code>TagIndex</code> type is initialized with an array of <code>Note</code> values, that it then iterates over in order to index them according to their assigned tags:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagIndex {
    <span class="s-keyword">private var</span> notes = [<span class="s-type">Tag</span> : [<span class="s-type">Note</span>]]()

    <span class="s-keyword">init</span>(notes: [<span class="s-type">Note</span>]) {
        <span class="s-keyword">for</span> note <span class="s-keyword">in</span> notes {
            <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> note.<span class="s-property">tags</span> {
                <span class="s-keyword">self</span>.<span class="s-property">notes</span>[tag, default: []].<span class="s-call">append</span>(note)
            }
        }
    }

    ...
}</code></pre><p>Again, the above approach might not seem problematic — but the fact that we’re hiding an <code>O(n)</code> iteration behind what looks like a constant-time initializer isn’t really a great design — since calling it with a large amount of notes within some form of critical path will most likely turn it into a bottleneck.</p><p>Just like how we before moved our <code>Request</code> type’s main work out from its initializer, let’s do the same thing here, and define a separate method dedicated to performing our indexing work:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagIndex {
    <span class="s-keyword">private var</span> notes = [<span class="s-type">Tag</span> : [<span class="s-type">Note</span>]]()

    <span class="s-keyword">mutating func</span> index(<span class="s-keyword">_</span> notes: [<span class="s-type">Note</span>]) {
        <span class="s-keyword">for</span> note <span class="s-keyword">in</span> notes {
            <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> note.<span class="s-property">tags</span> {
                <span class="s-keyword">self</span>.<span class="s-property">notes</span>[tag, default: []].<span class="s-call">append</span>(note)
            }
        }
    }
    
    ...
}</code></pre><p>It’s a subtle change, but it’s now crystal clear that calling the <code>index</code> method causes indexing to performed, rather than having that be an implicit side-effect of initializing our type.</p><p>However, just like how we before wanted to avoid requiring any post-init calls in order to make a type usable, it would be great if we could find a way to perform our indexing process in a way that’s both automatic, and predictable.</p><p>One way that we could do that is by using a <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory method</a>, which we can name in a way that makes it obvious that calling that method doesn’t only create a new <code>TagIndex</code> instance, but also indexes the notes that were passed into it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TagIndex</span> {
    <span class="s-keyword">static func</span> makeByIndexing(<span class="s-keyword">_</span> notes: [<span class="s-type">Note</span>]) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">var</span> instance = <span class="s-type">Self</span>()
        instance.<span class="s-call">index</span>(notes)
        <span class="s-keyword">return</span> instance
    }
}</code></pre><p>Using static factory methods can be a great way to let us keep our initializer implementations simple, while still making it as easy as possible to create and configure new instances of our types.</p><h2>Conclusion</h2><p>By keeping our initializers free of side-effects, and by making the process of configuring our types as simple and predictable as possible, we not only make our types easier to understand, but also give them a much greater degree of flexibility.</p><p>However, if we make our initializers too simple, that can sometimes result in quite ambiguous setups that require a fair amount of post-init configuration — which isn’t ideal. Like with so many other things, writing great initializers becomes a balancing act between simplicity and completeness — and by using techniques like closures and static factory methods, we can often get closer to achieving that perfect balance.</p><p>What do you think? How do you like your initializers to work, and what kind of principles do you tend to follow when configuring your objects and values? Let me know — along with any questions, comments and feedback that you might have — either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/maintaining-model-consistency-in-swift</guid><title>Maintaining model consistency in Swift</title><description>This week, let’s take a look at how we can improve the internal consistency within each of our core data models, and how doing so can let us establish a much stronger foundation for our codebase as a whole.</description><link>https://www.swiftbysundell.com/articles/maintaining-model-consistency-in-swift</link><pubDate>Sun, 15 Dec 2019 15:00:00 +0100</pubDate><content:encoded><![CDATA[<p>When designing the model layer of any app or system, establishing a <em>”single source of truth”</em> for each state and piece of data that we’re dealing with is often essential in order to make our logic behave predictably.</p><p>However, ensuring that each state is stored in just a single place can often be easier said than done — and it’s very common to end up with bugs and errors resulting from inconsistent model data, especially when such models are passed around and mutated in several different places.</p><p>While some of those errors are bound to happen outside of the models themselves, this week, let’s take a look at how we can improve the internal consistency within each of our models — and how doing so can let us establish a much stronger foundation for our codebase as a whole.</p><h2>Deriving dependent states</h2><p>The overall model layer of any given system can most often be described as a hierarchy, in which more high-level pieces of data depend on some form of underlying state. As a simple example, let’s say that we’re working on a contact management app, and that we have a <code>Contact</code> model which contains each person’s contact information — such as their name and email address:</p><pre class="splash"><code><span class="s-keyword">struct</span> Contact {
    <span class="s-keyword">let</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> lastName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> fullName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>
    ...
}</code></pre><p>At first glance, the above might look like any standard data model, but there is actually a substantial risk for it to become inconsistent. Since we have three separate properties for <code>firstName</code>, <code>lastName</code> and <code>fullName</code>, we’re going to always have to remember to update a contact’s <code>fullName</code> whenever we make any changes to either the <code>firstName</code> or <code>lastName</code> property — otherwise, we’ll end up ambiguous information.</p><p>Since <code>fullName</code> is, at the end of the day, a convenience — a higher-level state that makes building our UI simpler — let’s make it derivative. Rather than implementing it as a separate, stored property, let’s turn it into a computed one instead:</p><pre class="splash"><code><span class="s-keyword">struct</span> Contact {
    <span class="s-keyword">let</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> lastName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> fullName: <span class="s-type">String</span> { <span class="s-string">"</span>\(firstName) \(lastName)<span class="s-string">"</span> }
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>
    ...
}</code></pre><p>That way, we no longer have to worry about our model becoming inconsistent, since a contact’s <code>fullName</code> will now be re-computed each time that it’s accessed according to the current <code>firstName</code> and <code>lastName</code>.</p><p>However, always re-computing a dependent state each time that it gets accessed is not always practical — especially if that state depends on a potentially large collection of elements, or if the required computation involves a bit more than simply combining a few underlying values.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">“Utilizing value semantics in Swift”</a></em>, in those situations, maintaining a separate stored property might again be the best approach — but if we prevent that property from being externally mutated, and if we make it auto-update whenever its underlying state changes, then we can still ensure that its containing model remains consistent.</p><p>Here’s how we might use a <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">property observer</a> to do that for a <code>Leaderboard</code> model, which contains high score entries for the top players of a game, as well as the current average score among those players:</p><pre class="splash"><code><span class="s-keyword">struct</span> Leaderboard {
    <span class="s-keyword">typealias</span> Entry = (name: <span class="s-type">String</span>, score: <span class="s-type">Int</span>)

    <span class="s-keyword">var</span> entries: [<span class="s-type">Entry</span>] {
        <span class="s-comment">// Each time that our array of entries gets modified, we
        // re-compute the current average score:</span>
        <span class="s-keyword">didSet</span> { <span class="s-call">updateAverageScore</span>() }
    }
    
    <span class="s-comment">// By marking our property as 'private(set)', we prevent it
    // from being mutated outside of this type:</span>
    <span class="s-keyword">private(set) var</span> averageScore = <span class="s-number">0</span>

    <span class="s-keyword">init</span>(entries: [<span class="s-type">Entry</span>]) {
        <span class="s-keyword">self</span>.<span class="s-property">entries</span> = entries
        <span class="s-comment">// Property observers don't get triggered as part of
        // initializers, so we have to call our update method
        // manually here:</span>
        <span class="s-call">updateAverageScore</span>()
    }

    <span class="s-keyword">private mutating func</span> updateAverageScore() {
        <span class="s-keyword">guard</span> !entries.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
            averageScore = <span class="s-number">0</span>
            <span class="s-keyword">return</span>
        }

        <span class="s-keyword">let</span> totalScore = entries.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { score, entry <span class="s-keyword">in</span>
            score += entry.<span class="s-property">score</span>
        }

        averageScore = totalScore / entries.<span class="s-property">count</span>
    }
}</code></pre><p>The patterns used above don’t only improve the consistency of our models, they also make those models easier to use and understand — since we no longer have to be aware of rules like <em>“always remember to update X when you modify Y”</em> — as that sort of logic is now baked into the models themselves.</p><h2>Consistent collections</h2><p>While maintaining a 1:1 relationship between two pieces of state can be challenging enough, things get even trickier when we have to ensure that multiple collections remain consistent with each other. Going back to the example of a contact management app from before, let’s say that we’re now building a <code>ContactList</code> class — which will store a set of contacts, while also enabling those contacts to be organized into groups, and to be marked as favorites:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> contacts = [<span class="s-type">Contact</span>.<span class="s-type">ID</span> : <span class="s-type">Contact</span>]()
    <span class="s-keyword">var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">var</span> groups = [<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span> : <span class="s-type">Contact</span>.<span class="s-type">Group</span>]()

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
    }
}</code></pre><p class="info">Above we’re making use of <a href="https://www.swiftbysundell.com/articles/namespacing-swift-code-with-nested-types">nested types</a> in order to make types like <code>Group</code> and <code>Name</code> more contextual and <a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">“self-documenting”</a>.</p><p>Similar to the earlier example in which we were required to manually keep a contact’s names in sync, the above model also makes each of its call sites responsible for keeping it consistent. For example, when removing a contact, we also have to remember to remove its ID from our set of <code>favoriteIDs</code> — and when renaming a group, we always have to update its key within the <code>groups</code> dictionary as well.</p><p>Both of the two functions below fail to do that, and even though they might look perfectly valid, they’re both causing the <code>ContactList</code> they’re mutating to become inconsistent:</p><pre class="splash"><code><span class="s-keyword">func</span> removeContact(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
    <span class="s-comment">// If the removed contact was also added as a favorite, its
    // ID will still remain in that list, even after it was removed.</span>
    contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
}

<span class="s-keyword">func</span> renameGroup(named currentName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>,
                 to newName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>) {
    <span class="s-comment">// The renamed group's key will now be incorrect, since
    // it's still referring to the group's previous name.</span>
    contactList.<span class="s-property">groups</span>[currentName]?.name = newName
}</code></pre><p>An initial idea on how to avoid the above kind of inconsistencies might be to take the same <code>private(set)</code> approach that we used on our <code>Leaderboard</code> model from before, and prevent our collections from being mutated outside of the <code>ContactList</code> type:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private(set) var</span> contacts = [<span class="s-type">Contact</span>.<span class="s-type">ID</span> : <span class="s-type">Contact</span>]()
    <span class="s-keyword">private(set) var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">private(set) var</span> groups = [<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span> : <span class="s-type">Contact</span>.<span class="s-type">Group</span>]()
    ...
}</code></pre><p>However, in this case we actually need to be able to mutate our collections <em>somehow</em> — so the above approach would require us to replicate several of our underlying collections’ APIs, in order to make mutations like adding and removing contacts possible:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span> {
    <span class="s-keyword">func</span> add(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
        contacts[contact.<span class="s-property">id</span>] = contact
    }

    <span class="s-keyword">func</span> remove(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
        contacts[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
        favoriteIDs.<span class="s-call">remove</span>(contact.<span class="s-property">id</span>)
    }

    <span class="s-keyword">func</span> renameGroup(named currentName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>,
                     to newName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>) {
        <span class="s-keyword">guard var</span> group = groups.<span class="s-call">removeValue</span>(forKey: currentName) <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span>
        }

        group.<span class="s-property">name</span> = newName
        groups[newName] = group
    }
}</code></pre><p>The above might work as long as we only have to mutate our collections in very simple ways, and as long as we won’t add any new pieces of data to our model, but it’s not a very flexible solution overall. Requiring a brand new API to be created for each mutation is, in general, not a great design — so let’s see if we can find a more dynamic and future-proof approach.</p><p>If we think about it, keeping our <code>ContactList</code> data in sync really just requires us to be able to react to any changes to the property that’s also used as an element’s key (<code>id</code> in the case of <code>Contact</code> and <code>name</code> in the case of <code>Contact.Group</code>), and to be able to perform an update whenever an element was removed (so that we can make sure that no removed contacts still remain in the <code>favoriteIDs</code> set).</p><p>Let’s add both of those two capabilities by implementing a very lightweight wrapper around <code>Dictionary</code>. Our wrapper, let’s call it <code>Storage</code>, will use Swift’s <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths mechanism</a> in order to keep our keys in sync — and will also enable us to attach a <code>keyRemovalHandler</code> closure to get notified whenever a key was removed:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span> {
    <span class="s-keyword">struct</span> Storage&lt;Key: <span class="s-type">Hashable</span>, Value&gt; {
        <span class="s-keyword">fileprivate var</span> keyRemovalHandler: ((<span class="s-type">Key</span>) -&gt; <span class="s-type">Void</span>)?

        <span class="s-keyword">private let</span> keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Key</span>&gt;
        <span class="s-keyword">private var</span> values = [<span class="s-type">Key</span> : <span class="s-type">Value</span>]()

        <span class="s-keyword">fileprivate init</span>(keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Key</span>&gt;) {
            <span class="s-keyword">self</span>.<span class="s-property">keyPath</span> = keyPath
        }
    }
}</code></pre><p class="info">Our initializer and <code>keyRemovalHandler</code> are marked as <code>fileprivate</code> in order to prevent instances of our new <code>Storage</code> type to be created outside of the file that <code>ContactList</code> is defined in, further strengthening the consistency of our model code.</p><p>To make <code>Storage</code> behave like a <em>real</em> Swift collection, we have two options. We could either make it <a href="https://www.swiftbysundell.com/articles/creating-custom-collections-in-swift">conform to the full <code>Collection</code> protocol</a> or, if we only need to be able to iterate over it, we could simply make it conform to <code>Sequence</code> — by forwarding the call to <code>makeIterator()</code> to its underlying dictionary:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span>: <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> makeIterator() -&gt; <span class="s-type">Dictionary</span>&lt;<span class="s-type">Key</span>, <span class="s-type">Value</span>&gt;.<span class="s-type">Iterator</span> {
        values.<span class="s-call">makeIterator</span>()
    }
}</code></pre><p>With the above in place, we will still be able to write <code>for</code> loops over our collections, and to use APIs like <code>forEach</code>, <code>map</code> and <code>filter</code> on them — just like when using <code>Dictionary</code> directly.</p><p>Next, to enable <code>Storage</code> to be mutated, we’re going to add a <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift"><code>subscript</code> implementation</a> that both ensures that an element’s key gets updated in case the property its key is based on was changed, and that also calls our <code>keyRemovalHandler</code> when a key was removed:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span> {
    <span class="s-keyword">subscript</span>(key: <span class="s-type">Key</span>) -&gt; <span class="s-type">Value</span>? {
        <span class="s-keyword">get</span> { values[key] }
        <span class="s-keyword">set</span> {
            <span class="s-keyword">guard let</span> newValue = newValue <span class="s-keyword">else</span> {
                <span class="s-keyword">return</span> <span class="s-call">remove</span>(key)
            }

            <span class="s-keyword">let</span> newKey = newValue[keyPath: keyPath]
            values[newKey] = newValue

            <span class="s-keyword">if</span> key != newKey {
                <span class="s-call">remove</span>(key)
            }
        }
    }

    <span class="s-keyword">private mutating func</span> remove(<span class="s-keyword">_</span> key: <span class="s-type">Key</span>) {
        values[key] = <span class="s-keyword">nil</span>
        keyRemovalHandler?(key)
    }
}</code></pre><p>Just like that, our collection wrapper is done, and we’re ready to update <code>ContactList</code> to use it — by storing our contacts and groups using our new type, and by registering a <code>keyremovalHandler</code> that ensures that our <code>favoriteIDs</code> set stays in sync with our collection of contacts:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> contacts = <span class="s-type">Storage</span>(keyPath: \<span class="s-type">Contact</span>.<span class="s-property">id</span>)
    <span class="s-keyword">var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">var</span> groups = <span class="s-type">Storage</span>(keyPath: \<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-property">name</span>)

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name

        contacts.<span class="s-property">keyRemovalHandler</span> = { [<span class="s-keyword">weak self</span>] key <span class="s-keyword">in
            self</span>?.<span class="s-property">favoriteIDs</span>.<span class="s-call">remove</span>(key)
        }
    }
}</code></pre><p class="info">Note how Swift is able to infer the generic <code>Key</code> and <code>Value</code> types of our <code>Storage</code> instances based on the key paths that are passed into them — beautiful!</p><p>With our new implementation, we’ll still be able mutate our collections by adding and removing values, just like when using <code>Dictionary</code> directly — only now we’re ensuring that our data remains consistent, completely automatically.</p><p>As an added bonus, since we now have a custom collection type in place, we could go one step further and make it <em>even nicer</em> to use — by adding convenience APIs for adding and removing values without having to worry about what key to use:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span> {
    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-keyword">let</span> key = value[keyPath: keyPath]
        values[key] = value
    }

    <span class="s-keyword">mutating func</span> remove(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-keyword">let</span> key = value[keyPath: keyPath]
        <span class="s-call">remove</span>(key)
    }
}</code></pre><p>Using the above APIs and our <code>subscript</code> implementation from before, we’re now free to decide how we want to add and remove values within each situation, without impacting the consistency of our model in any way:</p><pre class="splash"><code><span class="s-comment">// Adding values:</span>
contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = contact
contactList.<span class="s-property">contacts</span>.<span class="s-call">add</span>(contact)

<span class="s-comment">// Removing values:</span>
contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
contactList.<span class="s-property">contacts</span>.<span class="s-call">remove</span>(contact)</code></pre><p>While writing a custom collection isn’t always appropriate, whenever we want to add new behaviors to one of the data structures that the standard library offers, creating lightweight wrappers that are each tailored to a very specific domain can be a great approach.</p><h2>Conclusion</h2><p>In many ways, in order to make a code base really robust and capable, we have to start by making its core data models as predictable and consistent as we possibly can — since those models often act as the foundation on top of which the rest of our code base is built.</p><p>By not requiring various states to be synced manually, and by preventing inconsistent states from being stored in the first place, we not only end up with a much stronger foundation — but one that’s often easier to work with as well, as our model architecture ends up doing much of that synchronization work for us.</p><p>What do you think? How do you currently ensure that your models remain as consistent as possible, and will any of the techniques covered in this article help you get closer to that goal? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/predicates-in-swift</guid><title>Predicates in Swift</title><description>Predicates can enable us to filter various collections in ways that are incredibly flexible. Let’s take a look at how we could construct powerful, type-safe predicates using closures, generics, and operators.</description><link>https://www.swiftbysundell.com/articles/predicates-in-swift</link><pubDate>Sun, 8 Dec 2019 22:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Even though modern apps tend to rely heavily on some form of server component in order to load their data and perform various kinds of work, it’s also incredibly common for an app to have to deal with significant amounts of locally stored data as well.</p><p>Not only do we have to come up with efficient and secure ways to store such data, we also have to design APIs for accessing it — and to ensure that those are flexible enough to let us keep iterating on new features and capabilities in a smooth and productive manner.</p><p>This week, let’s take a look at how we could leverage the power of predicates to achieve a great degree of flexibility when it comes to working with local data, and how Swift enables us to model predicates in a way that’s both highly expressive and very powerful.</p><h2>Filtering a collection of models</h2><p>As an example, let’s say that we’re building a classic todo app that lets our users organize their tasks and todo items using multiple lists — each of which is represented by a <code>TodoList</code> instance.</p><p>Since we want to enable our users to easily filter their tasks in various ways — we’ve created several APIs that let us query a list’s items based on a number of different conditions, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">static var</span> now: <span class="s-type">Date</span> { <span class="s-type">Date</span>() }
}

<span class="s-keyword">struct</span> TodoList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> items = [<span class="s-type">TodoItem</span>]()

    <span class="s-keyword">func</span> futureItems(basedOnDate date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &gt; date
        }
    }

    <span class="s-keyword">func</span> overdueItems(basedOnDate date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; date
        }
    }

    <span class="s-keyword">func</span> itemsTaggedWith(<span class="s-keyword">_</span> tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> { $0.<span class="s-property">tags</span>.<span class="s-call">contains</span>(tag) }
    }
}</code></pre><p class="info">Note that simply calling <code>filter</code> on an array is often not the most efficient way to search through a (potentially large) collection of values. However, we’ll stick with <code>filter</code> in this article for simplicity. For more advanced ways of structuring data, check out <a href="https://www.swiftbysundell.com/articles/picking-the-right-data-structure-in-swift">“Picking the right data structure in Swift”</a>.</p><p>While there’s nothing wrong with the above APIs, it would be nice to have a slightly greater degree of flexibility as we keep iterating on our app and as more filtering features are added. As our <code>TodoList</code> type is currently designed, every time we want to add a new way of filtering our data, we have to go back and add a brand new API.</p><p>Let’s see if we instead can find a way to let the <em>consumers</em> of our data decide exactly how they’d like to filter it. That way we would only have to build and maintain a single API, while also enabling new features to be built without any modifications to our underlying datastore.</p><h2>A case for predicates</h2><p>One way that we could achieve such a level of flexibility is by using Foundation’s <code>NSPredicate</code> class, which leverages the dynamic nature of Objective-C in order to let us filter collections of data using string-based queries. For example, here’s how we could use an <code>NSPredicate</code> to retrieve all overdue items from an array of <code>TodoItem</code> values:</p><pre class="splash"><code><span class="s-comment">// Before we can apply a predicate to our array, we must
// first convert it into an Objective-C-based NSArray:</span>
<span class="s-keyword">let</span> array = <span class="s-type">NSArray</span>(array: items)

<span class="s-keyword">let</span> overdueItems = array.<span class="s-call">filtered</span>(using: <span class="s-type">NSPredicate</span>(
    format: <span class="s-string">"isCompleted == false &amp;&amp; dueDate &lt; %@"</span>,
    <span class="s-type">NSDate</span>()
))</code></pre><p>While <code>NSPredicate</code> is incredibly powerful, it does come with a fair amount of downsides when used in Swift. First of all, since queries are written as strings, they don’t come with any sort of compile-time safety — as there is no way for the compiler to validate our property names, or even verify that our queries are syntactically correct.</p><p>Using Objective-C based APIs, like <code>NSPredicate</code> and <code>NSArray</code>, also requires us to turn our data models into classes that inherit from <code>NSObject</code> — which would prevents us from using value semantics, and require us to conform to Objective-C conventions, like enabling dynamic string-based access to our properties.</p><p>So while the <em>idea and concept</em> of predicates is incredibly appealing, let’s see if we can implement them in a more <em>“Swifty”</em> way. After all, implementation details aside, a predicate is just a function that returns a <code>Bool</code> for a given value — and could, in the very simplest of forms, be modeled like this:</p><pre class="splash"><code><span class="s-keyword">typealias</span> Predicate&lt;T&gt; = (<span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span></code></pre><p>While we could definitely define our predicates as free-form functions and closures, let’s instead create a simple wrapping struct that takes a closure and stores it as its <em>matcher</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Predicate&lt;Target&gt; {
    <span class="s-keyword">var</span> matches: (<span class="s-type">Target</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">init</span>(matcher: <span class="s-keyword">@escaping</span> (<span class="s-type">Target</span>) -&gt; <span class="s-type">Bool</span>) {
        matches = matcher
    }
}</code></pre><p class="info">If the above design looks similar, it might be because we used the exact same setup to implement plugins in last week’s article, <a href="https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins">“Making Swift code extensible through plugins”</a>.</p><p>With the above in place, we can now go back to our <code>TodoList</code> type and replace all of our previous filtering APIs with just a single one — that takes a <code>Predicate</code> and passes its matching closure to <code>items.filter</code> in order to return the items that we’re looking for:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">func</span> items(matching predicate: <span class="s-type">Predicate</span>&lt;<span class="s-type">TodoItem</span>&gt;) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span>(predicate.<span class="s-property">matches</span>)
    }
}</code></pre><p>Now, whenever we want to filter a <code>TodoList</code> based on any sort of query, we can now easily do so by calling the above method:</p><pre class="splash"><code><span class="s-keyword">let</span> list: <span class="s-type">TodoList</span> = ...

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: <span class="s-type">Predicate</span> {
    !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
})</code></pre><p>However, while we’ve now made our filtering API a lot more flexible, we’ve also lost some of the consistency that our previous approach gave us. If we would need to re-type the same predicate code over and over again, chances are high that we’ll end up with inconsistencies, bugs and mistakes.</p><p>Thankfully, there’s a way to both achieve a decent level of consistency, while still maintaining the power and flexibility of free-form predicates. By combining <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static properties and factory methods</a> with <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraints</a>, we can construct our most commonly used predicates in one central place — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Predicate</span> <span class="s-keyword">where</span> <span class="s-type">Target</span> == <span class="s-type">TodoItem</span> {
    <span class="s-keyword">static var</span> isOverdue: <span class="s-type">Self</span> {
        <span class="s-type">Predicate</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
        }
    }
}</code></pre><p>Not only does the above approach give us a much greater degree of consistency, it also makes our call sites look really elegant, since we can reference the above kind of static properties using <em>dot-syntax</em>:</p><pre class="splash"><code><span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: .<span class="s-dotAccess">isOverdue</span>)</code></pre><p>Now that we’ve found a way to make our new predicate system both consistent and flexible — let’s see if we can keep iterating on it to make it even easier to define and compose various predicates.</p><h2>Expressive operators</h2><p>One of the perhaps most divisive features that Swift offers is the ability to <a href="https://www.swiftbysundell.com/articles/custom-operators-in-swift">define and overload operators</a>. While there’s definitely an argument to be made that relying too heavily on (especially custom) operators can make our code much more cryptic and harder to understand — they could also have the complete opposite effect when used within the right contexts.</p><p>For example, let’s see what would happen if we would overload the <code>==</code> operator to enable a predicate to be defined using a <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key path</a> and a value to match against:</p><pre class="splash"><code><span class="s-keyword">func</span> ==&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Equatable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] == rhs }
}</code></pre><p class="info">In Swift, operator implementations are just normal functions that take their operands as arguments (in this case a left-hand side one, and a right-hand side one).</p><p>Using the above, we can now create matching predicates like this:</p><pre class="splash"><code><span class="s-keyword">let</span> uncompletedItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">isCompleted</span> == <span class="s-keyword">false</span>)</code></pre><p>That’s pretty cool! If we wanted to, we could also overload the <code>!</code> operator as well — which would enable us to encapsulate the above <code>== false</code> check within the resulting predicate:</p><pre class="splash"><code><span class="s-keyword">prefix func</span> !&lt;<span class="s-type">T</span>&gt;(rhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    rhs == <span class="s-keyword">false</span>
}</code></pre><p>With the above in place, our call site syntax now becomes really lightweight:</p><pre class="splash"><code><span class="s-keyword">let</span> uncompletedItems = list.<span class="s-call">items</span>(matching: !\.<span class="s-property">isCompleted</span>)</code></pre><p>Along the same lines, we could also overload the <code>&gt;</code> and <code>&lt;</code> operators for values that conform to Swift’s <code>Comparable</code> protocol — enabling us to define comparing predicates using the same lightweight syntax:</p><pre class="splash"><code><span class="s-keyword">func</span> &gt;&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Comparable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] &gt; rhs }
}

<span class="s-keyword">func</span> &lt;&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Comparable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] &lt; rhs }
}

<span class="s-keyword">let</span> highPriorityItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">priority</span> &gt; <span class="s-number">5</span>)</code></pre><p>The fact that operators allow us to express completely custom types purely using language syntax is really fascinating, and gives us an incredible amount of power when it comes to how we design our APIs. We just have to make sure to use that power responsibly.</p><h2>Composition built-in</h2><p>The fact that we chose to base our <code>Predicate</code> type on closures also opens up a lot of opportunities for composition — since functions and closures can easily be combined in order to form new functionality.</p><p>For example, here’s how we could define an additional pair of operators to enable our predicates to be composed into double-matching, or either-matching combinations:</p><pre class="splash"><code><span class="s-keyword">func</span> &amp;&amp;&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { lhs.<span class="s-call">matches</span>($0) &amp;&amp; rhs.<span class="s-call">matches</span>($0) }
}

<span class="s-keyword">func</span> ||&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { lhs.<span class="s-call">matches</span>($0) || rhs.<span class="s-call">matches</span>($0) }
}</code></pre><p>Using the above, along with the other operator overloads that we’ve defined so far, we can now create much more complex predicates that can have any number of conditions — all using existing operators that we’re already familiar with:</p><pre class="splash"><code><span class="s-keyword">let</span> futureItems = list.<span class="s-call">items</span>(
    matching: !\.<span class="s-property">isCompleted</span> &amp;&amp; \.<span class="s-property">dueDate</span> &gt; .<span class="s-dotAccess">now</span>
)

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(
    matching: !\.<span class="s-property">isCompleted</span> &amp;&amp; \.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
)

<span class="s-keyword">let</span> myTasks = list.<span class="s-call">items</span>(
    matching: \.<span class="s-property">creator</span> == .<span class="s-dotAccess">currentUser</span> || \.<span class="s-property">assignedTo</span> == .<span class="s-dotAccess">currentUser</span>
)</code></pre><p>However, going back to the point of consistency from before, when it comes to complex predicates that are intended to be reused throughout our code base, it’s arguably better to still use a static factory method — as doing so lets us neatly encapsulate all of the associated logic in a single place:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Predicate</span> <span class="s-keyword">where</span> <span class="s-type">Target</span> == <span class="s-type">TodoItem</span> {
    <span class="s-keyword">static func</span> isOverdue(
        comparedTo date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>,
        inlcudingCompleted includeCompleted: <span class="s-type">Bool</span> = <span class="s-keyword">false</span>
    ) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Predicate</span> {
            <span class="s-keyword">if</span> !includeCompleted {
                <span class="s-keyword">guard</span> !$0.<span class="s-property">isCompleted</span> <span class="s-keyword">else</span> {
                    <span class="s-keyword">return false</span>
                }
            }

            <span class="s-keyword">return</span> $0.<span class="s-property">dueDate</span> &lt; date
        }
    }
}

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: .<span class="s-call">isOverdue</span>())</code></pre><p class="info">By using a method, rather than a computed property, we can also inject customization options and data that can be stubbed when writing tests.</p><p>One of the major benefits of using a wrapping type, rather than referencing functions and closures directly, is that doing so enables us to decide which kind of syntax that’s the most appropriate within each situation.</p><h2>An expandable pattern</h2><p>The beauty of the predicate pattern that we’ve now established is that it enables us to keep expanding our implementation to suit our evolving needs. For example, if we found ourselves needing to check whether a given nested collection contains an element, we could add yet another operator overload for that:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Collection</span>&gt;(
    lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>.<span class="s-type">Element</span>
) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; <span class="s-keyword">where</span> <span class="s-type">V</span>.<span class="s-type">Element</span>: <span class="s-type">Equatable</span> {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs].<span class="s-call">contains</span>(rhs) }
}

<span class="s-keyword">let</span> importantItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">tags</span> ~= <span class="s-string">"important"</span>)</code></pre><p>Finally, since we built our <code>Predicate</code> type as a simple closure-based wrapper, it’s automatically compatible with many of the standard library’s various collection APIs — as we can pass a predicate’s <code>matches</code> closure as a <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class function</a>:</p><pre class="splash"><code><span class="s-keyword">let</span> strings: [<span class="s-type">String</span>] = ...
<span class="s-keyword">let</span> predicate: <span class="s-type">Predicate</span>&lt;<span class="s-type">String</span>&gt; = \.<span class="s-property">count</span> &gt; <span class="s-number">3</span>

strings.<span class="s-call">filter</span>(predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">drop</span>(while: predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">prefix</span>(while: predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">contains</span>(where: predicate.<span class="s-property">matches</span>)</code></pre><p>The above call sites also read really nicely, almost like normal English sentences, thanks to our use of a wrapping type and the way its <code>matches</code> property is named.</p><h2>Conclusion</h2><p>Predicates can enable us to filter through in-memory data in ways that are both flexible and incredibly powerful, without requiring us to maintain a growing set of highly specific APIs.</p><p>By modeling our predicates in a way that takes advantage of some of Swift’s most powerful features — like generics, operators, and first class functions — we can also create predicates that are not only flexible, but completely type-safe as well.</p><p>I’m also really looking forward to the implementation of <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md">Swift Evolution proposal SE-0249</a>, which will enable key paths to be directly converted into functions — enabling even more kinds of predicates to be easily constructed.</p><p>However, the kind of predicates that we explored in this article are really only suitable for querying in-memory data, as it’d be very hard to encode free-form closures into something that could be passed to a server, or to an on-disk database.</p><p>What do you think? Have you used predicates in this sort of way before, or is it something that’d be suitable for your code base? Let me know — along with your questions, comments or feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins</guid><title>Making Swift code extensible through plugins</title><description>Let’s take a look at a few different ways to add plugin support to a type or library, and how doing so can enable a system to become a lot more decoupled and flexible.</description><link>https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins</link><pubDate>Sun, 1 Dec 2019 17:30:00 +0100</pubDate><content:encoded><![CDATA[<p>When writing shared abstractions, libraries and other kinds of code that’s intended to be used by multiple developers or different parts of a system, it’s often quite tricky to decide what the exact scope of that code’s functionality should be.</p><p>With a very narrow feature set the code might not be able to accomplish what we need it to, and if it has too many features there’s a substantial risk that it becomes huge, messy and hard to maintain — by attempting to cover too much ground and by taking on too many responsibilities.</p><p>This week, let’s continue exploring the topic of <em><a href="https://www.swiftbysundell.com/articles/configurable-types-in-swift">configurable types</a></em> that was covered earlier this year — by taking a look at how setting up a plugin-based architecture can help us keep a library or piece of functionality as narrow and as small as possible, while still enabling it to be extended and tailored for more specific use cases.</p><h2>Starting out simple</h2><p>There’s definitely an argument to be made that most of the code that we write should ideally start out as simple as possible. Making things too generic and flexible from the start often leads to over-complicated implementations, and APIs that might never end up being used in practice.</p><p>Let’s say that we've started building an <code>ImageLoader</code> class for loading images over the network, and that in order to follow that philosophy of not making things too complicated, we’ve simply made our new class act as a relatively thin wrapper around an existing <code>Networking</code> protocol — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">private let</span> networking: <span class="s-type">Networking</span>

    <span class="s-keyword">init</span>(networking: <span class="s-type">Networking</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">networking</span> = networking
    }

    <span class="s-keyword">func</span> loadImage(from url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> request = <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)

        networking.<span class="s-call">perform</span>(request) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">guard let</span> image = <span class="s-type">UIImage</span>(data: data) <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(<span class="s-type">ImageError</span>.<span class="s-property">invalidData</span>))
                    <span class="s-keyword">return</span>
                }

                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>The above implementation might be simple, but it’ll probably be enough as long as our requirements stay simple as well. However, as our project evolves, that situation might change. We might also decide that we want to share the above class with other developers, or between different apps, which could make its requirements grow increasingly more complex as a result.</p><p>For example, some use cases might require certain requests to be authenticated, or we might want to add support for displaying placeholder images if the user’s network connection was lost, and so on.</p><p>While we could, of course, decide to let our <code>ImageLoader</code> take on all of those new responsibilities (and have it grow in scope and complexity as a result) — let’s instead take a look at how we could enable external code to be injected into it, and how that code could implement those kind of features in a very flexible way.</p><h2>Plugins</h2><p>Like the name implies, a <em>plugin</em> is a piece of code that can be plugged into another type or system in order to modify its functionality. While plugins can take on many different shapes and forms, let’s again start out simple and say that a plugin will, in this case, simply be a function — that takes a value of a given type as input and returns a new version of it as output:</p><pre class="splash"><code><span class="s-keyword">typealias</span> Plugin&lt;T&gt; = (<span class="s-type">T</span>) -&gt; <span class="s-type">T</span></code></pre><p>With just that simple type alias, we could now start defining many different kinds of plugins and modifiers. For example, here’s how we might set up a plugin function that adds a watermark to any image that was passed into it:</p><pre class="splash"><code><span class="s-keyword">let</span> watermarkingPlugin: <span class="s-type">Plugin</span>&lt;<span class="s-type">UIImage</span>&gt; = { image <span class="s-keyword">in
    let</span> renderer = <span class="s-type">UIGraphicsImageRenderer</span>(size: image.<span class="s-property">size</span>)

    <span class="s-keyword">return</span> renderer.<span class="s-call">image</span> { context <span class="s-keyword">in</span>
        context.<span class="s-call">draw</span>(image)
        context.<span class="s-call">drawWatermark</span>(forImageSize: image.<span class="s-property">size</span>)
    }
}</code></pre><p>However, being able to define plugins is not enough — we also need a way for them to actually interact with the type that they’re for. To make that happen, let’s start by implementing a simple collection type that’ll let us keep track of all plugins that were added for a certain value and use case, and to also apply them to a given value as well:</p><pre class="splash"><code><span class="s-keyword">struct</span> PluginCollection&lt;Value&gt; {
    <span class="s-keyword">private var</span> plugins = [<span class="s-type">Plugin</span>&lt;<span class="s-type">Value</span>&gt;]()

    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> plugin: <span class="s-keyword">@escaping</span> <span class="s-type">Plugin</span>&lt;<span class="s-type">Value</span>&gt;) {
        plugins.<span class="s-call">append</span>(plugin)
    }

    <span class="s-keyword">func</span> apply(to value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Value</span> {
        plugins.<span class="s-call">reduce</span>(value) { value, plugin <span class="s-keyword">in</span>
            <span class="s-call">plugin</span>(value)
        }
    }
}</code></pre><p class="info">The reason we keep the underlying array of plugins private is that we don’t want to allow any external code to freely modify it. Using the above setup, the only type of mutation that’s allowed is to add new plugins to the collection.</p><p>With the above infrastructure in place, let’s start enabling plugins to be attached to our <code>ImageLoader</code> from before. The first thing we’ll do is to define two <code>PluginCollection</code> properties — one for plugins that’ll be called before we start performing a request, and one for those that wish to modify the result of loading an image:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    ...
    <span class="s-keyword">var</span> preProcessingPlugins = <span class="s-type">PluginCollection</span>&lt;<span class="s-type">Request</span>&gt;()
    <span class="s-keyword">var</span> postProcessingPlugins = <span class="s-type">PluginCollection</span>&lt;<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">Error</span>&gt;&gt;()
    ...
}</code></pre><p>Next, let’s invoke each set of plugins as part of our image loading process. Since our collection of <code>preProcessingPlugins</code> will be capable of modifying each request before it’s sent, let’s call it when initializing our <code>Request</code> value — like this:</p><pre class="splash"><code><span class="s-keyword">let</span> request = preProcessingPlugins.<span class="s-call">apply</span>(
    to: <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)
)</code></pre><p>On the other end, our collection of <code>postProcessingPlugins</code> should be called after a request finished loading — enabling each of those plugins to perform post-processing on the loaded image (or the resulting error). Using <em><a href="https://www.swiftbysundell.com/tips/variable-shadowing">variable shadowing</a></em>, we’ll wrap the <code>handler</code> that was passed into our image loading function, in order to inject our plugin logic:</p><pre class="splash"><code><span class="s-keyword">let</span> handler: <span class="s-type">Handler</span> = { [postProcessingPlugins] result <span class="s-keyword">in</span>
    <span class="s-call">handler</span>(postProcessingPlugins.<span class="s-call">apply</span>(to: result))
}</code></pre><p>If we now update <code>ImageLoader</code> with the above two pieces of code, our <code>loadImage</code> method will end up looking like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    ...
    <span class="s-keyword">func</span> loadImage(from url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> request = preProcessingPlugins.<span class="s-call">apply</span>(
            to: <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)
        )

        <span class="s-keyword">let</span> handler: <span class="s-type">Handler</span> = { [postProcessingPlugins] result <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(postProcessingPlugins.<span class="s-call">apply</span>(to: result))
        }

        networking.<span class="s-call">perform</span>(request) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">guard let</span> image = <span class="s-type">UIImage</span>(data: data) <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(<span class="s-type">ImageError</span>.<span class="s-property">invalidData</span>))
                    <span class="s-keyword">return</span>
                }

                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>In the grand scheme of things, the modifications that we just made to <code>ImageLoader</code> were really minor, but they still enable a ton of new flexibility and power. For example, besides the watermarking plugin we took a look at earlier, we could use our new plugin system to conditionally authenticate each request if the user of our app has logged in:</p><pre class="splash"><code>imageLoader.<span class="s-property">preProcessingPlugins</span>.<span class="s-call">add</span> { [loginController] request <span class="s-keyword">in</span>
    <span class="s-comment">// Don't authenticate external API calls</span>
    <span class="s-keyword">guard</span> request.<span class="s-property">url</span>.<span class="s-property">isInternalAPIURL</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> request
    }

    <span class="s-keyword">guard let</span> accessToken = loginController.<span class="s-property">session</span>?.<span class="s-property">accessToken</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> request
    }

    <span class="s-keyword">return</span> request.<span class="s-call">addingHeader</span>(
        named: <span class="s-string">"Authorization"</span>,
        value: <span class="s-string">"Bearer</span> \(accessToken)<span class="s-string">"</span>
    )
}</code></pre><p>When it comes to post-processing, we could now easily inject a placeholder image in case a request failed with an offline error:</p><pre class="splash"><code>imageLoader.<span class="s-property">postProcessingPlugins</span>.<span class="s-call">add</span> { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>:
        <span class="s-keyword">return</span> result
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error) <span class="s-keyword">where</span> error.<span class="s-property">isOfflineError</span>:
        <span class="s-keyword">return</span> .<span class="s-call">success</span>(.<span class="s-call">makePlaceholder</span>())
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>:
        <span class="s-keyword">return</span> result
    }
}</code></pre><p class="info">Above we’re using Swift’s powerful pattern matching capabilities to match all failures with errors that were caused by our app being offline. To learn more about those capabilities, check out <a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">“Pattern matching in Swift”</a>.</p><p>The benefit of building the above functionality as plugins, rather than implementing it within <code>ImageLoader</code> itself, is that our system becomes a lot more modular and flexible overall. Our image loader doesn’t need to know anything about access tokens, but can still support authenticated requests, and we could keep defining new kinds of plugins to do all sorts of both pre- and post-processing — all using a very simple, closure-based abstraction.</p><h2>Multiple flavors of the same pattern</h2><p>Like with most patterns and techniques, there are multiple ways that a plugin-style architecture could be implemented — and many different scales at which such a setup could be deployed. However, regardless of which abstraction that’s chosen and to what extent we end up using such a plugin system, the goal remains the same — to enable functionality to be decoupled, and for specific overrides to be injected, rather than requiring one single type to cover all possible use cases.</p><p>Let’s take a look at two examples from the open source world, starting with the Core Animation-based game engine <a href="https://github.com/JohnSundell/ImagineEngine">Imagine Engine</a> — which uses plugins to enable various game components and logic to be defined in a completely decoupled manner. Since these plugins require multiple APIs, they’re modeled as a protocol, rather than as a closure type:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Plugin: <span class="s-type">AnyObject</span> {
    <span class="s-keyword">associatedtype</span> Object: <span class="s-type">AnyObject</span>

    <span class="s-keyword">func</span> activate(for object: <span class="s-type">Object</span>, in game: <span class="s-type">Game</span>)
    <span class="s-keyword">func</span> deactivate()
}</code></pre><p>Just like our <code>ImageLoader</code> plugin system from before, the above protocol enables all sorts of plugins to be used to modify the game engine’s various objects. For example, here’s how a plugin could be implemented to have a scene’s camera follow the movement of any <em>actor</em> — such as a player or an enemy:</p><pre class="splash"><code><span class="s-keyword">class</span> FollowActorPlugin: <span class="s-type">Plugin</span> {
    <span class="s-keyword">private let</span> actor: <span class="s-type">Actor</span>

    <span class="s-keyword">init</span>(actor: <span class="s-type">Actor</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">actor</span> = actor
    }

    <span class="s-keyword">func</span> activate(for camera: <span class="s-type">Camera</span>, in game: <span class="s-type">Game</span>) {
        actor.<span class="s-property">events</span>.<span class="s-property">moved</span>.<span class="s-call">addObserver</span>(camera) { camera, actor <span class="s-keyword">in</span>
            camera.<span class="s-property">position</span> = actor.<span class="s-property">position</span>
        }
    }
}</code></pre><p class="info">The above code also shows the observer pattern in action, which was covered in the two-part article <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">“Observers in Swift”</a>.</p><p>Finally, let’s take a look at a third <em>“flavor”</em> of plugins, which can be found in the <a href="https://github.com/JohnSundell/Ink">Markdown parser Ink</a>, which enables <a href="https://daringfireball.net/projects/markdown">Markdown</a>-formatted strings to be converted into HTML. When using that library, the plugin-like <code>Modifier</code> type can be used to implement various modifiers that are plugged into the Markdown parsing process — for example in order to add a heading on top of each code block within an article:</p><pre class="splash"><code><span class="s-keyword">let</span> modifier = <span class="s-type">Modifier</span>(target: .<span class="s-dotAccess">codeBlocks</span>) { html, markdown <span class="s-keyword">in
    return</span> <span class="s-string">"&lt;h3&gt;Sample code:&lt;/h3&gt;"</span> + html
}</code></pre><p class="info">Fun meta fact: Ink was used to generate the very article that you’re reading right now.</p><p>Acting as a sort of hybrid between the protocol-oriented approach found in Imagine Engine, and the simpler closure-based approach that we built in this article, Ink’s <code>Modifier</code> type uses a <code>Target</code> enum to enable the library to decide in which context to execute each plugin closure — and looks like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Modifier {
    <span class="s-keyword">public typealias</span> Input = (html: <span class="s-type">String</span>, markdown: <span class="s-type">Substring</span>)
    <span class="s-keyword">public typealias</span> Closure = (<span class="s-type">Input</span>) -&gt; <span class="s-type">String</span>

    <span class="s-keyword">public var</span> target: <span class="s-type">Target</span>
    <span class="s-keyword">public var</span> closure: <span class="s-type">Closure</span>

    <span class="s-keyword">public init</span>(target: <span class="s-type">Target</span>, closure: <span class="s-keyword">@escaping</span> <span class="s-type">Closure</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">target</span> = target
        <span class="s-keyword">self</span>.<span class="s-property">closure</span> = closure
    }
}</code></pre><p>Each of the above examples enable their libraries to remain focused on their core set of tasks, rather than having to include explicit APIs for all sorts of functionality — which in turns enables the users of those libraries to more freely customize how they behave, and to implement new functionality without having to make any modifications to the library itself.</p><h2>Conclusion</h2><p>When deployed in the right contexts, plugin architectures can be incredibly powerful — and can let us unlock new capabilities for both external users, and for our internal implementations as well. Adding plugin support to a library or type can not only act as an <em>“escape hatch”</em> that lets users implement missing APIs and features themselves, but can also help prevent a project from growing too much in both scope and complexity.</p><p>However, plugins are not always appropriate, and they do come with their own set of trade-offs as well. One risk with using a plugin-heavy approach is that the overall system could become too fragmented and distributed — potentially making certain issues harder to debug, or making it more time-consuming to get an overview of the system. Whether or not those trade-offs are worth it will, like always, depend on the sort of system that we’re looking to build.</p><p>What do you think? Have you ever added plugin support to a library or system, or have you perhaps benefited from one of your dependencies supporting plugins? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</guid><title>Lightweight API design in Swift</title><description>This week, let’s take a look at a few core language features that enable us to design really lightweight APIs in Swift, and how we can use them to make a feature or system much more capable through the power of composition.</description><link>https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</link><pubDate>Sun, 24 Nov 2019 21:30:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the most powerful aspects of Swift is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types that are easier to understand and use — it also lets us create APIs that give a very lightweight first impression, while still progressively disclosing more power and complexity if needed.</p><p>This week, let’s take a look at some of the core language features that enable those kind of lightweight APIs to be created, and how we can use them to make a feature or system much more capable through the power of composition.</p><h2>A trade-off between power and ease of use</h2><p>Often when we design how our various types and functions will interact with each other, we have to find some form of balance between power and ease of use. Make things too simple, and they might not be flexible enough to enable our features to continuously evolve — but on the other hand, too much complexity often leads to frustration, misunderstandings, and ultimately bugs.</p><p>As an example, let’s say that we’re working on an app that lets our users apply various filters to images — for example to be able to edit photos from their camera roll or library. Each filter is made up of an array of image transforms, and is defined using an <code>ImageFilter</code> struct, that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageFilter {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span>
    <span class="s-keyword">var</span> transforms: [<span class="s-type">ImageTransform</span>]
}</code></pre><p>When it comes to the <code>ImageTransform</code> API, it’s currently modeled as a protocol, which is then conformed to by various types that implement our individual transform operations:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ImageTransform {
    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span>
}

<span class="s-keyword">struct</span> PortraitImageTransform: <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">var</span> zoomMultiplier: <span class="s-type">Double</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        ...
    }
}

<span class="s-keyword">struct</span> GrayScaleImageTransform: <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">var</span> brightnessLevel: <span class="s-type">BrightnessLevel</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        ...
    }
}</code></pre><p>One core advantage of the above approach is that, since each transform is implemented as its own type, we’re free to let each type define its own set of properties and parameters — such as how <code>GrayScaleImageTransform</code> accepts a <code>BrightnessLevel</code> to use when turning an image into grayscale.</p><p>We can then combine as many of the above types as we wish in order to form each filter — for example one that gives an image a bit of a <em>“dramatic”</em> look through a series of transforms:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        <span class="s-type">PortraitImageTransform</span>(zoomMultiplier: <span class="s-number">2.1</span>),
        <span class="s-type">ContrastBoostImageTransform</span>(),
        <span class="s-type">GrayScaleImageTransform</span>(brightnessLevel: .<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>So far so good — but if we take a closer look at the above API, it can definitely be argued that we’ve chosen to optimize for power and flexibility, rather than for ease of use. Since each transform is implemented as an individual type, it’s not immediately clear what kind of transforms that our code base contains, since there’s no single place in which they can all be instantly discovered.</p><p>Compare that to if we would’ve chosen to use an enum to model our transforms instead — which would’ve given us a very clear overview of all possible options:</p><pre class="splash"><code><span class="s-keyword">enum</span> ImageTransform {
    <span class="s-keyword">case</span> portrait(zoomMultiplier: <span class="s-type">Double</span>)
    <span class="s-keyword">case</span> grayScale(<span class="s-type">BrightnessLevel</span>)
    <span class="s-keyword">case</span> contrastBoost
}</code></pre><p>Using an enum would’ve also resulted in very nice and readable call sites — making our API feel much more lightweight and easy to use, since we would’ve been able to construct any number of transforms using <em>dot-syntax</em>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        .<span class="s-call">portrait</span>(zoomMultiplier: <span class="s-number">2.1</span>),
        .<span class="s-dotAccess">contrastBoost</span>,
        .<span class="s-call">grayScale</span>(.<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>However, while Swift enums are a fantastic tool in many different situations, this isn’t really one of them.</p><p>Since each transform needs to perform vastly different image operations, using an enum in this case would’ve forced us to write one massive <code>switch</code> statement to handle each and every one of those operations — which would most likely become somewhat of a nightmare to maintain.</p><h2>Light as an enum, capable as a struct</h2><p>Thankfully, there’s a third option — which sort of gives us the best of both worlds. Rather than using either a protocol or an enum, let’s instead use a struct, which in turn will contain a closure that encapsulates a given transform’s various operations:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageTransform {
    <span class="s-keyword">let</span> closure: (<span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        <span class="s-keyword">try</span> <span class="s-call">closure</span>(image)
    }
}</code></pre><p class="info">Note that the <code>apply(to:)</code> method is no longer required, but we still add it both for backward compatibility, and to make our call sites read a bit nicer.</p><p>With the above in place, we can now use <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods and properties</a> to create our transforms — each of which can still be individually defined and have its own set of parameters:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">static var</span> contrastBoost: <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }

    <span class="s-keyword">static func</span> portrait(withZoomMultipler multiplier: <span class="s-type">Double</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }

    <span class="s-keyword">static func</span> grayScale(withBrightness brightness: <span class="s-type">BrightnessLevel</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }
}</code></pre><p class="info">That <code>Self</code> can now be used as a return type for static factory methods is one of the <a href="https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1/">small but significant improvements introduced in Swift 5.1</a>.</p><p>The beauty of the above approach is that we’re back to the same level of flexibility and power that we had when defining <code>ImageTransform</code> as a protocol, while still being able to use a more or less identical dot-syntax as when using an enum:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        .<span class="s-call">portrait</span>(withZoomMultipler: <span class="s-number">2.1</span>),
        .<span class="s-dotAccess">contrastBoost</span>,
        .<span class="s-call">grayScale</span>(withBrightness: .<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>The fact that dot syntax isn’t tied to enums, but can instead be used with any sort of static API, is incredibly powerful — and even lets us encapsulate things one step further, by modeling the above filter creation as a computed static property as well:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageFilter</span> {
    <span class="s-keyword">static var</span> dramatic: <span class="s-type">Self</span> {
        <span class="s-type">ImageFilter</span>(
            name: <span class="s-string">"Dramatic"</span>,
            icon: .<span class="s-dotAccess">drama</span>,
            transforms: [
                .<span class="s-call">portrait</span>(withZoomMultipler: <span class="s-number">2.1</span>),
                .<span class="s-dotAccess">contrastBoost</span>,
                .<span class="s-call">grayScale</span>(withBrightness: .<span class="s-dotAccess">dark</span>)
            ]
        )
    }
}</code></pre><p>The result of all of the above is that we can now take a really complex series of tasks — applying image filters and transforms — and encapsulate them into an API that, on the surface level, appears as lightweight as simply passing a value to a function:</p><pre class="splash"><code><span class="s-keyword">let</span> filtered = image.<span class="s-call">withFilter</span>(.<span class="s-dotAccess">dramatic</span>)</code></pre><p>While it’s easy to dismiss the above change as purely adding <em>”syntactic sugar”</em>, we haven’t only improved the way our API reads, but also the way in which its parts can be composed. Since all transforms and filters are now just values, they can be combined in a huge number of ways — which doesn’t only make them more lightweight, but also much more flexible as well.</p><h2>Variadic parameters and further composition</h2><p>Next, let’s take a look at another really interesting language feature — variadic parameters — and what kind of API design choices that they can unlock.</p><p>Let’s now say that we’re working on an app that uses shape-based drawing in order to create parts of its user interface, and that we’ve used a similar struct-based approach as above in order to model how each shape is drawn into a <code>DrawingContext</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Shape {
    <span class="s-keyword">var</span> drawing: (<span class="s-keyword">inout</span> <span class="s-type">DrawingContext</span>) -&gt; <span class="s-type">Void</span>
}</code></pre><p class="info">Above we use the <code>inout</code> keyword to enable a value type (<code>DrawingContext</code>) to be passed as if it was a reference. For more on that keyword, and value semantics in general, check out <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">“Utilizing value semantics in Swift”</a>.</p><p>Just like how we enabled <code>ImageTransform</code> values to be easily created using static factory methods before, we’re now also able to encapsulate each shape’s drawing code within completely separate methods — like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> square(at point: <span class="s-type">Point</span>, sideLength: <span class="s-type">Double</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Shape</span> { context <span class="s-keyword">in
            let</span> origin = point.<span class="s-call">movedBy</span>(
                x: -sideLength / <span class="s-number">2</span>,
                y: -sideLength / <span class="s-number">2</span>
            )

            context.<span class="s-call">move</span>(to: origin)
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(x: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(x: sideLength, y: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(y: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin)
        }
    }
}</code></pre><p>Since each shape is simply modeled as a value, drawing arrays of them becomes quite easy — all we have to do is to create an instance of <code>DrawingContext</code>, and then pass that into each shape’s closure in order to build up our final image:</p><pre class="splash"><code><span class="s-keyword">func</span> draw(<span class="s-keyword">_</span> shapes: [<span class="s-type">Shape</span>]) -&gt; <span class="s-type">Image</span> {
    <span class="s-keyword">var</span> context = <span class="s-type">DrawingContext</span>()
    
    shapes.<span class="s-call">forEach</span> { shape <span class="s-keyword">in</span>
        context.<span class="s-call">move</span>(to: .<span class="s-dotAccess">zero</span>)
        shape.<span class="s-call">drawing</span>(&amp;context)
    }
    
    <span class="s-keyword">return</span> context.<span class="s-call">makeImage</span>()
}</code></pre><p>Calling the above function also looks quite elegant, since we’re again able to use dot syntax to heavily reduce the amount of syntax needed to perform our work:</p><pre class="splash"><code><span class="s-keyword">let</span> image = <span class="s-call">draw</span>([
    .<span class="s-call">circle</span>(at: point, radius: <span class="s-number">10</span>),
    .<span class="s-call">square</span>(at: point, sideLength: <span class="s-number">5</span>)
])</code></pre><p>However, let’s see if we can take things one step further using variadic parameters. While not a feature unique to Swift, when combined with Swift’s really flexible parameter naming capabilities, using variadic parameters can yield some really interesting results.</p><p>When a parameter is marked as variadic (by adding the <code>...</code> suffix to its type), we’re essentially able to pass any number of values to that parameter — and the compiler will automatically organize those values into an array for us, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> draw(<span class="s-keyword">_</span> shapes: <span class="s-type">Shape</span>...) -&gt; <span class="s-type">Image</span> {
    ...
    <span class="s-comment">// Within our function, 'shapes' is still an array:</span>
    shapes.<span class="s-call">forEach</span> { ... }
}</code></pre><p>With the above change in place, we can now remove all of the array literals from the calls to our <code>draw</code> function, and instead make them look like this:</p><pre class="splash"><code><span class="s-keyword">let</span> image = <span class="s-call">draw</span>(.<span class="s-call">circle</span>(at: point, radius: <span class="s-number">10</span>),
                 .<span class="s-call">square</span>(at: point, sideLength: <span class="s-number">5</span>))</code></pre><p>That might not seem like such a big change, but especially when designing more lower-level APIs that are intended to be used to create more higher-level values (such as our <code>draw</code> function), using variadic parameters can make those kind of APIs feel much more lightweight and convenient.</p><p>However, one drawback of using variadic parameters is that an array of pre-computed values can no longer be passed as a single argument. Thankfully, that can quite easily be fixed in this case, by creating a special <code>group</code> shape that — just like the <code>draw</code> function itself — iterates over an array of underlying shapes and draws them:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> group(<span class="s-keyword">_</span> shapes: [<span class="s-type">Shape</span>]) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Shape</span> { context <span class="s-keyword">in</span>
            shapes.<span class="s-call">forEach</span> { shape <span class="s-keyword">in</span>
                context.<span class="s-call">move</span>(to: .<span class="s-dotAccess">zero</span>)
                shape.<span class="s-call">drawing</span>(&amp;context)
            }
        }
    }
}</code></pre><p>With the above in place, we can now once again easily pass a group of pre-computed <code>Shape</code> values to our <code>draw</code> function, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> shapes: [<span class="s-type">Shape</span>] = <span class="s-call">loadShapes</span>()
<span class="s-keyword">let</span> image = <span class="s-call">draw</span>(.<span class="s-call">group</span>(shapes))</code></pre><p>What’s really cool though, is that not only does the above <code>group</code> API enable us to construct arrays of shapes — it also enables us to much more easily compose multiple shapes into more higher-level components. For example, here’s how we could express an entire drawing (such as a logo), using a group of composed shapes:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> logo(withSize size: <span class="s-type">Size</span>) -&gt; <span class="s-type">Self</span> {
        .<span class="s-call">group</span>([
            .<span class="s-call">rectangle</span>(at: size.<span class="s-property">centerPoint</span>, size: size),
            .<span class="s-call">text</span>(<span class="s-string">"The Drawing Company"</span>, fittingInto: size),
            ...
        ])
    }
}</code></pre><p>Since the above logo is a <code>Shape</code> just like any other, we can easily draw it with a single call to our <code>draw</code> method, using the same elegant dot syntax as we used before:</p><pre class="splash"><code><span class="s-keyword">let</span> logo = <span class="s-call">draw</span>(.<span class="s-call">logo</span>(withSize: size))</code></pre><p>What’s interesting is that while our initial goal might’ve been to make our API more lightweight, in doing so we also made it more composable and more flexible as well.</p><h2>Conclusion</h2><p>The more tools that we add to our <em>“API designer’s toolbox”</em>, the more likely it is that we’ll be able to design APIs that strike the right balance between power, flexibility and ease of use.</p><p>Making APIs as lightweight as possible might not be our ultimate goal, but by trimming our APIs down as much as we can, we also often discover how they can be made more powerful — by making the way we create our types more flexible, and by enabling them to be composed. All of which can aid us in achieving that perfect balance between simplicity and power.</p><p>What do you think? Do you like the kind of lightweight API design used in this article, or do you prefer your APIs to be a bit more verbose? Let me know — along with any questions, comments or feedback that you might have — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/defining-custom-patterns-in-swift</guid><title>Defining custom patterns in Swift</title><description>This week, let’s dive deep into the world of pattern matching in Swift — to take a look at how we can construct completely custom patterns, and some of the interesting techniques that we can unlock by doing so.</description><link>https://www.swiftbysundell.com/articles/defining-custom-patterns-in-swift</link><pubDate>Sun, 17 Nov 2019 14:30:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the most interesting aspects of Swift as a language is just how many of its core features that are implemented using the language itself, rather than being hard-coded into the compiler. That’s not only elegant from a theoretical perspective, but also gives us a ton of practical flexibility, as it lets us tweak how the language works and behaves in really powerful ways.</p><p>An example of one such feature is <em><a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">pattern matching</a></em> which, among other things, determines how control flow constructs like <code>switch</code> and <code>case</code> statements are evaluated. This week, let’s dive deep into the world of pattern matching in Swift — to take a look at how we can construct completely custom patterns, and some of the interesting techniques that we can unlock by doing so.</p><h2>Building the basics</h2><p>As the name implies, <em>pattern matching</em> is all about matching a given value against a pre-defined pattern, often in order to figure out which code branch to continue executing a program on. For example, every time we switch on a value, we are using Swift’s pattern matching feature:</p><pre class="splash"><code><span class="s-keyword">func</span> items(in section: <span class="s-type">Section</span>) -&gt; [<span class="s-type">Item</span>] {
    <span class="s-keyword">switch</span> section {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">featured</span>:
        <span class="s-keyword">return</span> dataSource.<span class="s-property">featuredItems</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">recent</span>:
        <span class="s-keyword">return</span> dataSource.<span class="s-property">recentItems</span>
    }
}</code></pre><p>Above we’re matching a <code>Section</code> enum value against two patterns that are made up of its cases (<code>featured</code> and <code>recent</code>), and while that’s a very common way of using pattern matching in Swift — it barely scratches the surface of what the feature is capable of.</p><p>To take things further, let’s start by defining a <code>Pattern</code> struct, which we’ll use to define our own closure-based patterns. Those closures will simply take a value to match, and then return the result as a <code>Bool</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Pattern&lt;Value&gt; {
    <span class="s-keyword">let</span> closure: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Bool</span>
}</code></pre><p>The above struct may be simple, but it actually enables us to now define all sorts of custom patterns, by extending it using <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraints</a> in order to add <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods</a> that create our patterns. For example, here’s how we could define a pattern that lets us match a value against a given set of candidates:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Pattern</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Hashable</span> {
    <span class="s-keyword">static func</span> any(of candidates: <span class="s-type">Set</span>&lt;<span class="s-type">Value</span>&gt;) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { candidates.<span class="s-call">contains</span>($0) }
    }
}</code></pre><p>Before we’ll be able to use our new <code>Pattern</code> struct within a <code>switch</code> statement, however, we’ll also need to tell Swift how to actually evaluate it within such a context.</p><p>All forms of pattern matching in Swift are powered by the <code>~=</code> operator, which takes the pattern to evaluate as its <em>left-hand-side</em> argument, and the value being matched as its <em>right-hand-side</em> one. So in order to hook our <code>Pattern</code> type into that system, all we have to do is to overload <code>~=</code> with a function that takes an instance of our new struct and a value to match — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Pattern</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span> {
    lhs.<span class="s-call">closure</span>(rhs)
}</code></pre><p>With the above in place, we’ve now built all of the infrastructure required to define our own custom patterns — so let’s get started!</p><h2>Mix and match</h2><p>Let’s say that we’re working on some form of social networking app, that uses a <code>LoggedInUser</code> struct in order to keep track of the currently logged in user’s data — for example the user’s ID, as well the IDs of the friends they’ve added using our app:</p><pre class="splash"><code><span class="s-keyword">struct</span> LoggedInUser {
    <span class="s-keyword">let</span> id: <span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;
    <span class="s-keyword">var</span> friendIDs: <span class="s-type">Set</span>&lt;<span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;&gt;
    ...
}</code></pre><p class="info">Above we’re using the <code>Identifier</code> type from <a href="https://www.swiftbysundell.com/articles/type-safe-identifiers-in-swift">“Type-safe identifiers in Swift”</a> and the <a href="https://github.com/JohnSundell/Identity">Identity package</a>.</p><p>Now let’s say that we’re building a view controller that lets us display any number of users as a list — and that we want to render different icons depending on what kind of user that we’re displaying. That decision can now be made completely within a single <code>switch</code> statement, thanks to our new <code>Pattern</code> type and its <code>any(of:)</code> variant:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">UserListViewController</span> {
    <span class="s-keyword">func</span> resolveIcon(for userID: <span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Icon</span> {
        <span class="s-keyword">switch</span> userID {
        <span class="s-keyword">case</span> loggedInUser.<span class="s-property">id</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">currentUser</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">any</span>(of: loggedInUser.<span class="s-property">friendIDs</span>):
            <span class="s-keyword">return</span> .<span class="s-dotAccess">friend</span>
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">anyUser</span>
        }
    }
}</code></pre><p>The above may at first not seem <em>that</em> different compared to writing our logic as a series of <code>if</code> and <code>else</code> statements, but it does make our code more declarative — and also makes <code>userID</code> a single source of truth for all of our possible rules and outcomes.</p><h2>Comparing patterns</h2><p>Let’s continue extending our <code>Pattern</code> type with more capabilities — this time by adding support for patterns that compare one value against another. We’ll do that by writing an extension constrained by the standard library’s <code>Comparable</code> protocol (another example of how a core language feature is implemented using a standard Swift protocol), which’ll contain two methods — one for matching against lower values, and one for greater ones:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Pattern</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Comparable</span> {
    <span class="s-keyword">static func</span> lessThan(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { $0 &lt; value }
    }

    <span class="s-keyword">static func</span> greaterThan(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { $0 &gt; value }
    }
}</code></pre><p>The above comes very much in handy anytime we want to compare a value against both a lower and upper bound — like in this example, in which we’re determining whether a user passed a required game score threshold, or whether they achieved a new high score — all within a single <code>switch</code> statement:</p><pre class="splash"><code><span class="s-keyword">func</span> levelFinished(withScore score: <span class="s-type">Int</span>) {
    <span class="s-keyword">switch</span> score {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">lessThan</span>(<span class="s-number">50</span>):
        <span class="s-call">showGameOverScreen</span>()
    <span class="s-keyword">case</span> .<span class="s-dotAccess">greaterThan</span>(highscore):
        <span class="s-call">showNewHighscore</span>(score)
    <span class="s-keyword">default</span>:
        <span class="s-call">goToNextLevel</span>()
    }
}</code></pre><p class="info">The cases within a <code>switch</code> statement are always evaluated top-to-bottom, meaning that the above <code>lessThan</code> check will be performed before the <code>greaterThan</code> one.</p><p>We’re now starting to uncover the true power of Swift’s pattern matching capabilities, since we’ve gone beyond just matching against single (or groups of) candidates, and are now constructing more complex pattern expressions — all without making our call sites any more complicated.</p><h2>Converting key paths into patterns</h2><p>Another way of forming patterns that can be incredibly useful, is by using <em><a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a></em>. Since key paths are already represented by a concrete type, <code>KeyPath</code>, we simply need to add another <code>~=</code> overload in order to enable any key path to be used as a pattern:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;, rhs: <span class="s-type">T</span>?) -&gt; <span class="s-type">Bool</span> {
    rhs?[keyPath: lhs] ?? <span class="s-keyword">false</span>
}</code></pre><p class="info">Above we’re accepting an optional, <code>T?</code>, which will enable us to match non-optional key paths against optional values.</p><p>With the above in place, we can now freely mix key paths with other kinds of patterns, which will enable us to express even quite complex pieces of logic using just a single <code>switch</code> statement.</p><p>For example, here we’re deciding how to parse a line of text into a list item, based on its first character — by using the <code>Character</code> type’s <a href="https://www.swiftbysundell.com/tips/character-category-properties">category properties</a> to form key path-based patterns, combined with patterns that match against the <code>Optional</code> enum’s two cases, as well as <code>where</code> clauses:</p><pre class="splash"><code><span class="s-keyword">struct</span> ListItemParser {
    <span class="s-keyword">enum</span> Kind {
        <span class="s-keyword">case</span> numbered
        <span class="s-keyword">case</span> unordered
    }

    <span class="s-keyword">let</span> kind: <span class="s-type">Kind</span>

    <span class="s-keyword">func</span> parseLine(<span class="s-keyword">_</span> line: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">ListItem</span> {
        <span class="s-comment">// Here we're switching on an optional Character, which is
        // the type of values that Swift strings are made up of:</span>
        <span class="s-keyword">switch</span> line.<span class="s-property">first</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">none</span>:
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">emptyLine</span>
        <span class="s-keyword">case</span> \.<span class="s-property">isNewline</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">empty</span>
        <span class="s-keyword">case</span> \.<span class="s-property">isNumber</span> <span class="s-keyword">where</span> kind == .<span class="s-dotAccess">numbered</span>:
            <span class="s-keyword">return</span> <span class="s-call">parseLineAsNumberedItem</span>(line)
        <span class="s-keyword">case</span> <span class="s-string">"-"</span> <span class="s-keyword">where</span> kind == .<span class="s-dotAccess">unordered</span>:
            <span class="s-keyword">return</span> <span class="s-call">parseLineAsUnorderedItem</span>(line)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">some</span>(<span class="s-keyword">let</span> character):
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-call">invalidFirstCharacter</span>(character)
        }
    }
}</code></pre><p class="info">The <code>.none</code> and <code>.some</code> cases used above are the two cases that make up Swift’s <code>Optional</code> enum, which is the type used to model all optional values within a Swift program.</p><p>As if the above wasn’t cool enough, let’s also take a look at how we could take any key path-based expression and combine it with a value comparison — enabling us to compose the two in order to form even more powerful patterns.</p><p>To make that happen, let’s define yet another operator overload, this time of <code>==</code> — which will return a <code>Pattern</code> that combines a <code>KeyPath</code> and a constant value, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> ==&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Equatable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Pattern</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-keyword">return</span> <span class="s-type">Pattern</span> { $0[keyPath: lhs] == rhs }
}</code></pre><p>To take the above for a spin, let’s say that we’re now working on a shopping app, and that we’re calculating the shipping cost for each order based on the <code>Destination</code> that it’ll be sent to. In this example, our logistics center is located in the city of Paris, which lets us to offer free shipping to everyone living in that city, as well as reduced shipping costs within Europe.</p><p>Since we’re now able to combine key paths with values to form patterns, we can simply implement the way we calculate what level of shipping costs that are associated with a given <code>Destination</code> like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Destination {
    <span class="s-keyword">var</span> address: <span class="s-type">String</span>
    <span class="s-keyword">var</span> city: <span class="s-type">String</span>
    <span class="s-keyword">var</span> country: <span class="s-type">Country</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Destination</span> {
    <span class="s-keyword">var</span> shippingCost: <span class="s-type">ShippingCost</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-comment">// Combining a key path with a constant value:</span>
        <span class="s-keyword">case</span> \.<span class="s-property">city</span> == <span class="s-string">"Paris"</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">free</span>
        <span class="s-comment">// Using a nested key path as a pattern:</span>
        <span class="s-keyword">case</span> \.<span class="s-property">country</span>.<span class="s-property">isInEurope</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">reduced</span>
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">normal</span>
        }
    }
}</code></pre><p>Pretty cool! Not only does the above read really nicely, it also enables us to easily insert new rules whenever needed, in a way that doesn’t necessarily increase the complexity of our code. We could also keep iterating on our <code>Pattern</code> struct, and the ways it can be combined with key paths, in order to enable even more powerful combinations to be created.</p><h2>Conclusion</h2><p>The fact that Swift’s pattern matching feature isn’t only specifically implemented for a small number of hard-coded types, but is rather a completely dynamic system that can be extended and customized, gives us some incredibly powerful capabilities.</p><p>However, like with any powerful system, it’s important to carefully consider when and how to deploy it — and to always use the resulting call sites as guidance as to what kind of patterns that we want to be able to construct. After all, the end goal of using powerful patterns to model complex logic using single <code>switch</code> statements should be to make that logic easier to understand, not the other way around.</p><p>What do you think? To what extent have you used Swift’s pattern matching capabilities so far, and will you try any of the techniques mentioned in this article within your code base? Let me know — and feel free to send me any questions, comments or feedback that you have — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift</guid><title>Combining value and reference types in Swift</title><description>Let’s take a look at how combining value and reference types can unlock some really powerful capabilities, enabling us to utilize both the convenience of reference types, and the safety and limited mutability of value types.</description><link>https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift</link><pubDate>Sun, 10 Nov 2019 18:00:00 +0100</pubDate><content:encoded><![CDATA[<p>A very common type of decision that all Swift developers have to make on an ongoing basis is whether to model a given piece of functionality or state as either a <em>value</em> or a <em>reference</em>. While values give us very clear semantics, as each value is automatically copied when passed, references enable us to establish a single source of truth — even though that might mean sharing state, which can also become a liability if we’re not careful.</p><p>However, not all of those decisions need to result in <em>either</em> a reference type or a value type — sometimes <em>combining</em> the two can give us some really powerful capabilities, and open up some incredibly interesting code design options. That’s exactly what we’ll explore this week — let’s dive in!</p><h2>Collections of weak references</h2><p>Often when establishing a relationship between two kinds of objects we’d like one side of that relationship to be referenced <em>weakly</em> (since if both sides reference each other strongly, that’d lead to a <a href="https://www.swiftbysundell.com/basics/memory-management">retain cycle</a>).</p><p>For example, let’s say that we’re building a <code>VideoPlayer</code>, and that we’d like to enable another object to observe it. To make that happen, we might define a class-bound <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">observation protocol</a> called <code>PlaybackObserver</code>, and then enable a conforming object to attach itself to our video player through an <code>observer</code> property:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">weak var</span> observer: <span class="s-type">PlaybackObserver</span>?
    ...
}</code></pre><p class="info">Arguably, if our <code>VideoPlayer</code> will maintain a 1:1 relationship to its observer, it might be more appropriate to make it a <a href="https://www.swiftbysundell.com/articles/delegation-in-swift">delegate instead</a>.</p><p>While the above approach works as long as we only support a <em>single</em> observer to be attached to each video player, once we add support for multiple ones, things start to get tricky — as we’d have to store our observers within some form of collection, like an <code>Array</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observers = [<span class="s-type">PlaybackObserver</span>]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        observers.<span class="s-call">append</span>(observer)
    }
    
    ...
}</code></pre><p>The problem is that, by making the above change, our observers are no longer stored weakly (since arrays retain their elements strongly). Thankfully, that’s quite easily fixed, by combining our <em>reference type-based</em> <code>PlaybackObserver</code> protocol with a <em>boxing value type</em> — which’ll simply wrap an observer instance by storing a weak reference to it, like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">VideoPlayer</span> {
    <span class="s-keyword">struct</span> Observation {
        <span class="s-keyword">weak var</span> observer: <span class="s-type">PlaybackObserver</span>?
    }
}</code></pre><p>With the above in place, we can now update our <code>VideoPlayer</code> to store <code>Observation</code> values, rather than direct (strong) references to each observer — which’ll break any possible retain cycles, since each observer is now again referenced weakly:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observations = [<span class="s-type">Observation</span>]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        <span class="s-keyword">let</span> observation = <span class="s-type">Observation</span>(observer: observer)
        observations.<span class="s-call">append</span>(observation)
    }
    
    ...
}</code></pre><p class="info">To learn more about the above way of managing observations, and the observer pattern in general, check out the two-part article <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">“Observers in Swift”</a>.</p><p>While the above implementation solved the problem of storing instances of a <em>specific type</em> in a weak fashion, let’s now say that we want to generalize that concept to let us use the same implementation within different parts of a code base. An initial idea on how to do that might be to create a generic <code>Weak</code> struct, which — similar to our above <code>Observation</code> type — stores a given object weakly:</p><pre class="splash"><code><span class="s-keyword">struct</span> Weak&lt;Object: <span class="s-type">AnyObject</span>&gt; {
    <span class="s-keyword">weak var</span> object: <span class="s-type">Object</span>?
}</code></pre><p>However, while the above <code>Weak</code> type will work great as long as we know the <em>exact type</em> of the object that it should store, it’ll turn out to be quite problematic for protocol types. Even though a protocol might be class-bound (in that it’s constrained to <code>AnyObject</code>, which only makes it possible for classes to conform to it), it doesn’t make the <em>protocol itself</em> a class type. So if we tried to use our new <code>Weak</code> type within our <code>VideoPlayer</code>, we’d get this kind of compiler error:</p><pre class="splash"><code><span class="s-comment">// Error: 'Weak' requires that 'PlaybackObserver' be a class type</span>
<span class="s-keyword">private var</span> observations = [<span class="s-type">Weak</span>&lt;<span class="s-type">PlaybackObserver</span>&gt;]()</code></pre><p>At this point, it might seem like all hope is lost, but it turns out that there is <em>a way</em> for us to achieve what we want — which involves using a capturing closure, rather than a <code>weak</code> property, to implement our object reference — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Weak&lt;Object&gt; {
    <span class="s-keyword">var</span> object: <span class="s-type">Object</span>? { <span class="s-call">provider</span>() }
    <span class="s-keyword">private let</span> provider: () -&gt; <span class="s-type">Object</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> object: <span class="s-type">Object</span>) {
        <span class="s-comment">// Any Swift value can be "promoted" to an AnyObject, however,
        // that doesn't automatically turn it into a reference.</span>
        <span class="s-keyword">let</span> reference = object <span class="s-keyword">as</span> <span class="s-type">AnyObject</span>

        provider = { [<span class="s-keyword">weak</span> reference] <span class="s-keyword">in</span>
            reference <span class="s-keyword">as</span>? <span class="s-type">Object</span>
        }
    }
}</code></pre><p>The downside of the above approach is that we’re now able to initialize our <code>Weak</code> struct with any object or value, not only with class instances. However, that might not be such a big deal, especially if we’re only using it as an implementation detail for tasks like managing observers. Because the upside is that we can now easily store collections of protocol-conforming instances weakly — enabling us to update our <code>VideoPlayer</code> from before to now look like this:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observations = [<span class="s-type">Weak</span>&lt;<span class="s-type">PlaybackObserver</span>&gt;]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        observations.<span class="s-call">append</span>(<span class="s-type">Weak</span>(observer))
    }
    
    ...
}</code></pre><p>Pretty cool! Whether or not it’s worth it to create a generic <code>Weak</code> wrapper, rather than just using specific ones (like the <code>Observation</code> type we started out with), will of course depend heavily on how many use cases for storing collections of weak references that we have. Like always, it’s often best to start out with a very specific implementation, and then generalize later if needed.</p><h2>Passing references to value types</h2><p>Next, let’s flip the coin — and take a look at how reference types can be used to wrap value types. Let’s say that we’re building an app that stores various user-configurable settings using a value type that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Settings {
    <span class="s-keyword">var</span> colorTheme: <span class="s-type">ColorTheme</span>
    <span class="s-keyword">var</span> rememberLoggedInUser: <span class="s-type">Bool</span>
    ...
}</code></pre><p>While defining core data models as values is usually a good idea, as it lets us <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">fully utilize value semantics</a> — sometimes we might want to enable multiple objects to share a reference to a single instance of a given model.</p><p>For example, let’s say that we wanted multiple parts of our code base to be able to read and modify the same <code>Settings</code> value, without having to implement any complex data flows. One way to accomplish that would be to create another boxing type, just like our <code>Weak</code> struct from before, but this time to enable us to wrap a value type inside of a reference type — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}</code></pre><p>With the above in place, we can now easily turn any value type into a reference, simply by wrapping it in a <code>Reference</code> instance, and then passing that instance to whichever object or function that we want to share our value with:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-call">loadSettings</span>()
<span class="s-keyword">let</span> sharedSettings = <span class="s-type">Reference</span>(value: settings)</code></pre><p>For example, here’s how a <code>ProfileViewModel</code> could accept a referenced <code>Settings</code> value, rather than just a copy of one:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel {
    <span class="s-keyword">private let</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> settings: <span class="s-type">Reference</span>&lt;<span class="s-type">Settings</span>&gt;

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, settings: <span class="s-type">Reference</span>&lt;<span class="s-type">Settings</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    <span class="s-keyword">func</span> makeEmailAddressIcon() -&gt; <span class="s-type">Icon</span> {
        <span class="s-keyword">var</span> icon = <span class="s-type">Icon</span>.<span class="s-property">email</span>
        icon.<span class="s-property">useLightVersion</span> = settings.<span class="s-property">value</span>.<span class="s-property">colorTheme</span>.<span class="s-property">isDark</span>
        <span class="s-keyword">return</span> icon
    }
    
    ...
}</code></pre><p>While the above approach is a really convenient way to share value type-based data across an app, it does come with two major downsides. The first is that we have to always access the passed reference’s <code>value</code> property in order to <em>actually</em> get access to the value that we’re interested in, and the second is that we’re now sharing <em>mutable state</em> between multiple parts of our code base.</p><p>While we can’t do much about the first downside (unless we want to replicate each of our value type’s APIs within our reference type, which kind of defeats the point of it), we <em>could</em> limit our state’s mutability — which often helps make a system a bit more predictable and easier to debug, since the number of places in which a piece of state can be modified is reduced.</p><p>One way to do that is to make our <code>Reference</code> type immutable, and then create a mutable subclass of it (let’s call it <code>MutableReference</code>). That way, only the creator of a reference will be able to mutate it, since it can simply be passed as an immutable <code>Reference</code> afterwards:</p><pre class="splash"><code><span class="s-keyword">class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">fileprivate(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}

<span class="s-keyword">class</span> MutableReference&lt;Value&gt;: <span class="s-type">Reference</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">func</span> update(with value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}</code></pre><p>Here’s an example of how the above can be really useful, since it lets us update our shared value reference whenever needed, while still enabling us to pass it as an immutable object — without having to do any kind of conversion:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-call">loadSettings</span>()

<span class="s-comment">// Since this part of our code base knows that our reference is
// mutable, it can easily update it whenever needed:</span>
<span class="s-keyword">let</span> sharedSettings = <span class="s-type">MutableReference</span>(value: settings)
<span class="s-call">observeSettingsChange</span>(with: sharedSettings.<span class="s-property">update</span>)

<span class="s-comment">// Since our view model accepts an immutable reference, it won't
// be able to mutate our value in any way:</span>
<span class="s-keyword">let</span> viewModel = <span class="s-type">ProfileViewModel</span>(settings: sharedSettings)</code></pre><p>The above kind of boxing types can be incredibly useful, especially if we limit their mutation capabilities to only be visible within the parts of our code base that <em>should</em> be able to mutate them — as that can give us much of the flexibility and power of reference types, without the problems that usually start to occur when over-sharing mutable state.</p><p>However, when deploying boxing types, it’s always worth considering whether another abstraction (such as a <a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">model controller</a>, a <a href="https://www.swiftbysundell.com/articles/bindable-values-in-swift">bindable value</a>, or a reactive framework such as Combine) would be more appropriate. Especially if the way we share and pass values across our app grows more complex, a more powerful abstraction might be the way to go — even though we might choose to start out with something like the above <code>Reference</code> type in order to keep things simple initially.</p><h2>Using reference types as underlying storage</h2><p>Finally, let’s go beyond boxing types and take a look at how value and reference types can be truly combined to unlock some really powerful capabilities. Let’s say that we’ve defined a value type that lets us express complex formatted texts, by splitting them up into separate components that can then be rendered into an <code>NSAttributedString</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> FormattedText {
    <span class="s-keyword">var</span> components: [<span class="s-type">Component</span>]

    <span class="s-keyword">func</span> render() -&gt; <span class="s-type">NSAttributedString</span> {
        <span class="s-keyword">let</span> result = <span class="s-type">NSMutableAttributedString</span>()
        components.<span class="s-call">forEach</span> { result.<span class="s-call">append</span>($0.<span class="s-call">render</span>()) }
        <span class="s-keyword">return</span> result
    }
}</code></pre><p>While the above provides a nice, <em>“Swifty”</em> way of building up attributed strings, it requires an <code>O(n)</code> evaluation every time that we want to display each text — which will result in duplicate work when rendering the same text in multiple places.</p><p>To address that, let’s take some inspiration from the Swift standard library, which uses pointers and references as storage for certain key value types — such as <code>String</code> and <code>Array</code> — to give them <em>copy-on-write</em> semantics. What that means is that multiple values can share the same underlying storage until one of them is actually mutated, minimizing the amount of copy operations that need to occur as we pass values around (since only the <em>“value type shell”</em> is actually copied).</p><p>In our case, we’ll use a similar approach, but for a slightly different purpose — to implement a <code>RenderingCache</code> for our above <code>FormattedText</code> type. That way we’ll only have to render each copy of the same text once, which should significantly boost performance in situations when the same text is used in multiple places (effectively turning each subsequent rendering pass into an <code>O(1)</code> operation).</p><p>Our cache will be a simple class, which only has one job — to store the result of a previous rendering operation:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">FormattedText</span> {
    <span class="s-keyword">class</span> RenderingCache {
        <span class="s-keyword">var</span> result: <span class="s-type">NSAttributedString</span>?
    }
}</code></pre><p>Then, as we’ve finished rendering an <code>NSAttributedString</code>, we’ll store the result in an instance of our <code>RenderingCache</code> — which will be replaced whenever our <code>components</code> array is mutated. That way we’re avoiding caching stale data, and since our cache is a reference type, it will keep being pointed to the same instance — even as a <code>FormattedText</code> value gets passed around our app.</p><p>Here’s what the complete implementation looks like:</p><pre class="splash"><code><span class="s-keyword">struct</span> FormattedText {
    <span class="s-keyword">var</span> components: [<span class="s-type">Component</span>] {
        <span class="s-keyword">didSet</span> { cache = <span class="s-type">RenderingCache</span>() }
    }

    <span class="s-keyword">private var</span> cache = <span class="s-type">RenderingCache</span>()

    <span class="s-keyword">init</span>(components: [<span class="s-type">Component</span>] = []) {
        <span class="s-keyword">self</span>.<span class="s-property">components</span> = components
    }

    <span class="s-keyword">func</span> render() -&gt; <span class="s-type">NSAttributedString</span> {
        <span class="s-keyword">if let</span> cached = cache.<span class="s-property">result</span> {
            <span class="s-keyword">return</span> cached
        }

        <span class="s-keyword">let</span> result = <span class="s-type">NSMutableAttributedString</span>()
        components.<span class="s-call">forEach</span> { result.<span class="s-call">append</span>($0.<span class="s-call">render</span>()) }
        cache.<span class="s-property">result</span> = result

        <span class="s-keyword">return</span> result
    }
}</code></pre><p>By using a reference type as our underlying storage, while keeping the API surface entirely value-type based — we can combine the performance benefits of having a single source of truth, while still enabling the users of our API to take full advantage of value semantics, by limiting mutability and by not publicly sharing state.</p><h2>Conclusion</h2><p>The fact that Swift fully supports both value and reference types gives us a ton of flexibility when it comes to how we design our APIs, how we construct their underlying implementations, and how state is managed within an app or system.</p><p>While most types will probably continue being either purely a value or a class, sometimes, by combining the two we can achieve some really powerful results — enabling us to utilize both the convenience and performance characteristics of reference types, and the safety and limited mutability of value types.</p><p>What do you think? Have you ever used one of the techniques mentioned in this article, or could they become useful to you either now or in the future? Let me know — along with your questions, comments and feedback — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/enums</guid><title>Basics: Enums</title><description>How enums work in Swift, a look at some of their most prominent features, and examples of situations in which they can be incredibly useful.</description><link>https://www.swiftbysundell.com/basics/enums</link><pubDate>Fri, 8 Nov 2019 18:30:00 +0100</pubDate><content:encoded><![CDATA[<p>An enum is a type that <em>enumerates</em> a finite set of values, such as raw values, like strings or integers. They’re really useful when modeling things like options, states, or anything else that can be described using a pre-defined number of values.</p><p>Let’s take a look at how enums work in Swift, some of their most prominent features, and examples of situations in which they can come very much in handy.</p><p>An enum is defined using the <code>enum</code> keyword, and can contain any number of <code>case</code> declarations that each define one of the enum’s possible states — like how this <code>ContactType</code> enum contains cases for various kinds of contacts:</p><pre class="splash"><code><span class="s-keyword">enum</span> ContactType {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
    <span class="s-keyword">case</span> businessPartner
}</code></pre><p>When using an instance of the above enum, we’ll get a compile-time guarantee that it’ll always be equal to one of the above cases — which is what makes enums such a great match for <code>switch</code> statements (which, by default, have to be exhaustive):</p><pre class="splash"><code><span class="s-keyword">func</span> iconName(forContactType type: <span class="s-type">ContactType</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">switch</span> type {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
        <span class="s-keyword">return</span> <span class="s-string">"friend"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
        <span class="s-keyword">return</span> <span class="s-string">"family"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
        <span class="s-keyword">return</span> <span class="s-string">"coworker"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">businessPartner</span>:
        <span class="s-keyword">return</span> <span class="s-string">"business_partner"</span>
    }
}</code></pre><p class="info">If we add a new case to our enum in the future, then the compiler will give us an error for the above code — which is great, as it forces us to decide how we want to handle the new case.</p><p>Our <code>ContactType</code> enum currently doesn’t represent any concrete value, but rather just acts as an abstract representation of a contact type. To change that, we simply have to add a raw type (like <code>String</code> or <code>Int</code>) to our enum declaration — like this:</p><pre class="splash"><code><span class="s-comment">// By adding ": String" after its name, we've now made our enum
// representable by a raw value — String in this case:</span>
<span class="s-keyword">enum</span> ContactType: <span class="s-type">String</span> {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
    <span class="s-comment">// We can also customize what exact raw value that we want a
    // case to be represented by (the default will match the
    // case's name for strings, and its index for integers):</span> 
    <span class="s-keyword">case</span> businessPartner = <span class="s-string">"business_partner"</span>
}</code></pre><p>The beauty of the above change is that it enables us to easily convert any <code>ContactType</code> value into a <code>String</code> — meaning that we can now rewrite our <code>iconName</code> function from before to look like this instead:</p><pre class="splash"><code><span class="s-keyword">func</span> iconName(forContactType type: <span class="s-type">ContactType</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">return</span> type.<span class="s-property">rawValue</span>
}</code></pre><p>That works both ways, as we can now also easily convert a <code>String</code> value into a <code>ContactType</code> instance as well, given that the string matches the raw value of one of our cases:</p><pre class="splash"><code><span class="s-comment">// A valid raw value will be matched to its corresponding case,
// while an invalid one will result in 'nil':</span>
<span class="s-keyword">let</span> valid = <span class="s-type">ContactType</span>(rawValue: <span class="s-string">"coworker"</span>) <span class="s-comment">// .coworker</span>
<span class="s-keyword">let</span> invalid = <span class="s-type">ContactType</span>(rawValue: <span class="s-string">"unknown"</span>) <span class="s-comment">// nil</span></code></pre><p>Besides being representable by raw values, enums can also carry <em>associated values</em> — which are values placed within individual enum cases. For example, here we’ve defined a <code>ReadState</code> enum, which is used to describe a user’s progress through a book:</p><pre class="splash"><code><span class="s-keyword">enum</span> ReadState {
    <span class="s-comment">// The user hasn't started reading the book yet:</span>
    <span class="s-keyword">case</span> unread
    <span class="s-comment">// The user is currently reading the book at a
    // given page number:</span>
    <span class="s-keyword">case</span> inProgress(pageNumber: <span class="s-type">Int</span>)
    <span class="s-comment">// The user has finished reading the book, and gave it
    // a given rating once done:</span>
    <span class="s-keyword">case</span> finished(rating: <span class="s-type">Rating</span>)
}</code></pre><p class="info">Note that an enum cannot have <strong>both</strong> a raw value type and associated values.</p><p>Associated enum values are incredibly flexible, since each case is free to define its very own set of values (like above). That’s particularly useful when <a href="https://www.swiftbysundell.com/articles/modelling-state-in-swift">modeling state</a>, since rather than having to define all possible state values as optionals, we only have to deal with the values that are relevant for the <em>current</em> state — again something that’s really useful when using a <code>switch</code> statement to handle an enum value:</p><pre class="splash"><code><span class="s-keyword">func</span> restore(fromState state: <span class="s-type">ReadState</span>) {
    <span class="s-keyword">switch</span> state {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">unread</span>:
        <span class="s-call">openBook</span>()
    <span class="s-keyword">case</span> .<span class="s-dotAccess">inProgress</span>(<span class="s-keyword">let</span> pageNumber):
        <span class="s-call">openBook</span>()
        <span class="s-call">turnToPage</span>(number: pageNumber)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>(<span class="s-keyword">let</span> rating):
        <span class="s-call">displayRating</span>(rating)
    }
}</code></pre><p>Finally, let’s take a look at a few different ways to <em>declare</em> an enum value. Another thing that makes enums so nice in Swift is that they support <em>“dot-syntax”</em> — which lets us refer to any enum case simply by prefixing it with a dot, when the enum’s type can be inferred by the compiler.</p><p>For example, here’s how we could call the above <code>restore</code> function using dot-syntax:</p><pre class="splash"><code><span class="s-call">restore</span>(fromState: .<span class="s-dotAccess">unread</span>)
<span class="s-call">restore</span>(fromState: .<span class="s-call">inProgress</span>(pageNumber: <span class="s-number">5</span>))</code></pre><p>While dot-syntax is arguably just <em>syntactic sugar</em>, it can make our function calls read so much nicer — effectively enabling us to read the above code more or less like normal English sentences.</p><p>However, when the underlying type can’t be inferred by the compiler, we do have to declare it — for example when storing an instance of the above <code>ReadState</code> enum as a property:</p><pre class="splash"><code><span class="s-keyword">struct</span> BookSession {
    <span class="s-keyword">var</span> book: <span class="s-type">Book</span>
    <span class="s-keyword">var</span> readState: <span class="s-type">ReadState</span> = .<span class="s-dotAccess">unread</span>
}</code></pre><p class="info">We could also have declared the above <code>readState</code> property as <code>ReadState.unread</code>, which would’ve yielded the exact same result.</p><p>Swift enums are both incredibly powerful and flexible, and could also be used to simplify our code — by pre-defining the number of states or configurations that a given value can be in at compile-time.</p><p>That’s a key part though, because enums are only really useful when the number of states can be specified up-front — so for more free-form values that can only be determined at runtime, other constructs (like structs, protocols, or classes) are most likely going to be more appropriate.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing</guid><title>Tip: Implementing throwing protocol functions as non-throwing</title><description>In Swift, it’s possible to satisfy a throwing function protocol requirement using a non-throwing function, which can be very useful in certain situations.</description><link>https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing</link><pubDate>Tue, 5 Nov 2019 21:45:00 +0100</pubDate><content:encoded><![CDATA[<p>In Swift, it’s possible to satisfy a throwing function protocol requirement using a non-throwing function, which can be very useful in certain situations. For example, let’s say that we’ve defined a protocol for parsers that enable us tokenize a string in some way:</p><pre class="splash"><code><span class="s-keyword">protocol</span> TokenParser {
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Token</span>
}</code></pre><p>While certain implementations of the above protocol will need to throw, that won’t necessarily be true for all conforming types. For example, the below <code>KeywordParser</code> throws, while <code>TextParser</code> doesn’t:</p><pre class="splash"><code><span class="s-keyword">struct</span> KeywordParser: <span class="s-type">TokenParser</span> {
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Token</span> {
        ...
    }
}

<span class="s-keyword">struct</span> TextParser: <span class="s-type">TokenParser</span> {
    <span class="s-comment">// This will satisfy our protocol requirement, even though
    // this implementation doesn't actually throw:</span>
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) -&gt; <span class="s-type">Token</span> {
        ...
    }
}</code></pre><p>Since the original declaration of our protocol function is marked as throwing, we’ll always need to call it with <code>try</code> when the exact conforming type isn’t known — regardless of whether the underlying implementation <em>actually</em> throws:</p><pre class="splash"><code><span class="s-keyword">let</span> parsers: [<span class="s-type">TokenParser</span>] = ...

<span class="s-keyword">for</span> parser <span class="s-keyword">in</span> parsers {
    <span class="s-comment">// Since all we know about each parser within this iteration
    // is that it conforms to our 'TokenParser' protocol, we'll
    // need to use 'try' when calling its function:</span>
    <span class="s-keyword">let</span> token = <span class="s-keyword">try</span> parser.<span class="s-call">parseToken</span>(from: string)
}</code></pre><p>However, when dealing with a non-throwing conforming type directly, we can now omit the <code>try</code> keyword — even though the original protocol requirement was marked as throwing:</p><pre class="splash"><code><span class="s-keyword">let</span> parser = <span class="s-type">TextParser</span>()
<span class="s-keyword">let</span> text = parser.<span class="s-call">parseToken</span>(from: string)</code></pre><p>It’s a small feature, but the fact that we can implement a throwing function requirement using a non-throwing one gives us a slightly greater degree of flexibility when conforming to protocols that contain such functions.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies</guid><title>Deciding whether to adopt new Swift technologies</title><description>This week, let’s take a look at a few tips and ways of thinking when it comes to approaching new tools and technologies — using the decision of whether or not to be an early adopter of SwiftUI as an example.</description><link>https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies</link><pubDate>Sun, 3 Nov 2019 20:30:00 +0100</pubDate><content:encoded><![CDATA[<p>As Swift developers, the ways we build apps and the tools that we use are constantly changing. Every year, there’s a huge amount of new technologies, tools, frameworks, and language features coming out — both from Apple and third party developers — and while many of them are both useful and exciting, it can sometimes be challenging to keep up with this very rapid flow of changes.</p><p>Since everything is moving so fast, and there’s no indication of things ever really slowing down — making decisions as to what new technologies to adopt becomes incredibly important, especially as a project grows in both size and complexity. This week, let’s take a look at a few tips and ways of thinking when it comes to approaching new tools and technologies — using the decision of whether or not to be an early adopter of <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> as an example.</p><h2>To be, or not to be, production-ready</h2><p>Whenever a new tool, library or framework comes out, there’s one main question that tends to get asked really frequently: <em>is this new piece of technology “production-ready”?</em></p><p>While that’s a great question to ask, the answers are most often very context-specific. What the criteria are for something to be considered <em>production-ready</em> tend to vary quite a lot, both from person to person, and depending on what sort of environment that the technology will be deployed in. For one person, <em>production-ready</em> might simply mean that <em>“it seems to work when used”</em>, while others might have a much more extensive list of requirements to be fulfilled.</p><p>So rather than trying to obtain a singular answer as to whether the technology we’re looking to adopt is universally <em>production-ready</em>, it’s often much more productive to ask a series of questions that’ll let us build up an idea of its current state — questions like:</p><ul><li>Are there any examples of this technology being deployed in production, and what seems to be the results?</li><li>What sort of <em>scale</em> do we need this new tool to handle, and does that seem to be what the tool is currently designed for?</li><li>How does the vendor or creator of the tool use it themselves, and does that match the way we’re planning to use it?</li><li>What sort of documentation and support is available, and does that seem to match our needs?</li></ul><p>In many ways, choosing to become an <em>early adopter</em> of anything — whether it’s hardware or software — always comes with a certain degree of risk. However, the more aligned our use case is with what seems to be the most common one, the lower that risk usually becomes — and the only way to really find out whether or not that’s true, is to do a little bit of research before we start writing any code.</p><h2>Non-critical first steps</h2><p>In general, a great way to start adopting a new API or technology is to start by deploying it in a fairly <em>non-critical</em> part of a project. That both reduces the risk of an essential feature breaking, and lets us ease our way into using the new tool — to learn about its strengths, weaknesses and edge cases before fully deploying it across the project.</p><p>For example, let’s say that we’re currently deciding whether or not to adopt SwiftUI, and that we’ve determined that it seems to be ‌production-ready for our use case. However, since fully embracing SwiftUI requires us to drop support for older operating system versions — we’d first like to test it in a way that lets us still maintain complete backward compatibility.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift/">“Shifting paradigms in Swift”</a></em>, one way to do that is to add all of our SwiftUI code behind <em>availability checks</em> — which will let us keep running our app on older system versions, by only activating our SwiftUI-related code when running on devices that support it.</p><p>Let’s say that our app contains a feature that lets us show some form of promotion to our users, and that it’s not something we consider to be essential for our overall user experience — so we decide to use that feature as our <em>SwiftUI testbed</em>, by implementing it as a <code>View</code> marked with the <code>@available</code> attribute:</p><pre class="splash"><code><span class="s-keyword">import</span> SwiftUI

<span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> PromotionView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> { ... }
}</code></pre><p>Doing the above will give us a compiler error if we ever try to use our new <code>PromotionView</code> within code paths that aren’t guaranteed to only be executed on iOS 13 and above — so to give the compiler that guarantee, we’ll use an <code>#available</code> check at the call site, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> presentPromotion(in presentingViewController: <span class="s-type">UIViewController</span>) {
    <span class="s-comment">// Using this statement will let us assume that the rest
    // of this function will only be executed on iOS 13 and above:</span>
    <span class="s-keyword">guard #available</span>(iOS <span class="s-number">13</span>, *) <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span>
    }
    
    <span class="s-comment">// We also add a dynamic feature flag that'll let us control
    // whether our promotion feature will be enabled at runtime,
    // essentially acting as an additional safety mechanism in
    // case something goes wrong and we need to disable it:</span>
    <span class="s-keyword">guard</span> featureFlags.<span class="s-property">enablePromotion</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span>
    }

    <span class="s-comment">// We can now use iOS 13-only APIs without any problems:</span>
    <span class="s-keyword">let</span> view = <span class="s-type">PromotionView</span>()
    <span class="s-keyword">let</span> viewController = <span class="s-type">UIHostingController</span>(rootView: view)
    presentingViewController.<span class="s-call">present</span>(viewController, animated: <span class="s-keyword">true</span>)
}</code></pre><p class="info">To learn more about feature flags, check out <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift/">“Feature flags in Swift”</a>.</p><p>Deploying a feature like the above feature in production, and monitoring the results over a period of time, perhaps gives us the very best indication as to whether or not a given piece of technology is something that’s ready for us to fully adopt. Doing so also lets us start working out how to integrate the new tool with the rest of our code base in a highly encapsulated way — which is great in case we decide to not adopt the new tool after all, as it should let us delete our experimental code quite quickly.</p><h2>Where’s the escape hatch?</h2><p>When adopting new technologies, chances are quite high that we’ll discover gaps in what their various APIs offer — especially when compared to older tools that the new ones are aiming to replace. No matter how great a new piece of technology is, building out a diverse set of APIs that cover a lot of ground takes time — which is definitely something that we need to take into account when picking what technologies to adopt.</p><p>One thing that creators of tools and frameworks can do to mitigate this problem, however, is to build in some form of <em>“escape hatch”</em> — that enables us to temporarily step outside the realm of the tool in order to complete a given task. Having such a mechanism available heavily reduces the chance that we’ll get stuck while adopting that technology, and also future-proofs it, as we’ll be able to extend it to better fit our use case.</p><p>Again using SwiftUI as an example — since it’s fully backward compatible with both UIKit and AppKit, that essentially acts as such an escape hatch. If we encounter something that’s missing in SwiftUI, or if we want to bring some of our existing code into it, we can do so by adopting <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match/"><code>UIViewRepresentable</code></a>. Since we can also freely mix and match SwiftUI-based view controllers with UIKit-based ones, we can selectively adopt SwiftUI for the parts of our UI that it works great for — while still falling back to UIKit (or AppKit on the Mac) whenever needed:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-comment">// This view controller is implemented using UIKit:</span>
        <span class="s-keyword">let</span> header = <span class="s-type">HeaderViewController</span>()
        ...
        <span class="s-call">add</span>(header)

        <span class="s-comment">// While this one is implemented using SwiftUI:</span>
        <span class="s-keyword">let</span> list = <span class="s-type">ListView</span>()
        <span class="s-keyword">let</span> listWrapper = <span class="s-type">UIHostingController</span>(rootView: list)
        ...
        <span class="s-call">add</span>(listWrapper)
    }
}</code></pre><p class="info">To see the implementation of the above <code>add</code> convenience API for managing child view controllers, check out <a href="https://www.swiftbysundell.com/basics/child-view-controllers">this Basics article</a>.</p><p>Whether or not a given tool supports some form of escape hatch-like mechanism, and how much flexibility that it gives us, is also something that we’ll be able to gradually discover by adopting it slowly — feature by feature.</p><h2>Conclusion</h2><p>It’s close to impossible to universally assert that any new tool, library or framework is fully ready for all kinds of use cases out of the gate — as how well any new piece of technology will work depends highly on the context that it’ll be used it. However, by learning from others’ experience, by taking our time to experiment and try out the tool for ourselves, and by making sure that any new technologies that we choose to adopt has some way for us to temporarily work around its limits — we can greatly increase our chances of success, even if we choose to become early adopters.</p><p>It’s also important to point out that <em>not</em> being an early adopter is also a perfectly valid choice — and in many circumstances it’s even the <em>right</em> choice. New technologies will most likely <em>always</em> have problems, and while they might be exciting and fun to use, there’s rarely any harm in being a bit more conservative with our tech choices — especially when working on a larger, existing code base. Like always, it’s all about finding the right balance between moving our tech stack forward, without running into too many problems along the way.</p><p>To learn more about SwiftUI in particular, and how Apple is both using it internally, as well as some of their plans for improving it — make sure to listen to my <a href="https://www.swiftbysundell.com/podcast/59/">podcast interview with Josh Shaffer</a>, engineering director with the UIKit and SwiftUI team.</p><p>What do you think? How do you usually decide whether a given technology is production-ready, and what do you think about the suggestions in this article? Let me know — along with any questions, comments and feedback that you might have — either <a href="https://www.swiftbysundell.com/contact">via email</a> or <a href="https://twitter.com/johnsundell">on Twitter</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/pragmatic-unit-testing-in-swift</guid><title>Pragmatic unit testing in Swift</title><description>This week, let’s take a look at a few different ways to deploy unit testing in a more pragmatic manner — to use testing to solve immediate problems, and to enable our code to be tested without having to fundamentally change it.</description><link>https://www.swiftbysundell.com/articles/pragmatic-unit-testing-in-swift</link><pubDate>Sun, 27 Oct 2019 21:40:00 +0100</pubDate><content:encoded><![CDATA[<p>It’s sometimes easy to think of the decision of whether or not to use unit testing as a binary one: either testing is fully embraced, and all of our project’s code refactored to be completely testable — or no testing will be done at all.</p><p>When faced with such a binary decision, it’s not very surprising that many teams opt for the latter of the two options — often because of time constraints, tight deadlines, and important new features that need shipping.</p><p>However, there’s really no reason to treat unit testing as such a big, binary decision. After all, any form of automated testing is <em>just another tool</em> that we can use to improve our code and the way we work with it. So this week, let’s take a look at a few different ways to deploy unit testing in a more pragmatic manner — to use testing to solve immediate problems, and to enable our code to be tested without having to fundamentally change it.</p><h2>Verifying bug fixes</h2><p>When starting to add unit tests to a project — or when wanting to extend the coverage of an existing, partial test suite — it can often be hard to decide where to start. Do we start by verifying the functionality that’s closest to the user and our app’s UI, and then work our way down the stack, or vice versa?</p><p>Rather than having to search for the perfect starting point, a great way to get into the habit of unit testing changes to a code base is to start by using tests to verify bug fixes. Not only does that let us verify that we <em>actually</em> fixed the bug we were aiming to fix, it also lets us slowly but surely build up a solid suite of tests — all while improving the quality of our code at the same time.</p><p>As an example, let’s say that we’re working on an app that lets our users read various forms of written content. Historically, our app has only supported books and magazines, but we’ve recently also added support for newspapers — with those three types of content being represented using this enum:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">enum</span> Kind {
        <span class="s-keyword">case</span> book
        <span class="s-keyword">case</span> magazine
        <span class="s-keyword">case</span> newspaper
    }
}</code></pre><p>Now let’s say that when shipping the newspaper feature, we started getting reports from users that no newspapers ever show up within the app’s <em>“Recommended”</em> section — which turns out to be a bug caused by the following code:</p><pre class="splash"><code><span class="s-keyword">struct</span> RecommendedItems {
    <span class="s-keyword">var</span> books = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> magazines = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> newspapers = [<span class="s-type">Item</span>]()

    <span class="s-keyword">func</span> items(ofKind kind: <span class="s-type">Item</span>.<span class="s-type">Kind</span>) -&gt; [<span class="s-type">Item</span>] {
        <span class="s-keyword">if</span> kind == .<span class="s-dotAccess">book</span> {
            <span class="s-keyword">return</span> books
        } <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> magazines
        }
    }
}</code></pre><p>The problem is that we’re making the assumption that if the requested <code>Item.Kind</code> isn’t <code>.book</code>, then that must mean that we should return magazines — which might’ve made total sense when that code was written (since at that point, books and magazines were the only two kinds of items that we supported).</p><p>While we could of course simply fix the above bug and move on, let’s use it as an opportunity to add a test that’ll ensure that things will keep working in the future. So <em>before</em> we implement our fix, let’s add a test for it — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> RecommendedItemsTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRecommendedNewspapers() {
        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(
            kind: .<span class="s-dotAccess">newspaper</span>,
            id: <span class="s-string">"nytimes"</span>,
            name: <span class="s-string">"The New York Times"</span>
        )

        <span class="s-keyword">let</span> recommended = <span class="s-type">RecommendedItems</span>(newspapers: [item])

        <span class="s-call">XCTAssertEqual</span>(
            recommended.<span class="s-call">items</span>(ofKind: .<span class="s-dotAccess">newspaper</span>),
            [item]
        )
    }
}</code></pre><p>The above test will currently fail, which is great, as it reproduces the problem that our users have been facing. With that failing test in place, let’s now actually fix the bug, by turning our original <code>if/else</code> statements into a <code>switch</code> in order to handle all cases (which’ll also give us a compile time error if we ever end up with an unhandled case again):</p><pre class="splash"><code><span class="s-keyword">struct</span> RecommendedItems {
    <span class="s-keyword">var</span> books = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> magazines = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> newspapers = [<span class="s-type">Item</span>]()

    <span class="s-keyword">func</span> items(ofKind kind: <span class="s-type">Item</span>.<span class="s-type">Kind</span>) -&gt; [<span class="s-type">Item</span>] {
        <span class="s-keyword">switch</span> kind {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">book</span>: <span class="s-keyword">return</span> books
        <span class="s-keyword">case</span> .<span class="s-dotAccess">magazine</span>: <span class="s-keyword">return</span> magazines
        <span class="s-keyword">case</span> .<span class="s-dotAccess">newspaper</span>: <span class="s-keyword">return</span> newspapers
        }
    }
}</code></pre><p>With the above fix in place, our test will now pass — and we’re ready to submit our patch! Not only does the above approach give us a greater degree of confidence when fixing bugs, it also lets us make sure that the same bug won’t happen twice, since if we ever end up causing the same regression again — our test will now tell us about it.</p><h2>Safeguarding against future errors</h2><p>While the above kind of bug-fixing tests are incredibly useful, they’re written in reaction to a bug that was <em>already caused</em>, and only protects us against the exact same regression. So let’s see if we can take things one step further, while we’re already working on this part of the code base, to give ourselves a much stronger safeguard against related regressions as well.</p><p>To do that in this case, let’s add a test that’ll make sure that our <code>RecommendedItems</code> type will <em>always</em> be capable of returning items for <em>any</em> <code>Item.Kind</code>. We’ll start by making our <code>Item.Kind</code> enum conform to <code>CaseIterable</code> — which will let us iterate over its cases:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span>.<span class="s-type">Kind</span>: <span class="s-type">CaseIterable</span> {}</code></pre><p class="info">For more information on <code>CaseIterable</code>, check out <a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42">“Enum iterations in Swift”</a>.</p><p>Next, let’s make it slightly easier to create stubbed <code>Item</code> values (instances that we create purely for testing reasons), by adding the following extension to our unit testing target:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">static func</span> stub(ofKind kind: <span class="s-type">Kind</span>, id: <span class="s-type">Item</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Item</span> {
        <span class="s-keyword">return</span> <span class="s-type">Item</span>(kind: kind, id: id, name: <span class="s-string">"</span>\(kind)<span class="s-string">-</span>\(id)<span class="s-string">"</span>)
    }
}</code></pre><p class="info">For much more advanced ways of stubbing values, check out <a href="https://www.swiftbysundell.com/articles/defining-testing-data-in-swift">“Defining testing data in Swift”</a>.</p><p>With those two small extensions in place, we’re now ready to write our test, which will iterate over all cases within <code>Item.Kind</code> in order to make sure that there’s a recommended item defined for each kind — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> RecommendedItems: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testItemsForAllKinds() {
        <span class="s-keyword">let</span> book = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">book</span>, id: <span class="s-string">"book"</span>)
        <span class="s-keyword">let</span> magazine = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">magazine</span>, id: <span class="s-string">"magazine"</span>)
        <span class="s-keyword">let</span> newspaper = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">newspaper</span>, id: <span class="s-string">"newspaper"</span>)

        <span class="s-keyword">let</span> recommended = <span class="s-type">RecommendedItems</span>(
            books: [book],
            magazines: [magazine],
            newspapers: [newspaper]
        )

        <span class="s-keyword">for</span> kind <span class="s-keyword">in</span> <span class="s-type">Item</span>.<span class="s-type">Kind</span>.<span class="s-property">allCases</span> {
            <span class="s-keyword">let</span> items = recommended.<span class="s-call">items</span>(ofKind: kind)

            <span class="s-keyword">switch</span> kind {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">book</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [book])
            <span class="s-keyword">case</span> .<span class="s-dotAccess">magazine</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [magazine])
            <span class="s-keyword">case</span> .<span class="s-dotAccess">newspaper</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [newspaper])
            }
        }
    }
}</code></pre><p>The above test might be simple, but it gives us a much stronger guarantee that the way we keep track of recommended items within our app will keep working as we iterate on our code — even if we might yet again add support for a new content type in the future.</p><h2>Pragmatic refactoring</h2><p>While writing tests for the above kind of synchronous model code is often quite straightforward, things tend to get increasingly difficult and tricky as we enter the domain of asynchronous code — especially if the code in question wasn’t written with testing in mind.</p><p>For example, let’s say that we wanted to write a test to verify that a boolean flag is correctly stored in our app’s <code>UserDefaults</code> when the user successfully completes our onboarding process. All of that code currently lives inside of a <code>OnboardingViewController</code>, and looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">func</span> finishOnboarding() {
        <span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(
            with: .<span class="s-dotAccess">onboardingFinishedEndpoint</span>
        ) { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_</span>, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>.<span class="s-call">async</span> {
                <span class="s-keyword">guard let self</span> = <span class="s-keyword">self else</span> { <span class="s-keyword">return</span> }

                <span class="s-keyword">if let</span> error = error {
                    <span class="s-type">ErrorPresenter</span>.<span class="s-property">shared</span>.<span class="s-call">present</span>(error, in: <span class="s-keyword">self</span>)
                    <span class="s-keyword">return</span>
                }

                <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">setValue</span>(<span class="s-keyword">true</span>,
                    forKey: <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>
                )

                <span class="s-keyword">self</span>.<span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
            }
        }

        task.<span class="s-call">resume</span>()
    }
}</code></pre><p>As it currently stands, writing tests for the above code will be quite difficult. The main problem is that singletons are used to access <code>URLSession</code>, <code>ErrorPresenter</code> and <code>UserDefaults</code>, which will make it hard (or even impossible) for us to take control over those instances within our tests, in order to verify our functionality in a predictable way. Ideally we’d like those <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependencies to be injected</a>, so that we’d be able to <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mock them</a>.</p><p>However, completely refactoring <code>OnboardingViewController</code> to fully support dependency injection (and to also abstract our dependencies to the extent that they can be fully mocked) will most likely be a huge task — so let’s see if we can find a way to enable us to test our functionality with only a minor set of tweaks.</p><p>One way to do so is to encapsulate our view controller’s dependencies using functions, and then define a struct that contains all of those functions — like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OnboardingDependencies {
    <span class="s-comment">// Our networking code, modeled as a function that takes
    // a URL and a completion handler, and then calls the
    // underlying URLSession:</span>
    <span class="s-keyword">var</span> networking: (<span class="s-type">URL</span>, <span class="s-keyword">@escaping</span> (<span class="s-type">Error</span>?) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Void</span> = {
        url, handler <span class="s-keyword">in

        let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) {
            <span class="s-keyword">_</span>, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            
            <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>.<span class="s-call">async</span> {
                <span class="s-call">handler</span>(error)
            }
        }

        task.<span class="s-call">resume</span>()
    }

    <span class="s-comment">// Our error presenting function can be directly referenced,
    // since Swift supports first class functions:</span> 
    <span class="s-keyword">var</span> errorPresenting = <span class="s-type">ErrorPresenter</span>.<span class="s-property">shared</span>.<span class="s-property">present</span>

    <span class="s-comment">// Our key/value persistence code, which we turn into
    // a function that wraps our app's standard UserDefaults:</span>
    <span class="s-keyword">var</span> keyValuePesistance: (<span class="s-type">String</span>, <span class="s-type">Bool</span>) -&gt; <span class="s-type">Void</span> = {
        <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">setValue</span>($1, forKey: $0)
    }
}</code></pre><p>With the above in place, we can now define a new <code>dependencies</code> property within our view controller, and simply call the above functions in order to access our dependencies’ functionality:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> dependencies = <span class="s-type">OnboardingDependencies</span>()
    
    ...

    <span class="s-keyword">func</span> finishOnboarding() {
        dependencies.<span class="s-call">networking</span>(.<span class="s-dotAccess">onboardingFinishedEndpoint</span>) {
            [<span class="s-keyword">weak self</span>] error <span class="s-keyword">in

            guard let self</span> = <span class="s-keyword">self else</span> { <span class="s-keyword">return</span> }

            <span class="s-keyword">if let</span> error = error {
                <span class="s-keyword">self</span>.<span class="s-property">dependencies</span>.<span class="s-call">errorPresenting</span>(error, <span class="s-keyword">self</span>)
                <span class="s-keyword">return</span>
            }

            <span class="s-keyword">self</span>.<span class="s-property">dependencies</span>.<span class="s-call">keyValuePesistance</span>(
                <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>,
                <span class="s-keyword">true</span>
            )

            <span class="s-keyword">self</span>.<span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
        }
    }
}</code></pre><p>The above might not be our ideal way of doing dependency injection, but it works remarkably well, and doesn’t require any modifications to our view controller’s API — nor to any of its dependencies. We don’t need to define any new protocols, or fundamentally change our code, but we’ve still enabled the above function to be fully tested.</p><p>To do just that, we’ll simply create an instance of <code>OnboardingViewController</code>, and then override the dependency functions that we wish to take control over. Here’s how we might do that to write the test that we originally set out to add — which verifies that the correct flag is persisted when the user finishes the onboarding process:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewControllerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testPersistingOnboardingFinished() {
        <span class="s-keyword">let</span> vc = <span class="s-type">OnboardingViewController</span>()
        <span class="s-keyword">var</span> persistance: (key: <span class="s-type">String</span>, value: <span class="s-type">Bool</span>)?

        <span class="s-comment">// Hard-wire our networking function to always
        // return a nil error when called:</span>
        vc.<span class="s-property">dependencies</span>.<span class="s-property">networking</span> = { <span class="s-keyword">_</span>, handler <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(<span class="s-keyword">nil</span>)
        }

        <span class="s-comment">// Override our view controller's key/value persistance
        // function in order to capture its input:</span>
        vc.<span class="s-property">dependencies</span>.<span class="s-property">keyValuePesistance</span> = {
            persistance = ($0, $1)
        }

        vc.<span class="s-call">finishOnboarding</span>()

        <span class="s-comment">// Verify that the correct key and value were persisted:</span>
        <span class="s-call">XCTAssertEqual</span>(persistance?.<span class="s-property">key</span>, <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>)
        <span class="s-call">XCTAssertEqual</span>(persistance?.<span class="s-property">value</span>, <span class="s-keyword">true</span>)
    }
}</code></pre><p>Pretty cool! While our primary goal might’ve been to make <code>OnboardingViewController</code> testable, as an added bonus, we’ve now also made that class both simpler and more flexible — since it no longer has any strong coupling to its dependencies.</p><h2>Conclusion</h2><p>While unit testing might initially seem like a very big deal — something that will require months of refactoring work before a single test can be written — that’s rarely the case. While we might need to perform <em>some</em> modifications to certain parts of our code base in order to test it, those changes can often be done in a fully backward compatible manner, and in a way that takes just a short amount of time to implement.</p><p>At the end of the day, unit testing is not a way of life, nor will it completely remove the need for manual testing, or magically make an app error-free — it’s just a tool like any other. A tool that — if tactically and thoughtfully deployed — can help us verify bug fixes, prevent many kinds of future errors, and ensure that our code keeps working as intended as we add new features and capabilities.</p><p>What do you think? Do you already use some of the techniques within this article, or will you try them out? Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-key-paths-in-switch-statements</guid><title>Tip: Using key paths in switch statements</title><description>How to enable key paths to be used in switch statements, and within any other context that supports pattern matching.</description><link>https://www.swiftbysundell.com/tips/using-key-paths-in-switch-statements</link><pubDate>Wed, 23 Oct 2019 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>One of Swift’s lesser known, but incredibly powerful language features is how the <code>~=</code> operator lets us implement custom pattern matching variants between different types. Those new pattern matching capabilities can then be used in <code>switch</code> statements, when using <code>if case</code> syntax, or within any other context in which pattern matching is supported.</p><p>Here’s how we could use that language feature to define a <code>~=</code> overload that matches a boolean <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key path</a> into a type against an instance of that type:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;, rhs: <span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span> {
    rhs[keyPath: lhs]
}</code></pre><p>With the above in place, we can now simply use a key path to define a pattern, and mix those patterns freely with those that match against a value — which is really useful when using a <code>switch</code> statement to decide how to parse or handle a given value:</p><pre class="splash"><code><span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> character: <span class="s-type">Character</span>) {
    <span class="s-keyword">switch</span> character {
    <span class="s-keyword">case</span> <span class="s-string">"&lt;"</span>:
        <span class="s-call">parseElement</span>()
    <span class="s-keyword">case</span> <span class="s-string">"#"</span>:
        <span class="s-call">parseHashtag</span>()
    <span class="s-keyword">case</span> \.<span class="s-property">isNumber</span>:
        <span class="s-call">parseNumber</span>()
    <span class="s-keyword">case</span> \.<span class="s-property">isNewline</span>:
        <span class="s-call">startNewLine</span>()
    <span class="s-keyword">default</span>:
        <span class="s-call">parseAnyCharacter</span>()
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/default-arguments-in-swift</guid><title>Default arguments in Swift</title><description>When designing APIs, using default arguments can often let us strike a nice balance between flexibility and ease of use — as they let us add solid, intuitive defaults to many of the configuration options that we’ll end up providing. Let’s take a look at a few examples of how they may be used.</description><link>https://www.swiftbysundell.com/articles/default-arguments-in-swift</link><pubDate>Sun, 20 Oct 2019 13:30:00 +0200</pubDate><content:encoded><![CDATA[<p>A major part of designing powerful, flexible APIs that still feel lightweight and easy to use, is deciding what aspects to make user-configurable. On one hand, the more configuration options that we add, the more versatile an API becomes — but on the other hand, it might also make it more complicated and harder to understand.</p><p>That’s what makes <em>default arguments</em> such a great tool in Swift — as they let us add solid, intuitive defaults to many of the configuration options that we’ll end up providing. That way we can often strike a nice balance between flexibility and ease of use, and this week, let’s take a look at a few examples of how we might do just that.</p><h2>Making the easy path the right path</h2><p>One of the key ways that a project can be made more maintainable (especially as it grows in size, both code-wise and team-wise), is by ensuring that the easiest way to accomplish a certain task is also <em>the right way to do it</em>. It’s so common for highly similar functionality to be accidentally re-implemented multiple times by different developers, simply because there was no simple, shared abstraction available to use.</p><p>For example, let’s say that we wanted to make an effort to unify the durations used for various animations across an app. To make that happen, our goal needs to be to create a <em>simpler</em> API than what the system provides out of the box, so that all members of our team (including ourselves) will continuously choose to use that new API over the default one. In this case, we might build something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-comment">// Here we use a default argument to define what we want
    // our unified, default animation duration to be:</span>
    <span class="s-keyword">func</span> animate(withDuration duration: <span class="s-type">TimeInterval</span> = <span class="s-number">0.3</span>,
                 animations: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: duration,
                       animations: animations)
    }
}</code></pre><p class="info">We scope the above function to <code>UIResponder</code> (which both <code>UIView</code> and <code>UIViewController</code> are subclasses of), to avoid getting it as an autocompletion suggestion within non-UI contexts.</p><p>With the above in place, most animation code will — over time— most likely end up simply looking like this:</p><pre class="splash"><code><span class="s-call">animate</span> {
    button.<span class="s-property">frame</span>.<span class="s-property">size</span> = <span class="s-type">CGSize</span>(width: <span class="s-number">100</span>, height: <span class="s-number">100</span>)
}</code></pre><p>That’s great, both for readability, and since we’ll now have a single source of truth for the duration of all of our default animations. Equally important, however, is that our new default can easily be overridden — simply by specifying a value for that argument at the call site:</p><pre class="splash"><code><span class="s-call">animate</span>(withDuration: <span class="s-number">2</span>) {
    button.<span class="s-property">frame</span>.<span class="s-property">size</span> = <span class="s-type">CGSize</span>(width: <span class="s-number">100</span>, height: <span class="s-number">100</span>)
}</code></pre><p>Besides providing a great way to standardize various values across a code base, default arguments can also enable us to <a href="https://www.swiftbysundell.com/articles/designing-swift-apis">design more scalable APIs</a> — by making increasingly complex use cases and customization possible, without requiring all API users to take on that added complexity.</p><p>For example, here’s how we might extend our simplified animation API to support a much larger set of parameters — while still keeping the default use case as simple as possible:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-keyword">func</span> animate(withDuration duration: <span class="s-type">TimeInterval</span> = <span class="s-number">0.3</span>,
                 delay: <span class="s-type">TimeInterval</span> = <span class="s-number">0</span>,
                 options: <span class="s-type">UIView</span>.<span class="s-type">AnimationOptions</span> = .<span class="s-dotAccess">curveEaseInOut</span>,
                 animations: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: duration,
                       delay: delay,
                       options: options,
                       animations: animations)
    }
}</code></pre><p>That’s really what makes default arguments so incredibly useful — they let us keep expanding our APIs to make them increasingly more powerful and flexible, in a way that won’t impact any of our code that doesn’t need to take advantage of those new capabilities.</p><h2>The importance of being obvious</h2><p>However, when deciding what values to turn into defaults, it’s always important to consider whether a given default will end up becoming intuitive to our API users. After all, the best kind of defaults are those that <em>feel obvious</em>, since it’ll help us avoid misunderstandings and bugs caused by an API doing something that we didn’t expect.</p><p>For example, let’s say that we’ve written a function for storing a given value in a local database, and that we enable the API user to decide how to handle conflicts — whenever a similar value already exists within that database. In an attempt to make our API as simple as possible, we’ve again specified a default argument — like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> ConflictResolution {
    <span class="s-keyword">case</span> overwriteExisting
    <span class="s-keyword">case</span> stopIfExisting
    <span class="s-keyword">case</span> askUser
}

<span class="s-keyword">func</span> store&lt;T: <span class="s-type">Storable</span>&gt;(
    <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
    conflictResolution: <span class="s-type">ConflictResolution</span> = .<span class="s-dotAccess">stopIfExisting</span>
) <span class="s-keyword">throws</span> {
    ...
}</code></pre><p>Doing the above may at first seem like a good idea, but if we think about it, it’s not really <em>obvious</em> that calling our function without explicitly specifying a <code>ConflictResolution</code> will result in no value being stored if our database already contains an existing one. By simply calling <code>try store(value)</code>, we’d expect a value to actually be stored, but at the same time — we wouldn’t want to make <code>overwriteExisting</code> the default either, as that could result in unexpected data loss.</p><p>In this type of situation, when there’s really no obvious default to be found, it might be better to simply define a separate function if we want to provide some form of convenience API. For example, here’s how we might create a <code>storeIfNeeded</code> function to be able to easily store a value only if a similar one doesn’t already exist:</p><pre class="splash"><code><span class="s-keyword">func</span> storeIfNeeded&lt;T: <span class="s-type">Storable</span>&gt;(<span class="s-keyword">_</span> value: <span class="s-type">T</span>) <span class="s-keyword">throws</span> {
    <span class="s-keyword">try</span> <span class="s-call">store</span>(value, conflictResolution: .<span class="s-dotAccess">stopIfExisting</span>)
}</code></pre><p>So while default arguments are really useful in many kinds of situations, they’re not the <em>only</em> way to define convenience APIs, and like with so many other things — it all comes down to picking the right tool for the job within each given context.</p><h2>Retrofitted dependency injection</h2><p>Default arguments can also provide a great way to retrofit a given type or function with <em><a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependency injection</a></em>. Like we’ve taken a look at in <a href="https://www.swiftbysundell.com/tags/dependency-injection">previous articles</a> — injecting our code-level dependencies, rather than relying on singletons, is often key to writing more well-structured and testable code. However, completely refactoring a code base to introduce dependency injection everywhere can be a huge task — but thankfully, default arguments can enable us to perform those changes in a step-by-step fashion.</p><p>Let’s say that our code base makes heavy use of a <code>FileLoader</code> class — that currently accesses its underlying <code>FileManager</code>, as well as a globally shared <code>Cache</code>, as singletons. That does have <em>some</em> benefits, as it lets us simply initialize a <code>FileLoader</code> from anywhere, without having to worry about its dependencies. However, it also makes it much harder to both unit test that class, and to get a clear overview of what kind of dependencies that it has.</p><p>The good news is that by simply transforming the way we access those singletons to instead become default initializer arguments, we can both improve our type’s structure, and also make it a lot more testable — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> FileLoader {
    <span class="s-keyword">private let</span> fileManager: <span class="s-type">FileManager</span>
    <span class="s-keyword">private let</span> cache: <span class="s-type">Cache</span>

    <span class="s-keyword">init</span>(fileManager: <span class="s-type">FileManager</span> = .<span class="s-dotAccess">default</span>,
         cache: <span class="s-type">Cache</span> = .<span class="s-dotAccess">shared</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">fileManager</span> = fileManager
        <span class="s-keyword">self</span>.<span class="s-property">cache</span> = cache
    }
}</code></pre><p>Since we’ve now parameterized all of our file loader’s dependencies, they can much more easily be <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mocked</a> or <a href="https://www.swiftbysundell.com/articles/defining-testing-data-in-swift">stubbed</a> within our tests. For example, here’s how we might replace our app’s default <code>Cache</code> with one that automatically empties itself each time that our tests are run:</p><pre class="splash"><code><span class="s-keyword">let</span> loader = <span class="s-type">FileLoader</span>(cache: .<span class="s-dotAccess">autoEmptyingForTests</span>)</code></pre><p>For more info on unit testing, check out <a href="https://www.swiftbysundell.com/basics/unit-testing">this Basics article</a>, as well as this site’s many other <a href="https://www.swiftbysundell.com/tags/unit-testing">articles and podcast episodes</a> on that topic.</p><h2>Associated values within enums</h2><p>Finally, let’s take a look at a new <em>“flavor”</em> of default arguments that was added as part of Swift 5.1 — default associated values for enum cases.</p><p>Let’s say that we’re building a Swift library for creating XML documents. Since XML is a tree-like format in which all data is defined using nodes that come in a finite number of variations, we might choose to model each such node using an <code>XMLNode</code> enum that looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> XMLNode {
    <span class="s-comment">// A standard element, which can contain child elements:</span>
    <span class="s-keyword">case</span> element(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>],
        children: [<span class="s-type">XMLNode</span>]
    )
    <span class="s-comment">// A "void" element that closes itself, and can't have children:</span>
    <span class="s-keyword">case</span> voidElement(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>]
    )
    <span class="s-comment">// An inline piece of text, defined as a child node:</span>
    <span class="s-keyword">case</span> text(<span class="s-type">String</span>)
}</code></pre><p>Before Swift 5.1, using the above kind of approach did come with a quite major tradeoff, in that no default arguments could be defined. So even if we just wanted to create an empty (but still non-void) element, we’d still have to pass all associated values for that case:</p><pre class="splash"><code><span class="s-keyword">let</span> emptyItems = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(
    name: <span class="s-string">"items"</span>,
    attributes: [],
    children: []
)</code></pre><p>While we could’ve extended <code>XMLNode</code> with convenience APIs that would’ve filled in those empty defaults for us, we no longer have to — as we’re now able to define default arguments for associated enum values as well, exactly the same way as we do for function arguments:</p><pre class="splash"><code><span class="s-keyword">enum</span> XMLNode {
    <span class="s-keyword">case</span> element(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>] = [],
        children: [<span class="s-type">XMLNode</span>] = []
    )
    <span class="s-keyword">case</span> voidElement(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>] = []
    )
    <span class="s-keyword">case</span> text(<span class="s-type">String</span>)
}</code></pre><p>With the above change in place, our <code>XMLNode</code> API immediately becomes a lot more flexible — as we can now define all sorts of nodes, simply by using the above enum type:</p><pre class="splash"><code><span class="s-keyword">let</span> emptyItems = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(name: <span class="s-string">"items"</span>)
<span class="s-keyword">let</span> link = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(name: <span class="s-string">"link"</span>, children: [.<span class="s-call">text</span>(url)])
<span class="s-keyword">let</span> metadata = <span class="s-type">XMLNode</span>.<span class="s-call">voidElement</span>(name: <span class="s-string">"meta"</span>, attributes: metadataAttributes)</code></pre><p>Pretty cool! Especially for structures and models used to define data, using default values can be really powerful, as the granularity of any kind of data tends to vary quite a lot from use case to use case.</p><h2>Conclusion</h2><p>When deployed to provide a solid set of obvious and consistent defaults for an API, default arguments can be incredibly powerful. They can make our APIs feel so much more lightweight, and enable the callers of those APIs to ease their way into using them — by starting out simple, and then customizing and overriding the defaults values as needed.</p><p>Default arguments can also provide a way to easily retrofit an existing type or function with dependency injection, and to make enums a lot more flexible.</p><p>But we also have to be careful not to make too many assumptions when defining our default arguments. Because at the end of the day, even though defaults and strong conventions are incredibly useful, a non-obvious default is arguably much worse than having no default at all.</p><p>What do you think? How do you usually use default arguments, and what guiding principles do you think are good to keep in mind when deciding what value to turn into a default. Let me know — along with your questions, comments and feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/omitting-the-return-keyword</guid><title>Tip: Omitting the return keyword</title><description></description><link>https://www.swiftbysundell.com/tips/omitting-the-return-keyword</link><pubDate>Mon, 14 Oct 2019 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><strong>New in Swift 5.1:</strong> The <code>return</code> keyword can now be omitted when declaring functions and computed properties that only contain a single expression, which is really nice when declaring simpler convenience APIs:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">MarkdownReader</span> {
    <span class="s-keyword">var</span> isAtStart: <span class="s-type">Bool</span> { index == string.<span class="s-property">startIndex</span> }
    <span class="s-keyword">var</span> didReachEnd: <span class="s-type">Bool</span> { index == string.<span class="s-property">endIndex</span> }
    <span class="s-keyword">var</span> currentCharacter: <span class="s-type">Character</span> { string[index] }
    
    <span class="s-keyword">func</span> encodeCurrentCharacter() -&gt; <span class="s-type">String</span> {
        currentCharacter.<span class="s-call">encoded</span>()
    }
}</code></pre><p>While this new behavior might take a little while to get used to, it matches the way <a href="https://www.swiftbysundell.com/basics/closures">closures</a> work, which does result in improved consistency between properties, methods, and closures:</p><pre class="splash"><code><span class="s-comment">// Here's how the above 'isAtStart' property might have been
// declared as a closure instead, prior to Swift 5.1:</span>
<span class="s-keyword">let</span> isAtStart: () -&gt; <span class="s-type">Bool</span> = { index == string.<span class="s-property">startIndex</span> }</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift</guid><title>Encapsulating configuration code in Swift</title><description>Let’s take a look at a few different techniques that can let us achieve a nice balance between code reuse and configurability, by building lightweight abstractions that enable us to encapsulate our configuration code.</description><link>https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift</link><pubDate>Sun, 13 Oct 2019 19:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Striking a nice balance between code reuse and configurability can often be quite challenging. While we’d ideally like to avoid repeating code and accidentally creating multiple sources of truth, much of how our various objects and values need to be configured tends to be dependent on the context that they’re used in.</p><p>This week, let’s take a look at a few different techniques that can let us achieve such a balance — by building lightweight abstractions that enable us to encapsulate our configuration code, and how those abstractions can then be shared across a code base to also increase its level of consistency.</p><h2>Building components, rather than screens</h2><p>When doing any kind of software development, it often helps to slice a program up into various parts, in order to be able to deal with them as separate units. For UI-heavy applications, such as iOS and Mac apps, it’s often tempting to do that kind of slicing based on the various screens that make up the app. For example, a shopping app might have a product screen, a list screen, a search screen, and so on.</p><p>While that kind of screen-level slicing makes a lot of sense from a high-level perspective (especially since it matches the way we tend to discuss our apps with other collaborators — like testers and designers), it tends to result in UI code that needs to be quite heavily configured for each screen.</p><p>Take this <code>ProductViewController</code> for example, which contains a buy button, as well as views for displaying details and related items for each product — all of which are configured within the view controller’s <code>viewDidLoad</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> product: <span class="s-type">Product</span>
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        <span class="s-comment">// Buy button</span>
        <span class="s-keyword">let</span> buyButton = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        buyButton.<span class="s-call">setImage</span>(.<span class="s-dotAccess">buy</span>, for: .<span class="s-dotAccess">normal</span>)
        buyButton.<span class="s-property">backgroundColor</span> = .<span class="s-dotAccess">systemGreen</span>
        buyButton.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped),
            for: .<span class="s-dotAccess">touchUpInside</span>
        )
        view.<span class="s-call">addSubview</span>(buyButton)
        
        <span class="s-comment">// Product detail view</span>
        <span class="s-keyword">let</span> productDetailView = <span class="s-type">UIView</span>()
        ...
        
        <span class="s-comment">// Related products view</span>
        <span class="s-keyword">let</span> relatedProductsView = <span class="s-type">UIView</span>()
        ...
    }
}</code></pre><p>Even though we’ve attempted to make the above code a bit easier to read by adding a comment before each configuration block, our current <code>viewDidLoad</code> implementation does arguably suffer from a lack of structure. Since all of our configuration happens in one place, it’s easy for variables to be accidentally used in the wrong context, and for our code to become increasingly intertwined as time goes on.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">“Writing self-documenting Swift code”</a></em>, one way to mitigate the above problem is to simply break out the different parts of our configuration code into separate methods, which <code>viewDidLoad</code> can then call:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ProductViewController</span> {
    <span class="s-keyword">func</span> setupBuyButton() {
        <span class="s-keyword">let</span> buyButton = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        ...
    }

    <span class="s-keyword">func</span> setupProductDetailView() {
        <span class="s-keyword">let</span> productDetailView = <span class="s-type">UIView</span>()
        ...
    }

    <span class="s-keyword">func</span> setupRelatedProductsView() {
        <span class="s-keyword">let</span> relatedProductsView = <span class="s-type">UIView</span>()
        ...
    }
}</code></pre><p>While the above approach does solve our structural problem, and definitely makes our code more <em>self-documenting</em> and easier to read, it still strongly couples our individual view components with their presenting container — <code>ProductViewController</code> in this case.</p><p>That’s probably not a problem for one-off views that are currently only used within a single view controller, but for more general-purpose UI code, it’d be nice if we were able to easily reuse our various configurations across our code base.</p><p>One way to do so, which doesn’t require any new types to be defined, is to use <em><a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods</a></em> — which enable us to encapsulate the way we configure each view, in a way that’s both easy to define, and easy to use:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">static func</span> buyButton(withTarget target: <span class="s-type">Any</span>, action: <span class="s-type">Selector</span>) -&gt; <span class="s-type">UIButton</span> {
        <span class="s-keyword">let</span> button = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        button.<span class="s-call">setImage</span>(.<span class="s-dotAccess">buy</span>, for: .<span class="s-dotAccess">normal</span>)
        button.<span class="s-property">backgroundColor</span> = .<span class="s-dotAccess">systemGreen</span>
        button.<span class="s-call">addTarget</span>(target, action: action, for: .<span class="s-dotAccess">touchUpInside</span>)
        <span class="s-keyword">return</span> button
    }
}</code></pre><p>The beauty of static factory methods is that they enable us to call our APIs in a way that’s similar to enums — using Swift’s very lightweight <em>dot syntax</em>. If we’d also define similar methods as the above one for creating a <em>buy button</em>, then we could end up with a <code>viewDidLoad</code> implementation that simply looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> product: <span class="s-type">Product</span>
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">buyButton</span>(
            withTarget: <span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped)
        ))
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">productDetailView</span>(
            for: product
        ))
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">relatedProductsView</span>(
            for: product.<span class="s-property">relatedProducts</span>,
            delegate: <span class="s-keyword">self</span>
        ))
    }
}</code></pre><p>That’s really neat! Gone are the local variables, and we can still fit all of our view setup code within one method, while also giving us a much greater degree of encapsulation — and complete reusability, since we can now easily construct the above kind of views wherever we might need them.</p><h2>Multiple configuration steps</h2><p>While the above approach works great for UI configuration code that ideally should remain the same across our entire code base, such as setting up common components, we also often need to extend such configurations in a way that’s much more context-specific.</p><p>For example, we probably need to apply some form of layout to our views, to update or bind certain pieces of state to them, or otherwise customize their behaviors or appearance depending on the feature that they’re used in.</p><p>To make it easy to do so, let’s extend <code>UIView</code> with a convenience API — that simply executes a closure after adding a given view as a subview, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">@discardableResult
    func</span> add&lt;T: <span class="s-type">UIView</span>&gt;(<span class="s-keyword">_</span> subview: <span class="s-type">T</span>, then closure: (<span class="s-type">T</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">T</span> {
        <span class="s-call">addSubview</span>(subview)
        <span class="s-call">closure</span>(subview)
        <span class="s-keyword">return</span> subview
    }
}</code></pre><p>With the above method in place, we can now keep using that nice dot syntax to create our views, while still enabling us to apply context-specific configurations as well — for example in order to add a set of <a href="https://www.swiftbysundell.com/basics/layout-anchors">Auto Layout constraints</a>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        view.<span class="s-call">add</span>(.<span class="s-call">buyButton</span>(
            withTarget: <span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped)
        ), then: {
            <span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>([
                $0.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
                $0.<span class="s-property">trailingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">trailingAnchor</span>)
                ...
            ])
        })
        
        ...
    }
}</code></pre><p>Although the above syntax might take a while to get used to, it does sort of give us the best of both worlds — we’re now able to fully encapsulate both our global and local configurations, while also enforcing a certain degree of structure as well. It also lets us easily share view components among different screens, without requiring us to define any new <code>UIView</code> subclasses.</p><h2>A declarative structure</h2><p>What’s also interesting about the above approach is how it starts making our imperative UIKit-based code slightly more declarative — as we’re no longer continuously setting up our various views within our view controllers, but rather declaring what sort of configuration we wish to use. That sort of moves us closer to the world of <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a>, which could help ease our transition to that new world in the future.</p><p>Just compare how our <code>ProductViewController</code> might look if expressed as a SwiftUI view instead — structurally, it’s really quite similar to our above UIKit-based approach:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">BuyButton</span> {
                <span class="s-comment">// Handling code</span>
                ...
            }
            <span class="s-type">ProductDetailView</span>(product: product)
            <span class="s-type">RelatedProductsView</span>(products: product.<span class="s-property">relatedProducts</span>) {
                <span class="s-comment">// Handling code</span>
                ...
            }
        }
    }
}</code></pre><p>That of course doesn’t mean that we’ve automatically made our UIKit-based code SwiftUI-compatible, just by modifying its structure — but by using a similar way of thinking around how we organize our various view configurations, we can at least start to become more familiar with increasingly declarative coding styles.</p><h2>Configuration closures</h2><p>Although much of the configuration code that we write when developing UI-based apps tends to be centered around the view layer, other parts of our code base often needs to be quite heavily configured as well — especially logic that’s written directly on top of system APIs.</p><p>For example, let’s say that we’re building a type for parsing some form of metadata from a string, and that we’d like to use a shared <code>DateFormatter</code> among all instances of that type. To do that, we might define a private static property that is configured using a <em>self-executing closure</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> MetadataParser {
    <span class="s-keyword">private static let</span> dateFormatter: <span class="s-type">DateFormatter</span> = {
        <span class="s-keyword">let</span> formatter = <span class="s-type">DateFormatter</span>()
        formatter.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd HH:mm"</span>
        formatter.<span class="s-property">timeZone</span> = <span class="s-type">TimeZone</span>(secondsFromGMT: <span class="s-number">0</span>)
        <span class="s-keyword">return</span> formatter
    }()

    <span class="s-keyword">func</span> metadata(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Metadata</span> {
        ...
    }
}</code></pre><p>While self-executing closures are incredibly convenient, using them to configure properties can often “push” the core functionality of a type further and further down — which in turn can make it harder to quickly get an overview of what a type is actually doing. To mitigate that problem, let’s see if we can do something to make such configuration closures as compact as possible, without sacrificing readability.</p><p>Let’s start by defining a function called <code>configure</code>, which simply takes any object or value, and lets us apply any sort of mutations to it inside of a closure, using the <code>inout</code> keyword — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> configure&lt;T&gt;(<span class="s-keyword">_</span> object: <span class="s-type">T</span>, using closure: (<span class="s-keyword">inout</span> <span class="s-type">T</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">T</span> {
    <span class="s-keyword">var</span> object = object
    <span class="s-call">closure</span>(&amp;object)
    <span class="s-keyword">return</span> object
}</code></pre><p>To configure the shared <code>DateFormatter</code> for our metadata parsers, we can now simply pass it to the above function, and easily configure it using the <code>$0</code> closure argument shorthand — leaving us with code that’s more compact, while still remaining just as readable:</p><pre class="splash"><code><span class="s-keyword">struct</span> MetadataParser {
    <span class="s-keyword">private static let</span> dateFormatter = <span class="s-call">configure</span>(<span class="s-type">DateFormatter</span>()) {
        $0.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd HH:mm"</span>
        $0.<span class="s-property">timeZone</span> = <span class="s-type">TimeZone</span>(secondsFromGMT: <span class="s-number">0</span>)
    }

    <span class="s-keyword">func</span> metadata(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Metadata</span> {
        ...
    }
}</code></pre><p>The above way of configuring properties is arguably even easier to understand than self-executing closures — since by adding the call to <code>configure</code>, we’re making it crystal clear that the purpose of the accompanying closure is, in fact, to configure the instance that’s passed into it.</p><h2>Conclusion</h2><p>Just like any topic that relates to code style and structure, how to best configure objects and values will most likely always remain a matter of taste. However, regardless of how we actually end up configuring our code — if we can do so in a way that’s fully encapsulated, then those configurations tend to be much easier to both reuse and manage.</p><p>Starting to adopt increasingly declarative coding styles and patterns can also further help ease the transition into the world of SwiftUI and Combine, even if we might expect that it’ll take a year or two before we can actually start adopting those frameworks. Arguably, declarative programming is just as much about ways of thinking, as it is about APIs and syntax.</p><p>What do you think? How do you currently configure your views and other values and objects? Let me know — along with your questions, comments or feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift</guid><title>Alternatives to protocols in Swift</title><description>Protocols are, without a doubt, a major part of Swift’s overall design. However, they also come with their own set of downsides and trade-offs. This week, let’s take a look at some of those characteristics, and explore a few alternative ways of abstracting code in Swift — to see how they compare to using protocols.</description><link>https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift</link><pubDate>Sun, 6 Oct 2019 17:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Protocols are, without a doubt, a major part of Swift’s overall design — and can provide a great way to create abstractions, to separate concerns, and to improve the overall flexibility of a system or feature. By not strongly tying types together, but rather connecting the various parts of a code base through more abstract interfaces, we usually end up with a much more decoupled architecture that lets us iterate on each individual feature in isolation.</p><p>However, while protocols can be a great tool in many different situations, they also come with their own set of downsides and trade-offs. This week, let’s take a look at some of those characteristics, and explore a few alternative ways of abstracting code in Swift — to see how they compare to using protocols.</p><h2>Single requirements using closures</h2><p>One of the advantages of abstracting code using protocols is that it lets us group multiple <em>requirements</em> together. For example, a <code>PersistedValue</code> protocol might require both a <code>save</code> and a <code>load</code> method — which both enables us to enforce a certain degree of consistency among all such values, and to write shared utilities for saving and loading data.</p><p>However, not all abstractions involve multiple requirements, and it’s very common to end up with protocols that only have a single method or property — such as this one:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ModelProvider {
    <span class="s-keyword">associatedtype</span> Model: <span class="s-type">ModelProtocol</span>
    <span class="s-keyword">func</span> provideModel() -&gt; <span class="s-type">Model</span>
}</code></pre><p>Let’s say that the above <code>ModelProvider</code> protocol is used to abstract the way we load and provide models across our code base. It uses an associated type in order to let each implementation declare what type of model that it provides in a very type-safe way, which is great, as it enables us to write generic code to perform common tasks — such as rendering a detail view for a given model:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: <span class="s-type">AnyModelProvider</span>&lt;<span class="s-type">Model</span>&gt;

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">ModelProvider</span>&gt;(modelProvider: <span class="s-type">T</span>) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Model</span> == <span class="s-type">Model</span> {
        <span class="s-comment">// We wrap the injected provider in an AnyModelProvider
        // instance to be able to store a reference to it.</span>
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = <span class="s-type">AnyModelProvider</span>(modelProvider)
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> model = modelProvider.<span class="s-call">provideModel</span>()
        ...
    }
    
    ...
}</code></pre><p>While the above code works, it illustrates one of the downsides of using a protocol with associated types — we can’t store a reference to <code>ModelProvider</code> directly. Instead we first have to <em><a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">perform type erasure</a></em> to turn our protocol reference into a concrete type, which both clutters up our code, and requires us to implement additional types just to be able to use our protocol.</p><p>Since we’re dealing with a protocol that only has a single requirement, the question is — do we <em>really</em> need it? After all, our <code>ModelProvider</code> protocol doesn’t add any additional grouping or structure, so let’s instead lift out its sole requirement and turn that into a closure — which can then be injected directly, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: () -&gt; <span class="s-type">Model</span>

    <span class="s-keyword">init</span>(modelProvider: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Model</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = modelProvider
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> model = <span class="s-call">modelProvider</span>()
        ...
    }
    
    ...
}</code></pre><p class="info">To learn more about the above way of dependency injection, check out <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">“Simple Swift dependency injection with functions”</a>, and <a href="https://www.swiftbysundell.com/articles/functional-networking-in-swift">“Functional networking in Swift”</a>.</p><p>By directly injecting the functionality that we need, rather than requiring a type to conform to a protocol, we’ve also drastically improved the flexibility of our code — since we’re now free to inject anything from a free function, to an inline defined closure, to an instance method. We also no longer have to perform any type erasure, leaving us with much simpler code.</p><h2>Using generic types</h2><p>While closures and functions can be a great way to model single-requirement abstractions, using them can get a bit messy if we’ll start adding additional requirements. For example, let’s say that we’d like to extend our above <code>DetailViewController</code> to also support bookmarking and deleting models. If we were to stick with our closure-based approach, we’d end up with something like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: () -&gt; <span class="s-type">Model</span>
    <span class="s-keyword">private let</span> modelBookmarker: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
    <span class="s-keyword">private let</span> modelDeleter: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">init</span>(modelProvider: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Model</span>,
         modelBookmarker: <span class="s-keyword">@escaping</span> (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>,
         modelDeleter: <span class="s-keyword">@escaping</span> (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = modelProvider
        <span class="s-keyword">self</span>.<span class="s-property">modelBookmarker</span> = modelBookmarker
        <span class="s-keyword">self</span>.<span class="s-property">modelDeleter</span> = modelDeleter
        
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...
}</code></pre><p>Not only does the above setup require us to keep track of multiple stand-alone closures, we also end up with a lot of duplicated <em>“model”</em> prefixes — which (using the <em><a href="https://www.swiftbysundell.com/articles/structuring-swift-code">“Rule of Threes”</a></em>) tells us that we have somewhat of a structural problem here. While we <em>could</em> go back to encapsulating all of the above closures into a protocol, that’d again require us to do type erasure, and to lose some of that flexibility that we gained when we started using closures.</p><p>Instead, let’s use a generic type to group our requirements together — which both lets us retain the flexibility of using closures, while also adding some additional structure to our code:</p><pre class="splash"><code><span class="s-keyword">struct</span> ModelHandling&lt;Model: <span class="s-type">ModelProtocol</span>&gt; {
    <span class="s-keyword">var</span> provide: () -&gt; <span class="s-type">Model</span>
    <span class="s-keyword">var</span> bookmark: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
    <span class="s-keyword">var</span> delete: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
}</code></pre><p>Since the above is a concrete type, it doesn’t require any form of type erasure (in fact, it actually looks quite similar to the sort of type erased wrappers that we’re often forced to write when using protocols with associated types). So, just like a closure, it can be used and stored directly — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelHandler: <span class="s-type">ModelHandling</span>&lt;<span class="s-type">Model</span>&gt;
    <span class="s-keyword">private lazy var</span> model = modelHandler.<span class="s-call">provide</span>()

    <span class="s-keyword">init</span>(modelHandler: <span class="s-type">ModelHandling</span>&lt;<span class="s-type">Model</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">modelHandler</span> = modelHandler
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }

    <span class="s-keyword">@objc private func</span> bookmarkButtonTapped() {
        modelHandler.<span class="s-call">bookmark</span>(model)
    }
    
    <span class="s-keyword">@objc private func</span> deleteButtonTapped() {
        modelHandler.<span class="s-call">delete</span>(model)
        <span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
    }
    
    ...
}</code></pre><p>While protocols with associated types are incredibly useful when defining more high-level requirements (just like the standard library’s <code>Equatable</code> and <code>Collection</code> protocols do), when such a protocol needs to be used directly, using either a stand-alone closure or a generic type instead can often give us the same level of encapsulation — but through a much simpler abstraction.</p><h2>Separating requirements using enums</h2><p>A common challenge when designing any sort of abstraction is to not <em>“over-abstract”</em> by adding too many requirements. For example, let’s now say that we’re working on an app that lets the user consume multiple kinds of media — like articles, podcasts, videos, and so on — and that we’d like to create a shared abstraction for all of those different formats. If we again start with the protocol-oriented approach, we might end up with something like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Media {
    <span class="s-keyword">var</span> id: <span class="s-type">UUID</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">get</span> }
}</code></pre><p>Since the above protocol needs to work with all different kinds of media, we end up with multiple properties that are only relevant for certain formats. For example, an <code>Article</code> type doesn’t have any concept of a <em>duration</em> or <em>resolution</em> — leaving us with several properties that we simply have to implement because our protocol requires us to:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Media</span> {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? { <span class="s-keyword">return nil</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>? { <span class="s-keyword">return nil</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">return nil</span> }
}</code></pre><p>Not only does the above setup require us to add unnecessary boilerplate to our conforming types, it could also be a source of ambiguity — as there’s no way for us to enforce that an article actually contains text, or that the types that should support a URL, duration or resolution actually carries that data — since all of those properties are optionals.</p><p>There are multiple ways that we could address the above problem, starting with splitting our protocol up into multiple ones, each with an <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">increasing degree of specialization</a> — like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Media {
    <span class="s-keyword">var</span> id: <span class="s-type">UUID</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">protocol</span> ReadableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> text: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">protocol</span> PlayableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">get</span> }
}</code></pre><p>The above is definitely an improvement, as it would enable us to have types like <code>Article</code> conform to <code>ReadableMedia</code>, and playable types (like <code>Audio</code> and <code>Video</code>) conform to <code>PlayableMedia</code> — reducing both ambiguity and boilerplate, as each type can pick which specialized version of <code>Media</code> that it wants to conform to.</p><p>However, since the above protocols are all about data, it would arguably make even more sense to model them using an <em>actual data type</em> instead — which would both reduce the need for duplicate implementations, and would also let us work with any media format through a single, concrete type:</p><pre class="splash"><code><span class="s-keyword">struct</span> Media {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">var</span> content: <span class="s-type">Content</span>
}</code></pre><p>The above struct now only contains the data that’s shared among all of our media formats, except for its <code>content</code> property — which is what we’ll use for specialization. But this time, rather than making <code>Content</code> a protocol, let’s use an enum — which will enable us to define a tailored set of properties for each format, through associated values:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Media</span> {
    <span class="s-keyword">enum</span> Content {
        <span class="s-keyword">case</span> article(text: <span class="s-type">String</span>)
        <span class="s-keyword">case</span> audio(<span class="s-type">Playable</span>)
        <span class="s-keyword">case</span> video(<span class="s-type">Playable</span>, resolution: <span class="s-type">Resolution</span>)
    }
    
    <span class="s-keyword">struct</span> Playable {
        <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
        <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>
    }
}</code></pre><p>Gone are the optionals, and we’ve now achieved a nice balance between having a shared abstraction and enabling format-specific specialization. The beauty of enums is also that they enable us to express data variance without having to use either generics or protocols — everything can be encapsulated within the same, concrete type, as long as we know the number of variants up-front.</p><h2>Classes and inheritance</h2><p>Another approach that might not be as popular in Swift as in other languages, but is still definitely worth considering, is to create abstractions using classes that are specialized through inheritance. For example, rather than using a <code>Content</code> enum to implement our above media formats, we could’ve used a <code>Media</code> base class that would then be subclassed in order to add format-specific properties — like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Media {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>

    <span class="s-keyword">init</span>(id: <span class="s-type">UUID</span>, title: <span class="s-type">String</span>, description: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">id</span> = id
        <span class="s-keyword">self</span>.<span class="s-property">title</span> = title
        <span class="s-keyword">self</span>.<span class="s-property">description</span> = description
    }
}

<span class="s-keyword">class</span> PlayableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>

    <span class="s-keyword">init</span>(id: <span class="s-type">UUID</span>,
         title: <span class="s-type">String</span>,
         description: <span class="s-type">String</span>,
         url: <span class="s-type">URL</span>,
         duration: <span class="s-type">TimeInterval</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">url</span> = url
        <span class="s-keyword">self</span>.<span class="s-property">duration</span> = duration
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(id: id, title: title, description: description)
    }
}</code></pre><p>However, while the above approach makes total sense from a structural perspective — it does come with a few downsides. First, since classes don’t yet support memberwise initializers, we have to define all initializers ourselves — and we also have to manually pass data upwards through our inheritance tree by calling <code>super.init</code>. But perhaps more importantly is that classes are <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference types</a>, which means that we’d have to be careful not to perform any unexpected mutations when sharing <code>Media</code> instances across our code base.</p><p>But that doesn’t mean that there are no valid use cases for inheritance in Swift. For example, in <em><a href="https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift">“Under the hood of Futures &amp; Promises in Swift”</a></em>, inheritance provided a great way to expose a read-only <code>Future</code> type to API users — while still enabling such an instance to be privately mutated through a <code>Promise</code> subclass:</p><pre class="splash"><code><span class="s-keyword">class</span> Future&lt;Value&gt; {
    <span class="s-keyword">fileprivate var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;? {
        <span class="s-keyword">didSet</span> { result.<span class="s-call">map</span>(report) }
    }
    
    ...
}

<span class="s-keyword">class</span> Promise&lt;Value&gt;: <span class="s-type">Future</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">func</span> resolve(with value: <span class="s-type">Value</span>) {
        result = .<span class="s-call">success</span>(value)
    }

    <span class="s-keyword">func</span> reject(with error: <span class="s-type">Error</span>) {
        result = .<span class="s-call">failure</span>(error)
    }
}

<span class="s-keyword">func</span> loadCachedData() -&gt; <span class="s-type">Future</span>&lt;<span class="s-type">Data</span>&gt; {
    <span class="s-keyword">let</span> promise = <span class="s-type">Promise</span>&lt;<span class="s-type">Data</span>&gt;()
    cache.<span class="s-call">load</span> { promise.<span class="s-call">resolve</span>(with: $0) }
    <span class="s-keyword">return</span> promise
}</code></pre><p>Using the above setup, we can enable the same instance to expose a different set of APIs in different contexts, which is really useful when we want to only allow one of those contexts to mutate a given object. That’s especially true when working with generic code, as we’d again run into the associated types problem if we were to try to achieve the same thing using a protocol instead.</p><h2>Conclusion</h2><p>Protocols are great, and will most likely remain the most common way of defining abstractions in Swift for the foreseeable future. However, that doesn’t mean that using a protocol will always be the best solution — sometimes looking beyond the popular <em>“protocol-oriented programming”</em> mantra can result in code that’s both simpler and more robust — especially if the protocol we’re looking to define requires us to use associated types.</p><p>What do you think? Besides protocols, what are your favorite ways of creating abstractions in Swift? Let me know — along with any questions, comments or feedback that you might have — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/computing-dates-in-swift</guid><title>Computing dates in Swift</title><description>Let’s take a look at Foundation’s date handling APIs — how they can enable us to easily make the way we compute dates more correct, and how we can build our own lightweight abstractions on top of them to make dealing with dates in Swift a lot easier.</description><link>https://www.swiftbysundell.com/articles/computing-dates-in-swift</link><pubDate>Sun, 29 Sep 2019 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p>The task of computing various dates and timestamps is something that at first may seem deceptively simple. We all know that a minute consists of sixty seconds, an hour of sixty minutes and that there are twenty-four hours in a day — however, correctly computing and modifying dates often requires a far more complex model.</p><p>Thankfully, Apple ships a complete set of date and calendar APIs as part of Foundation, and while some of those APIs may seem a bit complex at first glance — they enable us to write date handling code that takes all sorts of anomalies and cultural differences into account, without requiring us to know about any of those conditions ourselves.</p><p>This week, let’s take a look at a few examples of how we might use those APIs — how they can enable us to easily make the way we compute dates more correct, and how we can build our own lightweight abstractions on top of them to make dealing with dates in Swift a lot easier.</p><h2>Not always a time interval away</h2><p>The <code>TimeInterval</code> type (which is actually just a <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type alias</a> for <code>Double</code>) enables us to express time as an interval of seconds — which is incredibly useful when we want to compute a date within the very near future, such as in this example, in which we’re scheduling a notification to be shown after 20 seconds:</p><pre class="splash"><code><span class="s-keyword">let</span> date = <span class="s-type">Date</span>().<span class="s-call">addingTimeInterval</span>(<span class="s-number">20</span>)
<span class="s-call">schedule</span>(notification, for: date)</code></pre><p>However, the above way of computing dates breaks down quite quickly as our time interval grows — as simply adding a number of seconds to the current date won’t account for things like leap seconds, changes in daylight savings time, or other time corrections and adjustments.</p><p>For example, although the following code might give us a date that’s technically 24 hours away in terms of number of seconds, it won’t always be <em>“tomorrow”</em> — as a time adjustment might either push the resulting date into the following or previous day, or otherwise affect the perceived time of day:</p><pre class="splash"><code><span class="s-keyword">let</span> tomorrow = <span class="s-type">Date</span>().<span class="s-call">addingTimeInterval</span>(<span class="s-number">60</span> * <span class="s-number">60</span> * <span class="s-number">24</span>)</code></pre><p>While absolute precision isn’t always required when handling dates, using manually computed time intervals can lead to some really tricky bugs if our code assumes that <code>tomorrow</code> doesn’t simply mean <em>“24 hours away in terms of absolute time”</em>, but rather <em>“the same time as now, but tomorrow”</em>.</p><p>To compute the latter in a way that’s a lot more robust, let’s instead use Foundation’s <code>Calendar</code> type, which enables us to manipulate dates according to a specific calendar (the most common of which is the <em>Gregorian Calendar</em>) — with nanosecond-level precision:</p><pre class="splash"><code><span class="s-comment">// Calendar.current gives us access to a calendar that’s
// configured according to the user’s system settings:</span>
<span class="s-keyword">let</span> calendar = <span class="s-type">Calendar</span>.<span class="s-property">current</span>
<span class="s-keyword">let</span> date = <span class="s-type">Date</span>()

<span class="s-comment">// Define which date components that we want to be considered
// when looking for tomorrow’s date. This essentially decides
// what level of precision that we’d like:</span>
<span class="s-keyword">let</span> components = calendar.<span class="s-call">dateComponents</span>(
    [.<span class="s-dotAccess">hour</span>, .<span class="s-dotAccess">minute</span>, .<span class="s-dotAccess">second</span>, .<span class="s-dotAccess">nanosecond</span>],
    from: date
)

<span class="s-keyword">let</span> tomorrow = calendar.<span class="s-call">nextDate</span>(
    after: date,
    matching: components,
    matchingPolicy: .<span class="s-dotAccess">nextTime</span>
)</code></pre><p class="info">If we were planning to store the above <code>Calendar</code> value for further use, it’d be much better to access it using <code>Calendar.autoupdatingCurrent</code>, since that’ll track any changes that the user might make to their system-wide calendar preferences.</p><p>While the above will truly give us a date that’s equivalent to the same time as right now but tomorrow, writing all of that code each time we want to perform such a date calculation can quickly get repetitive — so let’s move it into an extension on <code>Date</code> instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">func</span> sameTimeNextDay(
        inDirection direction: <span class="s-type">Calendar</span>.<span class="s-type">SearchDirection</span> = .<span class="s-dotAccess">forward</span>,
        using calendar: <span class="s-type">Calendar</span> = .<span class="s-dotAccess">current</span>
    ) -&gt; <span class="s-type">Date</span> {
        <span class="s-keyword">let</span> components = calendar.<span class="s-call">dateComponents</span>(
            [.<span class="s-dotAccess">hour</span>, .<span class="s-dotAccess">minute</span>, .<span class="s-dotAccess">second</span>, .<span class="s-dotAccess">nanosecond</span>],
            from: <span class="s-keyword">self</span>
        )
        
        <span class="s-keyword">return</span> calendar.<span class="s-call">nextDate</span>(
            after: <span class="s-keyword">self</span>,
            matching: components,
            matchingPolicy: .<span class="s-dotAccess">nextTime</span>,
            direction: direction
        )!
    }
}</code></pre><p class="info"><code>Calendar</code> very often returns an optional <code>Date</code> from its various APIs, since the <code>DateComponents</code> used might contain an invalid combination of units (for example specifying the 31st of February as a date). However, in the above example we’re sure that our input is valid, so we force unwrap the result.</p><p>Above we also add support for specifying a <code>SearchDirection</code>, which enables us to move either forward or backward in time when calculating the next date — which in turn enables us to create two convenience APIs, one for accessing the current time tomorrow, and one for doing the same thing but for yesterday instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">static var</span> currentTimeTomorrow: <span class="s-type">Date</span> {
        <span class="s-keyword">return</span> <span class="s-type">Date</span>().<span class="s-call">sameTimeNextDay</span>()
    }
    
    <span class="s-keyword">static var</span> currentTimeYesterday: <span class="s-type">Date</span> {
        <span class="s-keyword">return</span> <span class="s-type">Date</span>().<span class="s-call">sameTimeNextDay</span>(inDirection: .<span class="s-dotAccess">backward</span>)
    }
}</code></pre><p>With the above in place, we can now simply pass <code>.currentTimeTomorrow</code> or <code>.currentTimeYesterday</code> to any API that accepts a <code>Date</code>, which is actually <em>simpler</em> than manually computing a date by adding a time interval — while also being much more robust as well.</p><h2>From time intervals to date intervals</h2><p>Apart from moving a date forwards or backwards in time, <code>Calendar</code> also contains a suite of APIs for dealing with dates in terms of intervals. While a <code>Date</code> value represents a single point in time, our perception of time often revolves more around intervals like days, weeks, and years — rather than absolute timestamps.</p><p>For example, let’s say that we’re working on an app that refreshes the content shown to each user at midnight within the user’s current timezone. So rather than constantly trying to fetch new content from our server, we’ll cache any loaded content until midnight that day — to only perform a new request once the next day has begun.</p><p>Rather than having to manually calculate the exact <code>Date</code> that corresponds to the start of the next day, let’s call the <code>startOfDay</code> method on our <code>Calendar</code>, in combination with our newly added <code>currentTimeTomorrow</code> convenience API — like this:</p><pre class="splash"><code><span class="s-keyword">func</span> contentDidLoad(<span class="s-keyword">_</span> content: <span class="s-type">Content</span>) {
    <span class="s-keyword">let</span> refreshDate = calendar.<span class="s-call">startOfDay</span>(for: .<span class="s-dotAccess">currentTimeTomorrow</span>)
    <span class="s-call">cache</span>(content, until: refreshDate)
}</code></pre><p>However, while the above will give us the exact date at which our new content <em>should</em> be ready, all clocks aren’t perfectly synchronized — meaning that if we’d perform our network request at that exact date, we might still end up getting yesterday’s content back as a response, in case our server’s clock is slightly behind our client-side one.</p><p>To fix that problem, let’s again enlist the help of <code>TimeInterval</code>, and simply add 100 seconds to our refresh date in order to give us a <em>“buffer”</em> that should be enough to account for any differences between our client and server-side clocks:</p><pre class="splash"><code><span class="s-keyword">func</span> contentDidLoad(<span class="s-keyword">_</span> content: <span class="s-type">Content</span>) {
    <span class="s-keyword">let</span> refreshDate = calendar.<span class="s-call">startOfDay</span>(for: .<span class="s-dotAccess">currentTimeTomorrow</span>)
    <span class="s-call">cache</span>(content, until: refreshDate.<span class="s-call">addingTimeInterval</span>(<span class="s-number">100</span>))
}</code></pre><p class="info">The above is a great use case for a <code>TimeInterval</code>-based date manipulation, since we’re looking to shift our date in terms of absolute seconds, rather than retrieving a human-readable one.</p><p>Besides computing the start of a given interval, such as a day, <code>Calendar</code> also enables us to search for complete intervals as well — such as the next weekend that’ll come after a given date:</p><pre class="splash"><code><span class="s-keyword">let</span> nextWeekend = calendar.<span class="s-call">nextWeekend</span>(startingAfter: <span class="s-type">Date</span>())!

<span class="s-call">showPartySchedulingView</span>(
    withStartDate: nextWeekend.<span class="s-property">start</span>,
    endDate: nextWeekend.<span class="s-property">end</span>
)</code></pre><p>Finally, we can also use <code>Calendar</code> to retrieve an interval that a given date is a part of. For example, here’s how we could retrieve the start and end dates of the current day, month, and year:</p><pre class="splash"><code><span class="s-keyword">let</span> date = <span class="s-type">Date</span>()
<span class="s-keyword">let</span> today = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">day</span>, for: date)
<span class="s-keyword">let</span> currentMonth = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">month</span>, for: date)
<span class="s-keyword">let</span> currentYear = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">year</span>, for: date)</code></pre><p>Along the same lines, here’s how we could compute the date interval for the following year, by adding one year to the current date, and then using that date to retrieve our interval:</p><pre class="splash"><code><span class="s-keyword">let</span> components = <span class="s-type">DateComponents</span>(year: <span class="s-number">1</span>)
<span class="s-keyword">let</span> todayNextYear = calendar.<span class="s-call">date</span>(byAdding: components, to: <span class="s-type">Date</span>())!
<span class="s-keyword">let</span> nextYear = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">year</span>, for: todayNextYear)</code></pre><p>Above we use <code>DateComponents</code> to manipulate the current date, which we also used in the initial example to specify the granularity of a date search. Just like how <code>URLComponents</code> can be used to <a href="https://www.swiftbysundell.com/articles/constructing-urls-in-swift">define the individual components</a> that make up a URL, a <code>DateComponents</code> value can be used to refer to various units of time — such as hours, days, and years — when either searching for a date, or when mutating one.</p><h2>Conclusion</h2><p>The differences in how time is represented within various cultures around the world (and throughout history), as well as how each of our calendar and time measurement systems include correcting mechanisms — such as leap days and daylight savings time — makes computing dates a lot more complex than what it first might seem like.</p><p>However, most of those complexities can be handled for us by the system, as long as we use the right APIs to perform our date calculations — and while this article didn’t cover <em>all</em> such APIs — I hope that it can act as a reference for when your code next needs to travel either forwards or backwards in time.</p><p>If you have any questions, comments, or feedback — then feel free to contact me either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/making-types-expressible-by-string-interpolation</guid><title>Tip: Making types expressible by string interpolation</title><description>How to enable a type to be expressed by strings that contain interpolated values.</description><link>https://www.swiftbysundell.com/tips/making-types-expressible-by-string-interpolation</link><pubDate>Fri, 27 Sep 2019 16:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Creating wrapper types for raw values, such as strings and integers, can be a great way to make our code a bit more type-safe and self-documenting — and also gives us dedicated types on which we can implement domain-specific convenience APIs.</p><p>For example, here’s such a type that represents a file system path, which can be used to do things like load the contents of a file:</p><pre class="splash"><code><span class="s-keyword">struct</span> Path {
    <span class="s-keyword">var</span> string: <span class="s-type">String</span>
}

<span class="s-keyword">func</span> loadFile(at path: <span class="s-type">Path</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">File</span> {
    ...
}</code></pre><p>However, while having that dedicated <code>Path</code> type does give us several benefits, it could also make our APIs a bit more cumbersome to use. For example, anytime we want to specify a path using a string literal, we now have to wrap it first:</p><pre class="splash"><code><span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-type">Path</span>(string: <span class="s-string">"~/documents/article.md"</span>))</code></pre><p>To fix that, we can make <code>Path</code> conform to <code>ExpressibleByStringLiteral</code>, which enables us to directly pass a string literal to any API that accepts a <code>Path</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">init</span>(stringLiteral value: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">string</span> = value
    }
}

<span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-string">"~/documents/article.md"</span>)</code></pre><p>That’s really nice, however, the above won’t work if we’re using any form of interpolation within our string — such as in this case:</p><pre class="splash"><code><span class="s-comment">// Since this string literal contains interpolation, it won't
// be automatically converted to a Path, and we'll get an error:</span>
<span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-string">"/users/</span>\(username)<span class="s-string">/file.txt"</span>)</code></pre><p>Thankfully, the above problem is easily fixed. All we have to do is to declare that our <code>Path</code> also conforms to <code>ExpressibleByStringInterpolation</code> — and the compiler will be able to infer the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringInterpolation</span> {}</code></pre><p>We can now express our <code>Path</code> type using any kind of string literal — which makes it much more convenient to use, while still giving us all of the benefits of stronger typing.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/closures</guid><title>Basics: Closures</title><description>A look at a few different ways that closures can be defined and used in Swift, the flexibility of Swift’s closure syntax, and how behaviors like escaping and capturing may impact our code.</description><link>https://www.swiftbysundell.com/basics/closures</link><pubDate>Wed, 25 Sep 2019 17:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like functions, closures enable us to define a group of code statements that can be called as one unit, which can both accept input and produce output. The difference, however, is that closures can be defined <em>inline</em> — right at the point where we want to use them — which is incredibly useful in a number of different situations.</p><p>Closures can both be stored as properties and local variables, and can also be passed as arguments to functions (or other closures), like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> IntToStringConverter {
    <span class="s-comment">// A closure property that takes an Int as input
    // and produces a String as output:</span>
    <span class="s-keyword">var</span> body: (<span class="s-type">Int</span>) -&gt; <span class="s-type">String</span>
}

<span class="s-comment">// A closure defined as an inline variable, which
// takes no input and produces an Int as output:</span>
<span class="s-keyword">let</span> intProvider: () -&gt; <span class="s-type">Int</span> = { <span class="s-keyword">return</span> <span class="s-number">7</span> }

<span class="s-comment">// A closure function argument that takes no input
// and also doesn't produce any output:</span>
<span class="s-keyword">func</span> performOperation(then closure: () -&gt; <span class="s-type">Void</span>) {
    ...
}</code></pre><p>To take a look at how closures can be really useful in practice, let’s say that we wanted to extend Swift’s <code>String</code> type with a function that enables us to transform each word that appears within a string. By using a closure, we can enable the callers of our new function to freely decide <em>exactly how</em> to perform each transform:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">String</span> {
    <span class="s-keyword">func</span> transformWords(
        using closure: (<span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span>
    ) -&gt; <span class="s-type">String</span> {
        <span class="s-comment">// Split the current string up into word substrings:</span>
        <span class="s-keyword">let</span> words = <span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
        <span class="s-keyword">var</span> results = [<span class="s-type">String</span>]()

        <span class="s-comment">// Iterate through each word and transform it:</span>
        <span class="s-keyword">for</span> word <span class="s-keyword">in</span> words {
            <span class="s-comment">// We can call the closure that was passed into our
            // function just like how we'd call a function:</span>
            <span class="s-keyword">let</span> transformed = <span class="s-call">closure</span>(word)
            results.<span class="s-call">append</span>(transformed)
        }

        <span class="s-comment">// Join our results array back into a string:</span>
        <span class="s-keyword">return</span> results.<span class="s-call">joined</span>(separator: <span class="s-string">" "</span>)
    }
}</code></pre><p class="info">Note that the above sample code is just an example, as it’s not a very efficient way to transform strings. To learn more about strings and how the above <code>Substring</code> type works, check out the <a href="https://www.swiftbysundell.com/basics/strings">“Strings” article</a>.</p><p>We can now call the above function with any closure that we want, as long as it takes a <code>Substring</code> as input, and produces a <code>String</code> as output. For example, here’s how we could transform each word within a string into lowercase:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-string">"Hello, world!"</span>.<span class="s-call">transformWords</span>(using: { word <span class="s-keyword">in
    return</span> word.<span class="s-call">lowercased</span>()
})

<span class="s-call">print</span>(string) <span class="s-comment">// "hello, world!"</span></code></pre><p class="info">The <code>in</code> keyword that we use above is, among other things, used to name the arguments that our closure accepts.</p><p>Compared to most other language features, Swift’s closure syntax is quite flexible, and there’s a number of features that we can take advantage of in order to make the above code a bit more compact:</p><ul><li>Using <em>trailing closure syntax</em>, we can simply append our closure to the name of the function that we’re calling, rather than having to type out the parentheses and the parameter label.</li><li>We can replace <code>word in</code> with the <code>$0</code> <em>closure argument shorthand</em>, which lets us refer to the first (and in our case, only) argument passed into the closure.</li><li>We can remove the <code>return</code> keyword, which is not required for single-expression closures (a feature that, starting with Swift 5.1, also applies to functions and computed properties).</li></ul><p>By applying all of the above, our code will now look like this instead:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-string">"Hello, world!"</span>.<span class="s-call">transformWords</span> { $0.<span class="s-call">lowercased</span>() }</code></pre><p class="info">When using a more compact syntax, we always have to be careful not to reduce the readability of our code too much — so for more complex closures, using a more verbose syntax variant may be more appropriate.</p><p>Not only can newly defined closures be passed as function arguments, we can also pass an existing closure on to another function as well. For example, here’s how we could go back to the implementation of our <code>transformWords</code> function, and simply pass the given closure to <code>map</code> — rather than having write a manual iteration:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">String</span> {
    <span class="s-keyword">func</span> transformWords(
        using closure: (<span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span>
    ) -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">let</span> words = <span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
        <span class="s-keyword">let</span> results = words.<span class="s-call">map</span>(closure)
        <span class="s-keyword">return</span> results.<span class="s-call">joined</span>(separator: <span class="s-string">" "</span>)
    }
}</code></pre><p class="info">To learn more about <code>map</code>, check out the <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">“Map, FlatMap and CompactMap” article</a>.</p><p>So far, we’ve only used closures that are immediately executed and then discarded — but it’s also very common to want to store a closure for later use. For example, let’s say that we wanted to write a <code>delay</code> function, that lets us delay the execution of any closure by a certain amount of seconds. To do that, we’ll use <a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a>’s <code>asyncAfter</code> API — however, since passing our closure to that API will cause it to be stored until our delay time interval has passed, we’ll need to mark it as <code>@escaping</code>, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> delay(by seconds: <span class="s-type">TimeInterval</span>,
           on queue: <span class="s-type">DispatchQueue</span> = .<span class="s-dotAccess">main</span>,
           closure: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
    queue.<span class="s-call">asyncAfter</span>(
        deadline: .<span class="s-call">now</span>() + seconds,
        execute: closure
    )
}</code></pre><p>When a closure is marked as <code>@escaping</code>, it both means that it can be stored for later use, and it also means that we’ll need to explicitly use <code>self</code> whenever we’re accessing an instance property or method within it:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewWillAppear(<span class="s-keyword">_</span> animated: <span class="s-type">Bool</span>) {
        <span class="s-keyword">super</span>.<span class="s-call">viewWillAppear</span>(animated)

        <span class="s-call">delay</span>(by: <span class="s-number">2</span>) {
            <span class="s-comment">// We need to use 'self' here to be able to call our
            // method, since we're inside an escaping closure.</span>
            <span class="s-keyword">self</span>.<span class="s-call">showTutorialIfNeeded</span>()
        }
    }

    <span class="s-keyword">private func</span> showTutorialIfNeeded() {
        ...
    }
}</code></pre><p>However, there’s something that we need to be very careful with when writing code like the above — and that’s <em>capturing</em>. The reason we have to explicitly use <code>self</code> within escaping closures is that it causes that object to be captured, meaning that it’ll be retained in memory for as long as the closure itself remains in memory, which can cause memory leaks if we’re not careful.</p><p>Like we took a look at in the <a href="https://www.swiftbysundell.com/basics/memory-management"><em>“Memory Management”</em> article</a>, one way to prevent a strong capture from happening is to use a <em>capture list</em> to specify that we’d like to capture <code>self</code> weakly — which won’t cause it to be strongly retained:</p><pre class="splash"><code><span class="s-call">delay</span>(by: <span class="s-number">2</span>) { [<span class="s-keyword">weak self</span>] <span class="s-keyword">in
    self</span>?.<span class="s-call">showTutorialIfNeeded</span>()
}</code></pre><p class="info">Note that in the above example, it’s not <strong>really</strong> a big deal that we capture <code>self</code> strongly, as our closure will only be retained for 2 seconds. However, as we might increase that time interval in the future, it can still be a good idea to use <code>weak</code> — especially since there’s no reason for <code>self</code> to be retained strongly in this case anyway.</p><p>Finally, let’s take a look at how the line between functions and closures gets even more blurred as we start utilizing Swift’s <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class function</a> capabilities. Going back to our earlier example of transforming words, let’s say that we’ve defined a standard function that capitalizes any word passed to it:</p><pre class="splash"><code><span class="s-keyword">func</span> capitalize(word: <span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">return</span> word.<span class="s-property">capitalized</span>
}</code></pre><p>Since Swift supports first class functions, we can actually pass the above function just as if it was a <code>(Substring) -&gt; String</code> closure — which in turn lets us use it as an argument when calling our previous <code>transformWords</code> function, since it accepts a closure with that exact shape:</p><pre class="splash"><code><span class="s-keyword">let</span> name = <span class="s-string">"swift by sundell"</span>.<span class="s-call">transformWords</span>(using: capitalize)
<span class="s-call">print</span>(name) <span class="s-comment">// "Swift By Sundell"</span></code></pre><p>Pretty cool! There’s of course a huge number of other things that we can do with closures in Swift, some of which can take us deeper into the realm of functional programming — but I hope that this article has given you a quick basic overview of how closures can be used in Swift.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1</guid><title>5 small but significant improvements in Swift 5.1</title><description>Swift 5.1 has now been officially released, and despite being a minor release, it contains a substantial number of changes and improvements. This week, let’s take a look at five of those features, and what kind of situations they could be useful in.</description><link>https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1</link><pubDate>Sun, 22 Sep 2019 17:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Swift 5.1 has now been officially released, and despite being a minor release, it contains a substantial number of changes and improvements — ranging from fundamental new features, like module stability (which enables SDK vendors to ship pre-compiled Swift frameworks), to all of the <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">new syntax features that power SwiftUI</a>, and beyond.</p><p>Besides its headlining new features, Swift 5.1 also contains a number of smaller — but still highly significant — new capabilities and improvements. It’s the sort of changes that at first may seem really minor, or even unnecessary, but can turn out to have a quite major impact on how we write and structure our Swift code. This week, let’s take a look at five of those features, and what kind of situations they could be useful in.</p><h2>Memberwise initializers with default values</h2><p>One of the many things that make structs so appealing in Swift is their auto-generated <em>“memberwise”</em> initializers — which enable us to initialize any struct (that doesn’t contain private stored properties) simply by passing values corresponding to each of its properties, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Message {
    <span class="s-keyword">var</span> subject: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
}

<span class="s-keyword">let</span> message = <span class="s-type">Message</span>(subject: <span class="s-string">"Hello"</span>, body: <span class="s-string">"From Swift"</span>)</code></pre><p>These synthesized initializers have been significantly improved in Swift 5.1, since they now take default property values into account, and automatically translate those values into default initializer arguments.</p><p>Let’s say that we wanted to expand the above <code>Message</code> struct with support for attachments, but that we’d like the default value to be an empty array — and at the same time, we’d also like to enable a <code>Message</code> to be initialized without having to specify a <code>body</code> up-front, so we’ll give that property a default value as well:</p><pre class="splash"><code><span class="s-keyword">struct</span> Message {
    <span class="s-keyword">var</span> subject: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body = <span class="s-string">""</span>
    <span class="s-keyword">var</span> attachments: [<span class="s-type">Attachment</span>] = []
}</code></pre><p>In Swift 5.0 and earlier, we’d still have to pass initializer arguments for all of the above properties anyway, regardless of whether they have a default value. However, in Swift 5.1, that’s no longer the case — meaning that we can now initialize a <code>Message</code> by only passing a <code>subject</code>, like this:</p><pre class="splash"><code><span class="s-keyword">var</span> message = <span class="s-type">Message</span>(subject: <span class="s-string">"Hello, world!"</span>)</code></pre><p>That’s really cool, and it makes using structs even more convenient than before. But perhaps even cooler is that, just like when using standard default arguments, we can still override any default property value by passing an argument for it — which gives us a ton of flexibility:</p><pre class="splash"><code><span class="s-keyword">var</span> message = <span class="s-type">Message</span>(
    subject: <span class="s-string">"Hello, world!"</span>,
    body: <span class="s-string">"Swift 5.1 is such a great update!"</span>
)</code></pre><p>However, while memberwise initializers are incredibly useful within an app or module, they’re still not exposed as part of a module’s public API — meaning that if we’re building some form of library or framework, we still have to define our public-facing initializers manually (for now).</p><h2> to refer to enclosing types</h2><p>Swift’s <code>Self</code> keyword (<em>or type, really</em>) has previously enabled us to dynamically refer to a type in contexts where the actual concrete type isn’t known — for example by referring to a protocol’s implementing type within a protocol extension:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Numeric</span> {
    <span class="s-keyword">func</span> incremented(by value: <span class="s-type">Self</span> = <span class="s-number">1</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">return self</span> + value
    }
}</code></pre><p>While that’s still possible, the scope of <code>Self</code> has now been extended to also include concrete types — like enums, structs and classes — enabling us to use <code>Self</code> as a sort of alias referring to a method or property’s <em>enclosing</em> type, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TextTransform</span> {
    <span class="s-keyword">static var</span> capitalize: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">TextTransform</span> { $0.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">static var</span> removeLetters: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">TextTransform</span> { $0.<span class="s-call">filter</span> { !$0.<span class="s-property">isLetter</span> } }
    }
}</code></pre><p>The fact that we can now use <code>Self</code> above, rather than the full <code>TextTransform</code> type name, is of course purely <em>syntactic sugar</em> — but it can help make our code a bit more compact, especially when dealing with long type names. We can even use <code>Self</code> inline within a method or property as well, further making the above code even more compact:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TextTransform</span> {
    <span class="s-keyword">static var</span> capitalize: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">Self</span> { $0.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">static var</span> removeLetters: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">Self</span> { $0.<span class="s-call">filter</span> { !$0.<span class="s-property">isLetter</span> } }
    }
}</code></pre><p>Besides referring to an enclosing type itself, we can now also use <code>Self</code> to access static members within an instance method or property — which is quite useful in situations when we want to reuse the same value across all instances of a type, such as the <code>cellReuseIdentifier</code> in this example:</p><pre class="splash"><code><span class="s-keyword">class</span> ListViewController: <span class="s-type">UITableViewController</span> {
    <span class="s-keyword">static let</span> cellReuseIdentifier = <span class="s-string">"list-cell"</span>

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        tableView.<span class="s-call">register</span>(
            <span class="s-type">ListTableViewCell</span>.<span class="s-keyword">self</span>,
            forCellReuseIdentifier: <span class="s-type">Self</span>.<span class="s-property">cellReuseIdentifier</span>
        )
    }
}</code></pre><p>Again, we could’ve simply typed out <code>ListViewController</code> above when accessing our static property, but using <code>Self</code> does arguably improve the readability of our code — and will also enable us to rename our view controller without having to update the way we access its static members.</p><h2>Switching on optionals</h2><p>Next, let’s take a look at how Swift 5.1 makes it easier to perform pattern matching on optionals, which really comes in handy when switching on an optional value. As an example, let’s say that we’re working on a music app that contains a <code>Song</code> model — which has a <code>downloadState</code> property that lets us keep track of whether a song has been downloaded, if it’s currently being downloaded, and so on:</p><pre class="splash"><code><span class="s-keyword">struct</span> Song {
    ...
    <span class="s-keyword">var</span> downloadState: <span class="s-type">DownloadState</span>?
}</code></pre><p class="info">The reason the above property is an optional is that we want <code>nil</code> to represent the lack of a download state, that is, if a song hasn’t been downloaded at all.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">“Pattern matching in Swift”</a></em>, Swift’s advanced pattern matching capabilities enable us to directly switch on an optional value — without having to unwrap it first — however, before Swift 5.1, doing so required us to append a question mark to each matching case, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> songDownloadStateDidChange(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
    <span class="s-keyword">switch</span> song.<span class="s-property">downloadState</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadInProgress</span>?:
        <span class="s-call">showProgressIndiator</span>(for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadFailed</span>(<span class="s-keyword">let</span> error)?:
        <span class="s-call">showDownloadError</span>(error, for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloaded</span>?:
        <span class="s-call">downloadDidFinish</span>(for: song)
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">break</span>
    }
}</code></pre><p>In Swift 5.1, those trailing question marks are no longer needed, and we can now simply refer to each case directly — just like when switching on a non-optional value:</p><pre class="splash"><code><span class="s-keyword">func</span> songDownloadStateDidChange(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
    <span class="s-keyword">switch</span> song.<span class="s-property">downloadState</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadInProgress</span>:
        <span class="s-call">showProgressIndiator</span>(for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadFailed</span>(<span class="s-keyword">let</span> error):
        <span class="s-call">showDownloadError</span>(error, for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloaded</span>:
        <span class="s-call">downloadDidFinish</span>(for: song)
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">break</span>
    }
}</code></pre><p>While the above is a really welcome change in terms of further reducing the syntax required to implement common patterns, it does come with a slight side-effect, that could potentially be source-breaking for certain enums and switch statements.</p><p>Since Swift optionals are implemented using the <code>Optional</code> enum under the hood, we’re no longer able to perform the above kind of optional pattern matching on any enum that contains either a <code>some</code> or <code>none</code> case — since those will now conflict with the cases that <code>Optional</code> contains.</p><p>However, it can be argued that any enum that contains such cases (especially <code>none</code>), should instead be implemented using an optional — since representing potentially missing values is essentially what optionals do.</p><h2> protocol</h2><p>Originally introduced as part of the initial release of SwiftUI, the new <code>Identifiable</code> protocol has now made its way into the Swift standard library — and provides a simple and unified way to mark any type as having a stable, unique identifier.</p><p>To conform to this new protocol, we simply have to declare an <code>id</code> property, which can contain any <code>Hashable</code> type — for example <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> User: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">typealias</span> ID = <span class="s-type">String</span>

    <span class="s-keyword">var</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}</code></pre><p>Similar to when <a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift"><code>Result</code></a> was added to the standard library as part of Swift 5.0, a major benefit of now having <code>Identifable</code> accessible to any Swift module is that it can be used to share requirements across different code bases.</p><p>For example, using a constrained protocol extension, we could add a convenience API for transforming any <code>Sequence</code> that contains identifiable elements into a dictionary — and then vend that extension as part of a library, without requiring us to define any protocol of our own:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sequence</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">func</span> keyedByID() -&gt; [<span class="s-type">Element</span>.<span class="s-type">ID</span> : <span class="s-type">Element</span>] {
        <span class="s-keyword">var</span> dictionary = [<span class="s-type">Element</span>.<span class="s-type">ID</span> : <span class="s-type">Element</span>]()
        <span class="s-call">forEach</span> { dictionary[$0.<span class="s-property">id</span>] = $0 }
        <span class="s-keyword">return</span> dictionary
    }
}</code></pre><p class="info">The above API is implemented as a method, rather than as a computed property, since its time complexity is <code>O(n)</code>. For more on picking between a method and a computed property, see <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">this article</a>.</p><p>However, while the standard library’s new <code>Identifiable</code> protocol is really useful when dealing with collections of values that each have a stable identifier, it doesn’t do much to improve the actual type safety of our code.</p><p>Since all that <code>Identifiable</code> does is requiring us to define any hashable <code>id</code> property, it won’t protect us from accidentally mixing up identifiers — such as in this situation, when we’re mistakenly passing a <code>User</code> ID to a function that accepts a <code>Video</code> ID:</p><pre class="splash"><code><span class="s-call">postComment</span>(comment, onVideoWithID: user.<span class="s-property">id</span>)</code></pre><p>So there’s still quite a lot of strong use cases for a proper <code>Identifier</code> type and a more robust <code>Identifiable</code> protocol — such as the ones we took a look at in <em><a href="https://www.swiftbysundell.com/articles/type-safe-identifiers-in-swift">“Type-safe identifiers in Swift”</a></em>, which prevents the above kind of mistakes from happening. However, it’s still really nice to now have <em>some</em> version of an <code>Identifiable</code> protocol in the standard library, even if it is a bit more limited.</p><h2>Ordered collection diffing</h2><p>Finally, let’s take a look at a brand new standard library API that’s being introduced as part of Swift 5.1 — ordered collection diffing. As we, as a community, move closer and closer to the world of declarative programming with tools like Combine and SwiftUI — being able to calculate the difference between two states is something that becomes increasingly important.</p><p>After all, declarative UI development is all about continuously rendering new snapshots of state — and while SwiftUI and the new <a href="https://wwdcbysundell.com/2019/diffable-data-sources-first-look">diffable data sources</a> will probably do most of the heavy lifting to make that happen — being able to calculate a diff between two states ourselves could be incredibly useful.</p><p>For example, let’s say that we’re building a <code>DatabaseController</code> that’ll let us easily update our on-disk database with an array of in-memory models. To be able to figure out whether a model should be inserted or deleted, we can now simply call the new <code>difference</code> API to calculate the diff between our old array and the new one — and then iterate through the changes within that diff in order to perform our database operations:</p><pre class="splash"><code><span class="s-keyword">class</span> DatabaseController&lt;Model: <span class="s-type">Hashable</span> &amp; <span class="s-type">Identifiable</span>&gt; {
    <span class="s-keyword">private let</span> database: <span class="s-type">Database</span>
    <span class="s-keyword">private(set) var</span> models: [<span class="s-type">Model</span>] = []
    
    ...

    <span class="s-keyword">func</span> update(with newModels: [<span class="s-type">Model</span>]) {
        <span class="s-keyword">let</span> diff = newModels.<span class="s-call">difference</span>(from: models)

        <span class="s-keyword">for</span> change <span class="s-keyword">in</span> diff {
            <span class="s-keyword">switch</span> change {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">_</span>):
                database.<span class="s-call">insert</span>(model)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">_</span>):
                database.<span class="s-call">delete</span>(model)
            }
        }

        models = newModels
    }
}</code></pre><p>However, the above implementation does not account for moved models — since moves will, by default, be treated as separate insertions and removals. To fix that, let’s also call the <code>inferringMoves</code> method when computing our diff — and then look at whether each insert was associated with a removal, and if so treat it as a move instead, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> update(with newModels: [<span class="s-type">Model</span>]) {
    <span class="s-keyword">let</span> diff = newModels.<span class="s-call">difference</span>(from: models).<span class="s-call">inferringMoves</span>()
    
    <span class="s-keyword">for</span> change <span class="s-keyword">in</span> diff {
        <span class="s-keyword">switch</span> change {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> model, <span class="s-keyword">let</span> association):
            <span class="s-comment">// If the associated index isn't nil, that means
            // that the insert is associated with a removal,
            // and we can treat it as a move.</span>
            <span class="s-keyword">if</span> association != <span class="s-keyword">nil</span> {
                database.<span class="s-call">move</span>(model, toIndex: index)
            } <span class="s-keyword">else</span> {
                database.<span class="s-call">insert</span>(model)
            }
        <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">let</span> association):
            <span class="s-comment">// We'll only process removals if the associated
            // index is nil, since otherwise we will already
            // have handled that operation as a move above.</span>
            <span class="s-keyword">if</span> association == <span class="s-keyword">nil</span> {
                database.<span class="s-call">delete</span>(model)
            }
        }
    }
    
    models = newModels
}</code></pre><p>The fact that diffing is now built into the standard library (and also into UIKit and AppKit) is fantastic news — as writing an efficient, flexible, and robust diffing algorithm can be incredibly difficult.</p><h2>Conclusion</h2><p>Not only is Swift 5.1 a key enabler for SwiftUI and Combine, it’s also big news for any team that vends pre-compiled frameworks, as Swift is now not only ABI stable, but also module stable. On top of that, Swift 5.1 also includes many small but welcome changes and tweaks that should be applicable to almost any code base — and while we’ve taken a look at five of those changes in this article, we’ll keep diving deeper into more aspects of Swift 5.1 within the coming weeks and months.</p><p>The reason no SwiftUI-related features were included in this article is that those were covered in <em><a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">“The Swift 5.1 features that power SwiftUI’s API”</a></em>. The same is also true for static subscripts, which were covered in <em><a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">“The power of subscripts in Swift”</a></em>.</p><p>What do you think? Have you already migrated your projects to Swift 5.1, and if so, what’s your favorite new feature? Let me know — along with any questions, comments or feedback that you might have — either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/gathering-test-coverage-in-xcode</guid><title>Tip: Gathering test coverage in Xcode</title><description>How to enable and use test coverage in Xcode.</description><link>https://www.swiftbysundell.com/tips/gathering-test-coverage-in-xcode</link><pubDate>Wed, 18 Sep 2019 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Measuring the degree to which a project’s suite of unit tests covers its code base can be a great way to identify code paths that aren’t yet tested. While coverage data doesn’t tell us anything about the <em>quality</em> of our tests, it can still be an incredibly useful tool — especially when retrofitting a code base with tests, or when we’re unsure whether a certain condition or state is actually being tested.</p><p>However, Xcode won’t gather test coverage by default, but thankfully it’s really easy to enable. Start by pressing <code>⌥⌘U</code> to bring up the current target’s test settings. Then open the <em>Options</em> tab, and check the <em>Code Coverage</em> checkbox, like this:</p><img src="https://www.swiftbysundell.com/images/tips/enabling-code-coverage.png" alt="How to enable code coverage"/><p>That’s it! Next, let’s actually make use of the coverage data that from now on will be generated each time we run our tests. One way to do that is to open up the <em>Report Navigator</em> (<code>⌘9</code>), which will now show a coverage report for each subsequent testing session:</p><img src="https://www.swiftbysundell.com/images/tips/accessing-code-coverage-reports.png" alt="How to access code coverage reports"/><p>Finally, we can also enable our new coverage data to be shown inline as we’re coding. While some developers might find that distracting, it can be a great way to quickly spot code paths that need testing. To turn that on, use the <em>Adjust Editor Options</em> button located in the top-right corner of each editor:</p><img src="https://www.swiftbysundell.com/images/tips/showing-code-coverage-inline.png" alt="How to display code coverage inline"/><p>As you can see above, any code paths that aren’t yet tested will now be highlighted using a red bar, and the iteration count will also be shown for all other paths. Really nice!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager</guid><title>Managing dependencies using the Swift Package Manager</title><description>Starting with Xcode 11, the Swift Package Manager is becoming a true first class citizen within Apple’s suite of developer tools. Let’s take a look at how it can be used to manage a project’s various dependencies.</description><link>https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager</link><pubDate>Sun, 15 Sep 2019 21:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When Swift was open sourced at the end of 2015, one of the most surprising and interesting new projects that was introduced along with it, was the <em>Swift Package Manager</em>. While it wasn’t the first dependency manager for Swift projects, it was the first that was officially provided and supported by Apple, which many developers saw as really good news.</p><p>However, while the server-side Swift community quickly embraced the Swift Package Manager as the go-to tool for managing dependencies when building server applications, it’s taken quite a while for it to become fully integrated into the rest of Apple’s developer toolchains.</p><p>But now, starting with Xcode 11, the Swift Package Manager is finally becoming a true <em>first class citizen</em> within Apple’s suite of developer tools — so this week, let’s take a look at how it can be used to manage a project’s various dependencies — both internal and external ones.</p><h2>The anatomy of a Swift package</h2><p>A <em>Swift Package</em> is essentially a group of Swift source files that are compiled together to form a <em>Module</em> — which can then be shared and imported into other projects as one unit. Packages can either be public libraries that are shared using services like GitHub, or internal tools and frameworks that are only shared within a small number of projects.</p><p>The contents of a package is declared using a <code>Package.swift</code> <em>manifest file</em>, which is placed in the root directory of each package. Rather than using a data format, like JSON or XML, Swift package manifest files are written using actual Swift code — with a <code>Package</code> instance representing the declaration of the package.</p><p>As an example, let’s say that we’re working on a todo list app, and that we want to create a <code>TodoKit</code> package for all of our core logic that’s shared across the app — including things like our database layer, our model code, and so on. To get started, we’ll create a new folder (with a name that matches what we want our package to be called), and we’ll then run <code>swift package init</code> within it to create our package:</p><pre><code class="no-highlight">$ mkdir TodoKit
$ cd TodoKit
$ swift package init</code></pre><p class="info">In Xcode 11, we can also perform the above setup using the <code>File &gt; New &gt; Swift Package</code> menu command.</p><p>By doing the above, the Swift Package Manager will now have created an initial structure for our new package — which includes a <code>Package.swift</code> manifest file that looks something like this:</p><pre class="splash"><code><span class="s-comment">// swift-tools-version:5.1</span>

<span class="s-keyword">import</span> PackageDescription

<span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"TodoKit"</span>,
    products: [
        <span class="s-comment">// The external product of our package is an importable
        // library that has the same name as the package itself:</span>
        .<span class="s-call">library</span>(
            name: <span class="s-string">"TodoKit"</span>,
            targets: [<span class="s-string">"TodoKit"</span>]
        )
    ],
    targets: [
        <span class="s-comment">// Our package contains two targets, one for our library
        // code, and one for our tests:</span>
        .<span class="s-call">target</span>(name: <span class="s-string">"TodoKit"</span>),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p class="info">The <code>swift-tools-version</code> comment at the top of the file isn’t just a comment, it also tells the Swift Package Manager what version of the Swift toolchain to use when building our package.</p><p>By default, the Swift Package Manager will match the names of the targets defined within our manifest file with corresponding folders on disk in order to determine what Swift files that belong to each target. That behavior, along with other defaults — such as build settings, target platforms, etc. — can be overridden by passing additional parameters to the APIs used above.</p><h2>Adding remote dependencies</h2><p>Besides facilitating the creation of packages, one of the Swift Package Manager’s core use cases is enabling remote dependencies — such as third party libraries — to be added to a project. Any package that can be fetched through Git can be added simply by specifying its URL, as well as the <em>version constraint</em> that we wish to apply to it:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    ...
    dependencies: [
        <span class="s-comment">// Here we define our package's external dependencies
        // and from where they can be fetched:</span>
        .<span class="s-call">package</span>(
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>, 
            from: <span class="s-string">"4.0.0"</span>
        )
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"TodoKit"</span>,
            <span class="s-comment">// Here we add our new dependency to our main target,
            // which lets us import it within that target's code:</span>
            dependencies: [<span class="s-string">"Files"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p>Above we’re importing <em>any version</em> of the <a href="https://github.com/JohnSundell/Files">Files package</a> between <code>4.0.0</code> and <code>5.0.0</code> — leaving it up to the Swift Package Manager to resolve the most appropriate version that satisfies our overall dependency graph, while defaulting to the latest version within that range.</p><p>Using such a broad version constraint can be really powerful, since if we were to add another dependency that requires a specific version of Files, the package manager would be free to pick that version (as long as it’s within our allowed version range) — making it less likely that we’ll end up with an unresolvable dependency graph.</p><p>However, sometimes we might want to lock onto a specific version of one of our dependencies — perhaps to avoid a regression that was introduced in a later version, or to be able to keep using an API that was later removed. To do that, we can replace the above <code>from:</code> parameter with the <code>.exact</code> version requirement — like this:</p><pre class="splash"><code>.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">exact</span>(<span class="s-string">"4.0.0"</span>)
)</code></pre><p>On the other hand, we might instead want to use a dependency revision that’s <em>further ahead</em> than the latest official release — for example to include a bug fix or a new API that hasn’t been properly released yet. To do that, we have two options.</p><p>The first option is to point our dependency to a specific Git branch (which can be quite risky if that branch is rapidly changing), or to lock onto a specific commit hash (which is less risky, but also less flexible, since we’ll have to manually change that hash each time we want to update that dependency):</p><pre class="splash"><code><span class="s-comment">// Depending on a branch (master in this case):</span>
.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">branch</span>(<span class="s-string">"master"</span>)
)

<span class="s-comment">// Depending on an exact commit:</span>
.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">revision</span>(<span class="s-string">"0e0c6aca147add5d5750ecb7810837ef4fd10fc2"</span>)
)</code></pre><p>Being able to specify dependencies not only by version, but by Git revision as well, can also be really useful in order to temporarily fetch a dependency from a forked repository, rather than from its original one.</p><p>For example, let’s say that we’ve discovered a bug in one of our external dependencies, and that we’ve implemented a fix for it within our fork of that project. Rather than having to wait for that fix to be merged into the original repository, and then released — we can simply point that dependency to the URL of our fork, and then specify <code>master</code> as our branch target, to be able to directly use our patched version.</p><h2>Using local packages</h2><p>When working on several different packages in parallel, for example when splitting a project up into multiple smaller libraries, using <em>local dependencies</em> can sometimes be really useful — and drastically improve iteration times.</p><p>Rather than being downloaded from a URL, local package dependencies are simply added directly from a folder on disk — which both lets us import our own packages without having to worry about versioning, and also enables us to directly edit a dependency’s source files within the project that’s using it.</p><p>For example, here’s how we could add a local <code>CalendarKit</code> package as a dependency to <code>TodoKit</code> — simply by specifying its relative folder path:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    ...
    dependencies: [
        .<span class="s-call">package</span>(
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
            .<span class="s-call">exact</span>(<span class="s-string">"4.0.0"</span>)
        ),
        <span class="s-comment">// Using 'path', we can depend on a local package that's
        // located at a given path relative to our package's folder:</span>
        .<span class="s-call">package</span>(path: <span class="s-string">"../CalendarKit"</span>)
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"TodoKit"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"CalendarKit"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p>Besides being able to directly edit dependencies, local package references are also really useful when building custom developer tools. For example, we could use the Swift Package Manager to <a href="https://www.swiftbysundell.com/articles/building-a-command-line-tool-using-the-swift-package-manager">build a command line tool</a> within an app’s repository, and then use a local dependency to import some of our app code into that tool — like our model or networking code, for example.</p><h2>Platform and OS version constraints</h2><p>Apart from the internal packages and third party libraries that we’ve explicitly added to a project, our code will most likely also depend on a specific range of platforms and operating system versions — in order to have access to the right APIs and system frameworks.</p><p>While all Swift packages are assumed to be cross-platform (and version agnostic) by default, by adding the <code>platform</code> parameter when initializing our <code>Package</code> within our manifest file, we can constrain our code to only support a given set of platforms and OS versions — like this, if we wanted to build a package that contains iOS 13-specific code:</p><pre class="splash"><code><span class="s-comment">// swift-tools-version:5.1</span>

<span class="s-keyword">import</span> PackageDescription

<span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"TodoSwiftUIComponents"</span>,
    platforms: [.<span class="s-call">iOS</span>(.<span class="s-dotAccess">v13</span>)],
    ...
)</code></pre><p>Just like when picking a minimum deployment target for an app in Xcode, using the <code>platforms</code> parameter enables us to use APIs that are only available on a subset of platforms or OS versions — such as SwiftUI or Combine. We can of course also specify multiple platforms and version as well — for example, we could append <code>.macOS(.v10_15)</code> to the above array to also add support for macOS Catalina.</p><h2>Adding packages to an Xcode project</h2><p>Starting with Xcode 11, Swift packages can now be directly added and imported into an app project using Xcode’s new <code>Swift Packages</code> option, which is located within the <code>File</code> menu. Using this new integration both enables us to easily import third party libraries as Swift packages, and it can also let us leverage the power of the Swift Package Manager to improve the modularity of our code base.</p><p>By creating separate packages for different parts of our code base — just like the <code>TodoKit</code>, <code>CalendarKit</code>, and <code>TodoSwiftUIComponents</code> examples from before — we can both improve the separation of concerns within our app, and also enable our code to be easily reused across different platforms or extensions.</p><p>For example, by defining our UI components in a separate package from our model code, there’s no risk of accidentally <a href="https://www.swiftbysundell.com/articles/preventing-views-from-being-model-aware-in-swift">mixing view code with model code</a> — which can help us maintain a much more solid architecture over time — and it also enables us to easily share our core UI components between multiple targets.</p><h2>Conclusion</h2><p>While the Swift Package Manager isn’t really a brand new tool anymore, the fact that it can now be used for apps on all of Apple’s platforms gives it a much wider appeal — and kind of feels like a <em>“new beginning”</em> for Swift packages as a concept. Being able to use the same package manager to build anything from server-side applications, to command line tools and scripts, to iOS apps, is also incredibly powerful — and could potentially enable parts of our code to be reused in even more contexts.</p><p>What do you think? Have you used the Swift Package Manager before, or will you try it out now that it’s integrated into Xcode? Let me know — along with your questions, comments or feedback — either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/swiftui</guid><title>Basics: SwiftUI</title><description>A recap of the basics of SwiftUI, Apple’s declarative new UI framework for building apps across all of their platforms. How to build custom views and modify existing ones, how to manage local state within a view, and how to compose multiple views to form new ones.</description><link>https://www.swiftbysundell.com/basics/swiftui</link><pubDate>Thu, 12 Sep 2019 21:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Apple’s new declarative UI framework, SwiftUI, offers a brand new way to construct views across all Apple platforms. Rather than explicitly programming instructions as to how each view should be rendered, with SwiftUI, we’re instead <em>declaring</em> what we want the end result of our UI to be — letting us leverage the framework to do most of the actual rendering work for us.</p><p>When using SwiftUI, each view is essentially a description of a single piece of our UI — both in terms of how it’ll look and behave in terms of layout, as well as how it should handle user interactions and other events. As an example, here’s a <code>ProductView</code> that shows information about a product within a shopping app — by conforming to SwiftUI’s <code>View</code> protocol, and then returning its subviews through its computed <code>body</code> property:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// We'll render our product view as a vertical stack
        // containing the product's image, name, and price:</span>
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
            <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
            <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
        }
    }
}</code></pre><p class="info">The syntax used above may at first seem a bit unfamiliar. That’s because SwiftUI makes heavy use of a few key new features introduced in Swift 5.1. To learn more about those, check out <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">“The Swift 5.1 features that power SwiftUI’s API”</a>.</p><p>What’s interesting about the above implementation, especially if compared to UI code written using Apple’s older frameworks (like UIKit and AppKit), is that it doesn’t contain any layout instructions, apart from its <code>VStack</code>. That’s really one of the core advantages of SwiftUI — since we’re no longer dealing with view objects that need to be explicitly positioned and sized, but rather with view descriptions, it lets the system make many different kinds of layout decisions on our behalf.</p><p>Besides <code>VStack</code>, SwiftUI offers two other main stack types that can be used to leverage its automatic layout system — <code>HStack</code> and <code>ZStack</code>. For example, here’s how we could wrap our <em>name</em> and <em>price</em> labels in an <code>HStack</code> to render them side-by-side, rather than stacking them vertically:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
        
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
            }
        }
    }
}</code></pre><p>Finally, the <code>ZStack</code> type can be used to stack views in terms of depth — which comes very much in handy when adding some form of background to a view. For example, here’s how we could give our <code>ProductView</code> a gradient background, by placing a <code>LinearGradient</code> on top of our previous <code>VStack</code>, and then wrapping both within a <code>ZStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">LinearGradient</span>(
                gradient: <span class="s-type">Gradient</span>(colors: [.<span class="s-dotAccess">red</span>, .<span class="s-dotAccess">blue</span>]),
                startPoint: .<span class="s-dotAccess">topLeading</span>,
                endPoint: .<span class="s-dotAccess">bottomTrailing</span>
            ).<span class="s-call">edgesIgnoringSafeArea</span>(.<span class="s-dotAccess">all</span>)
            
            <span class="s-type">VStack</span> {
                <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
            
                <span class="s-type">HStack</span> {
                    <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                    <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
                }
            }
        }
    }
}</code></pre><p class="info">The reason we call <code>edgesIgnoringSafeArea</code> above is to make our gradient extend beyond the safe area insets of our view, which will make it fill the entire screen on all devices.</p><p>While it’s really convenient to be able to quickly add all of our views in one place, doing so tends to get a bit messy once we reach a certain number of views or levels of indentation. Thankfully, since SwiftUI is all about building views as separate component-like building blocks, extracting parts of a view into its own type is often quite trivial.</p><p>Let’s do exactly that, and split our <code>ProductView</code> up into two separate subviews instead — one for our gradient, and one for displaying our product info:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductGradientView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">LinearGradient</span>(
            gradient: <span class="s-type">Gradient</span>(colors: [.<span class="s-dotAccess">red</span>, .<span class="s-dotAccess">blue</span>]),
            startPoint: .<span class="s-dotAccess">topLeading</span>,
            endPoint: .<span class="s-dotAccess">bottomTrailing</span>
        ).<span class="s-call">edgesIgnoringSafeArea</span>(.<span class="s-dotAccess">all</span>)
    }
}

<span class="s-keyword">struct</span> ProductInfoView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
        
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
            }
        }
    }
}</code></pre><p>With those two new views in place, we can now simply make <code>ProductView</code> <em><a href="https://www.swiftbysundell.com/articles/composing-types-in-swift">compose them</a></em> into our final UI, making our code a lot easier to read:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">ProductGradientView</span>()
            <span class="s-type">ProductInfoView</span>(product: product)
        }
    }
}</code></pre><p>Another way that SwiftUI enables us to create custom views is by applying <em>modifiers</em> to existing ones. For example, here’s how we could use modifiers to turn our product label bold, as well as limit its text to two lines — and also change the text color of our price label:</p><pre class="splash"><code><span class="s-type">HStack</span> {
    <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">bold</span>().<span class="s-call">lineLimit</span>(<span class="s-number">2</span>)
    <span class="s-type">Text</span>(product.<span class="s-property">price</span>).<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
}</code></pre><p>Besides defining what our views will look like in terms of visuals, another important aspect of any kind of UI development is keeping track of state — both when it comes to handling user input, and to ensure that our UI gets properly updated as our state changes. While we’ll explore all of SwiftUI’s various state handling APIs in much more detail in upcoming articles, let’s start by taking a look at how the new <code>@State</code> property wrapper can be used to manage <em>local state</em> within a view.</p><p>Let’s say that we wanted to add a stepper to our product view that lets the user pick the number of items to order. To do that, we both need to display the current quantity of items, and also modify it whenever the user interacted with our stepper — in order words, we need to establish a <em>two-way binding</em> between our UI and the state (the quantity of items) that it depends on.</p><p>Since our state will only be read and modified within our view, let’s define it using a <code>@State</code> property, which will enable us to establish such a two-way binding between our new property and the stepper that’ll render and modify it:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-comment">// Using the '@State' property wrapper we can define pieces
    // of state that are local (private) to the current view:</span>
    <span class="s-keyword">@State private var</span> quantity = <span class="s-number">1</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">ProductGradientView</span>()

            <span class="s-type">VStack</span> {
                <span class="s-type">ProductInfoView</span>(product: product)

                <span class="s-comment">// Here we can both directly interpolate our value
                // into the stepper's label, and also bind it to
                // the stepper itself, enabling it to be modified:</span>
                <span class="s-type">Stepper</span>(<span class="s-string">"Quantity:</span> \(quantity)<span class="s-string">"</span>,
                    value: $quantity,
                    in: <span class="s-number">1</span>...<span class="s-number">99</span>
                ).<span class="s-call">padding</span>()
            }
        }
    }
}</code></pre><p class="info">The reason we prefix our <code>quantity</code> property with <code>$</code> when injecting it as our stepper’s <code>value</code> above is because we want to pass a reference to the wrapped <code>@State</code> property, rather than its current <code>Int</code> value.</p><p>It’s quite clear that SwiftUI isn’t <em>just</em> a new UI framework — it’s a substantial paradigm shift in terms of how apps are built for Apple’s platforms. It’ll definitely take a while to get used to, and it’ll also take some time for common patterns and best practices to emerge, given that many of the patterns we might have used in the past won’t be directly compatible with SwiftUI’s very declarative structure. But it’s a really exciting time to be an Apple platforms developer, isn’t it?</p><p>Thanks for reading! 🚀</p>]]></content:encoded></item></channel></rss>